// PRIM Algorithm Code Templates
// Templates for all supported languages

export const PRIM_TEMPLATES = {
  cpp: [
    { key: "prim_init", text: "#include <queue>" },
    { key: "prim_init", text: "vector<double> key(n, INF); vector<int> parent(n, -1); vector<bool> inMST(n, false);" },
    { key: "prim_init", text: "key[s] = 0;" },
    { key: "prim_init", text: "priority_queue<pair<double, int>, vector<pair<double, int>>, greater<>> pq; pq.push({0, s});" },
    { key: "prim_extract", text: "while (!pq.empty()) {" },
    { key: "prim_extract", text: "  auto [key_u, u] = pq.top(); pq.pop();" },
    { key: "prim_extract", text: "  if (inMST[u]) continue;" },
    { key: "prim_extract", text: "  inMST[u] = true;" },
    { key: "prim_relax", text: "  for (auto &[v, w] : adj[u]) {" },
    { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
    { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
    { key: "prim_relax", text: "          pq.push({key[v], v});" },
    { key: "prim_relax", text: "      }" },
    { key: "prim_relax", text: "  }" },
    { key: "prim_extract", text: "}" },
    { key: "prim_done", text: "// MST constructed" },
  ],
  c: [
    { key: "prim_init", text: "// Note: C doesn't have built-in priority queue" },
    { key: "prim_init", text: "// Use array-based approach or implement min-heap" },
    { key: "prim_init", text: "double key[n]; int parent[n]; bool inMST[n];" },
    { key: "prim_init", text: "for (int i = 0; i < n; i++) { key[i] = INF; parent[i] = -1; inMST[i] = false; }" },
    { key: "prim_init", text: "key[s] = 0;" },
    { key: "prim_extract", text: "for (int count = 0; count < n; count++) {" },
    { key: "prim_extract", text: "  int u = -1; double min_key = INF;" },
    { key: "prim_extract", text: "  for (int i = 0; i < n; i++)" },
    { key: "prim_extract", text: "      if (!inMST[i] && key[i] < min_key) { u = i; min_key = key[i]; }" },
    { key: "prim_extract", text: "  if (u == -1) break; inMST[u] = true;" },
    { key: "prim_relax", text: "  for (each edge (u, v, w) in adj[u]) {" },
    { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
    { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
    { key: "prim_relax", text: "      }" },
    { key: "prim_relax", text: "  }" },
    { key: "prim_extract", text: "}" },
    { key: "prim_done", text: "// MST constructed" },
  ],
  java: [
    { key: "prim_init", text: "import java.util.*;" },
    { key: "prim_init", text: "double[] key = new double[n]; int[] parent = new int[n]; boolean[] inMST = new boolean[n];" },
    { key: "prim_init", text: "Arrays.fill(key, Double.POSITIVE_INFINITY); Arrays.fill(parent, -1); key[s] = 0;" },
    { key: "prim_init", text: "PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Double.compare(a[0], b[0]));" },
    { key: "prim_init", text: "pq.offer(new int[]{0, s});" },
    { key: "prim_extract", text: "while (!pq.isEmpty()) {" },
    { key: "prim_extract", text: "  int[] curr = pq.poll(); double key_u = curr[0]; int u = curr[1];" },
    { key: "prim_extract", text: "  if (inMST[u]) continue;" },
    { key: "prim_extract", text: "  inMST[u] = true;" },
    { key: "prim_relax", text: "  for (Edge e : adj[u]) {" },
    { key: "prim_relax", text: "      int v = e.v; double w = e.w;" },
    { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
    { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
    { key: "prim_relax", text: "          pq.offer(new int[]{(int)key[v], v});" },
    { key: "prim_relax", text: "      }" },
    { key: "prim_relax", text: "  }" },
    { key: "prim_extract", text: "}" },
    { key: "prim_done", text: "// MST constructed" },
  ],
  python: [
    { key: "prim_init", text: "import heapq" },
    { key: "prim_init", text: "key = {v: float('inf') for v in V}; parent = {v: None for v in V}" },
    { key: "prim_init", text: "key[s] = 0" },
    { key: "prim_init", text: "pq = [(0, s)]; in_mst = set()" },
    { key: "prim_extract", text: "while pq:" },
    { key: "prim_extract", text: "  key_u, u = heapq.heappop(pq)" },
    { key: "prim_extract", text: "  if u in in_mst: continue" },
    { key: "prim_extract", text: "  in_mst.add(u)" },
    { key: "prim_relax", text: "  for (v, w) in adj[u]:" },
    { key: "prim_relax", text: "      if v not in in_mst and w < key[v]:" },
    { key: "prim_relax", text: "          key[v] = w; parent[v] = u" },
    { key: "prim_relax", text: "          heapq.heappush(pq, (key[v], v))" },
    { key: "prim_done", text: "# MST constructed" },
  ],
  rust: [
    { key: "prim_init", text: "use std::collections::BinaryHeap;" },
    { key: "prim_init", text: "let mut key = vec![f64::INFINITY; n]; let mut parent = vec![None; n]; let mut in_mst = vec![false; n];" },
    { key: "prim_init", text: "key[s] = 0.0;" },
    { key: "prim_init", text: "let mut pq = BinaryHeap::new(); pq.push(std::cmp::Reverse((0.0, s)));" },
    { key: "prim_extract", text: "while let Some(std::cmp::Reverse((key_u, u))) = pq.pop() {" },
    { key: "prim_extract", text: "  if in_mst[u] { continue; }" },
    { key: "prim_extract", text: "  in_mst[u] = true;" },
    { key: "prim_relax", text: "  for &(v, w) in &adj[u] {" },
    { key: "prim_relax", text: "      if !in_mst[v] && w < key[v] {" },
    { key: "prim_relax", text: "          key[v] = w; parent[v] = Some(u);" },
    { key: "prim_relax", text: "          pq.push(std::cmp::Reverse((key[v], v)));" },
    { key: "prim_relax", text: "      }" },
    { key: "prim_relax", text: "  }" },
    { key: "prim_extract", text: "}" },
    { key: "prim_done", text: "// MST constructed" },
  ],
  typescript: [
    { key: "prim_init", text: "const key = Array(n).fill(Infinity); const parent = Array(n).fill(null); const inMST = Array(n).fill(false);" },
    { key: "prim_init", text: "key[s] = 0;" },
    { key: "prim_init", text: "const pq = [[0, s]];" },
    { key: "prim_extract", text: "while (pq.length > 0) {" },
    { key: "prim_extract", text: "  pq.sort((a, b) => a[0] - b[0]);" },
    { key: "prim_extract", text: "  const [key_u, u] = pq.shift();" },
    { key: "prim_extract", text: "  if (inMST[u]) continue;" },
    { key: "prim_extract", text: "  inMST[u] = true;" },
    { key: "prim_relax", text: "  for (const [v, w] of adj[u]) {" },
    { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
    { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
    { key: "prim_relax", text: "          pq.push([key[v], v]);" },
    { key: "prim_relax", text: "      }" },
    { key: "prim_relax", text: "  }" },
    { key: "prim_extract", text: "}" },
    { key: "prim_done", text: "// MST constructed" },
  ],
  go: [
    { key: "prim_init", text: "import (\"container/heap\")" },
    { key: "prim_init", text: "key := make([]float64, n); parent := make([]int, n); inMST := make([]bool, n)" },
    { key: "prim_init", text: "for i := range key { key[i] = math.Inf(1); parent[i] = -1 }" },
    { key: "prim_init", text: "key[s] = 0" },
    { key: "prim_init", text: "pq := &PriorityQueue{}; heap.Init(pq); heap.Push(pq, Item{0, s})" },
    { key: "prim_extract", text: "for pq.Len() > 0 {" },
    { key: "prim_extract", text: "  item := heap.Pop(pq).(Item); key_u, u := item.priority, item.value" },
    { key: "prim_extract", text: "  if inMST[u] { continue }" },
    { key: "prim_extract", text: "  inMST[u] = true" },
    { key: "prim_relax", text: "  for _, e := range adj[u] {" },
    { key: "prim_relax", text: "      v, w := e.v, e.w" },
    { key: "prim_relax", text: "      if !inMST[v] && w < key[v] {" },
    { key: "prim_relax", text: "          key[v] = w; parent[v] = u" },
    { key: "prim_relax", text: "          heap.Push(pq, Item{key[v], v})" },
    { key: "prim_relax", text: "      }" },
    { key: "prim_relax", text: "  }" },
    { key: "prim_extract", text: "}" },
    { key: "prim_done", text: "// MST constructed" },
  ],
  kotlin: [
    { key: "prim_init", text: "import java.util.*" },
    { key: "prim_init", text: "val key = DoubleArray(n) { Double.POSITIVE_INFINITY }" },
    { key: "prim_init", text: "val parent = IntArray(n) { -1 }" },
    { key: "prim_init", text: "val inMST = BooleanArray(n)" },
    { key: "prim_init", text: "key[s] = 0.0" },
    { key: "prim_init", text: "val pq = PriorityQueue<Pair<Double, Int>>(compareBy { it.first })" },
    { key: "prim_init", text: "pq.add(0.0 to s)" },
    { key: "prim_extract", text: "while (pq.isNotEmpty()) {" },
    { key: "prim_extract", text: "  val (key_u, u) = pq.poll()" },
    { key: "prim_extract", text: "  if (inMST[u]) continue" },
    { key: "prim_extract", text: "  inMST[u] = true" },
    { key: "prim_relax", text: "  adj[u].forEach { (v, w) ->" },
    { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
    { key: "prim_relax", text: "          key[v] = w; parent[v] = u" },
    { key: "prim_relax", text: "          pq.add(key[v] to v)" },
    { key: "prim_relax", text: "      }" },
    { key: "prim_relax", text: "  }" },
    { key: "prim_extract", text: "}" },
    { key: "prim_done", text: "// MST constructed" },
  ],
  swift: [
    { key: "prim_init", text: "import Foundation" },
    { key: "prim_init", text: "var key = Array(repeating: Double.infinity, count: n)" },
    { key: "prim_init", text: "var parent = Array(repeating: -1, count: n)" },
    { key: "prim_init", text: "var inMST = Array(repeating: false, count: n)" },
    { key: "prim_init", text: "key[s] = 0" },
    { key: "prim_init", text: "var pq = [(0.0, s)]" },
    { key: "prim_extract", text: "while !pq.isEmpty {" },
    { key: "prim_extract", text: "  pq.sort { $0.0 < $1.0 }" },
    { key: "prim_extract", text: "  let (key_u, u) = pq.removeFirst()" },
    { key: "prim_extract", text: "  if inMST[u] { continue }" },
    { key: "prim_extract", text: "  inMST[u] = true" },
    { key: "prim_relax", text: "  for (v, w) in adj[u] {" },
    { key: "prim_relax", text: "      if !inMST[v] && w < key[v] {" },
    { key: "prim_relax", text: "          key[v] = w; parent[v] = u" },
    { key: "prim_relax", text: "          pq.append((key[v], v))" },
    { key: "prim_relax", text: "      }" },
    { key: "prim_relax", text: "  }" },
    { key: "prim_extract", text: "}" },
    { key: "prim_done", text: "// MST constructed" },
  ],
  csharp: [
    { key: "prim_init", text: "using System.Collections.Generic;" },
    { key: "prim_init", text: "double[] key = new double[n]; int[] parent = new int[n]; bool[] inMST = new bool[n];" },
    { key: "prim_init", text: "Array.Fill(key, double.PositiveInfinity); Array.Fill(parent, -1); key[s] = 0;" },
    { key: "prim_init", text: "var pq = new PriorityQueue<int, double>(); pq.Enqueue(s, 0);" },
    { key: "prim_extract", text: "while (pq.Count > 0) {" },
    { key: "prim_extract", text: "  pq.TryDequeue(out int u, out double key_u);" },
    { key: "prim_extract", text: "  if (inMST[u]) continue;" },
    { key: "prim_extract", text: "  inMST[u] = true;" },
    { key: "prim_relax", text: "  foreach (var (v, w) in adj[u]) {" },
    { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
    { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
    { key: "prim_relax", text: "          pq.Enqueue(v, key[v]);" },
    { key: "prim_relax", text: "      }" },
    { key: "prim_relax", text: "  }" },
    { key: "prim_extract", text: "}" },
    { key: "prim_done", text: "// MST constructed" },
  ],
  ruby: [
    { key: "prim_init", text: "require 'set'" },
    { key: "prim_init", text: "key = Hash.new(Float::INFINITY); parent = {}; in_mst = Set.new" },
    { key: "prim_init", text: "key[s] = 0" },
    { key: "prim_init", text: "pq = [[0, s]]" },
    { key: "prim_extract", text: "until pq.empty?" },
    { key: "prim_extract", text: "  pq.sort_by! { |x| x[0] }" },
    { key: "prim_extract", text: "  key_u, u = pq.shift" },
    { key: "prim_extract", text: "  next if in_mst.include?(u)" },
    { key: "prim_extract", text: "  in_mst.add(u)" },
    { key: "prim_relax", text: "  adj[u].each do |v, w|" },
    { key: "prim_relax", text: "      unless in_mst.include?(v)" },
    { key: "prim_relax", text: "          if w < key[v]" },
    { key: "prim_relax", text: "              key[v] = w; parent[v] = u; pq << [key[v], v]" },
    { key: "prim_relax", text: "          end" },
    { key: "prim_relax", text: "      end" },
    { key: "prim_relax", text: "  end" },
    { key: "prim_extract", text: "end" },
    { key: "prim_done", text: "# MST constructed" },
  ],
  php: [
    { key: "prim_init", text: "$key = array_fill(0, $n, INF); $parent = array_fill(0, $n, -1); $inMST = array_fill(0, $n, false);" },
    { key: "prim_init", text: "$key[$s] = 0;" },
    { key: "prim_init", text: "$pq = [[0, $s]];" },
    { key: "prim_extract", text: "while (!empty($pq)) {" },
    { key: "prim_extract", text: "  usort($pq, function($a, $b) { return $a[0] - $b[0]; });" },
    { key: "prim_extract", text: "  list($key_u, $u) = array_shift($pq);" },
    { key: "prim_extract", text: "  if ($inMST[$u]) continue;" },
    { key: "prim_extract", text: "  $inMST[$u] = true;" },
    { key: "prim_relax", text: "  foreach ($adj[$u] as [$v, $w]) {" },
    { key: "prim_relax", text: "      if (!$inMST[$v] && $w < $key[$v]) {" },
    { key: "prim_relax", text: "          $key[$v] = $w; $parent[$v] = $u;" },
    { key: "prim_relax", text: "          array_push($pq, [$key[$v], $v]);" },
    { key: "prim_relax", text: "      }" },
    { key: "prim_relax", text: "  }" },
    { key: "prim_extract", text: "}" },
    { key: "prim_done", text: "// MST constructed" },
  ],
  scala: [
    { key: "prim_init", text: "import scala.collection.mutable" },
    { key: "prim_init", text: "val key = Array.fill(n)(Double.PositiveInfinity)" },
    { key: "prim_init", text: "val parent = Array.fill(n)(-1)" },
    { key: "prim_init", text: "val inMST = Array.fill(n)(false)" },
    { key: "prim_init", text: "key(s) = 0.0" },
    { key: "prim_init", text: "val pq = mutable.PriorityQueue((0.0, s))(Ordering.by(-_._1))" },
    { key: "prim_extract", text: "while (pq.nonEmpty) {" },
    { key: "prim_extract", text: "  val (key_u, u) = pq.dequeue" },
    { key: "prim_extract", text: "  if (inMST(u)) return" },
    { key: "prim_extract", text: "  inMST(u) = true" },
    { key: "prim_relax", text: "  adj(u).foreach { case (v, w) =>" },
    { key: "prim_relax", text: "      if (!inMST(v) && w < key(v)) {" },
    { key: "prim_relax", text: "          key(v) = w; parent(v) = u" },
    { key: "prim_relax", text: "          pq.enqueue((key(v), v))" },
    { key: "prim_relax", text: "      }" },
    { key: "prim_relax", text: "  }" },
    { key: "prim_extract", text: "}" },
    { key: "prim_done", text: "// MST constructed" },
  ],
  haskell: [
    { key: "prim_init", text: "import Data.Heap (MinHeap, empty, insert, view)" },
    { key: "prim_init", text: "import qualified Data.Heap as H" },
    { key: "prim_init", text: "let key = replicate n (1/0) in let parent = replicate n (-1) in" },
    { key: "prim_init", text: "let key' = update key s 0 in" },
    { key: "prim_init", text: "let pq = H.singleton (0, s) in" },
    { key: "prim_extract", text: "prim key parent pq = case H.view pq of" },
    { key: "prim_extract", text: "  Nothing -> (key, parent)" },
    { key: "prim_extract", text: "  Just ((key_u, u), pq') ->" },
    { key: "prim_extract", text: "    if inMST u then prim key parent pq'" },
    { key: "prim_relax", text: "    else let relax (v, w) (key'', parent'', pq'') =" },
    { key: "prim_relax", text: "            if not (inMST v) && w < key'' !! v then" },
    { key: "prim_relax", text: "              (update key'' v w, update parent'' v u, H.insert (w, v) pq'')" },
    { key: "prim_relax", text: "            else (key'', parent'', pq'')" },
    { key: "prim_relax", text: "          in foldr relax (key, parent, pq') (adj !! u)" },
    { key: "prim_done", text: "-- MST constructed" },
  ],
  ocaml: [
    { key: "prim_init", text: "module Heap = BatHeap" },
    { key: "prim_init", text: "let key = Array.make n infinity in" },
    { key: "prim_init", text: "let parent = Array.make n (-1) in" },
    { key: "prim_init", text: "let in_mst = Array.make n false in" },
    { key: "prim_init", text: "key.(s) <- 0.0;" },
    { key: "prim_init", text: "let pq = Heap.empty |> Heap.insert (0.0, s) in" },
    { key: "prim_extract", text: "let rec prim key parent in_mst pq = match Heap.find_min pq with" },
    { key: "prim_extract", text: "  | None -> (key, parent)" },
    { key: "prim_extract", text: "  | Some (key_u, u) ->" },
    { key: "prim_extract", text: "    let pq' = Heap.delete_min pq in" },
    { key: "prim_extract", text: "    if in_mst.(u) then prim key parent in_mst pq'" },
    { key: "prim_extract", text: "    else (in_mst.(u) <- true;" },
    { key: "prim_relax", text: "     let relax (v, w) (key'', parent'', pq'') =" },
    { key: "prim_relax", text: "            if not in_mst.(v) && w < key''.(v) then" },
    { key: "prim_relax", text: "              (key''.(v) <- w; parent''.(v) <- u; Heap.insert (w, v) pq'')" },
    { key: "prim_relax", text: "            else (key'', parent'', pq'')" },
    { key: "prim_relax", text: "     in List.fold_right relax adj.(u) (key, parent, pq'))" },
    { key: "prim_done", text: "(* MST constructed *)" },
  ],
  fsharp: [
    { key: "prim_init", text: "open System.Collections.Generic" },
    { key: "prim_init", text: "let key = Array.create n System.Double.PositiveInfinity" },
    { key: "prim_init", text: "let parent = Array.create n -1" },
    { key: "prim_init", text: "let inMST = Array.create n false" },
    { key: "prim_init", text: "key.[s] <- 0.0" },
    { key: "prim_init", text: "let pq = SortedSet<(float * int)>(compare); pq.Add((0.0, s)) |> ignore" },
    { key: "prim_extract", text: "while pq.Count > 0 do" },
    { key: "prim_extract", text: "  let (key_u, u) = pq.Min; pq.Remove((key_u, u)) |> ignore" },
    { key: "prim_extract", text: "  if inMST.[u] then ()" },
    { key: "prim_extract", text: "  else inMST.[u] <- true" },
    { key: "prim_relax", text: "  adj.[u] |> List.iter (fun (v, w) ->" },
    { key: "prim_relax", text: "      if not inMST.[v] && w < key.[v] then" },
    { key: "prim_relax", text: "        key.[v] <- w; parent.[v] <- u" },
    { key: "prim_relax", text: "        pq.Add((key.[v], v)) |> ignore)" },
  ],
  dart: [
    { key: "prim_init", text: "import 'dart:collection';" },
    { key: "prim_init", text: "List<double> key = List.filled(n, double.infinity);" },
    { key: "prim_init", text: "List<int> parent = List.filled(n, -1);" },
    { key: "prim_init", text: "List<bool> inMST = List.filled(n, false);" },
    { key: "prim_init", text: "key[s] = 0;" },
    { key: "prim_init", text: "var pq = PriorityQueue<MapEntry<int, double>>((a, b) => a.value.compareTo(b.value));" },
    { key: "prim_init", text: "pq.addEntry(MapEntry(s, 0));" },
    { key: "prim_extract", text: "while (pq.isNotEmpty) {" },
    { key: "prim_extract", text: "  var entry = pq.removeFirst(); int u = entry.key; double key_u = entry.value;" },
    { key: "prim_extract", text: "  if (inMST[u]) continue;" },
    { key: "prim_extract", text: "  inMST[u] = true;" },
    { key: "prim_relax", text: "  for (var e in adj[u]) {" },
    { key: "prim_relax", text: "      int v = e[0]; double w = e[1];" },
    { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
    { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
    { key: "prim_relax", text: "          pq.addEntry(MapEntry(v, key[v]));" },
    { key: "prim_relax", text: "      }" },
    { key: "prim_relax", text: "  }" },
    { key: "prim_extract", text: "}" },
    { key: "prim_done", text: "// MST constructed" },
  ],
  lua: [
    { key: "prim_init", text: "local key = {}; local parent = {}; local in_mst = {}" },
    { key: "prim_init", text: "for i = 1, n do key[i] = math.huge; parent[i] = nil; in_mst[i] = false end" },
    { key: "prim_init", text: "key[s] = 0; local pq = {{0, s}}" },
    { key: "prim_extract", text: "while #pq > 0 do" },
    { key: "prim_extract", text: "  table.sort(pq, function(a, b) return a[1] < b[1] end)" },
    { key: "prim_extract", text: "  local key_u, u = table.remove(pq, 1)[1], table.remove(pq, 1)[2]" },
    { key: "prim_extract", text: "  if in_mst[u] then goto continue end" },
    { key: "prim_extract", text: "  in_mst[u] = true" },
    { key: "prim_relax", text: "  for _, edge in ipairs(adj[u]) do" },
    { key: "prim_relax", text: "      local v, w = edge[1], edge[2]" },
    { key: "prim_relax", text: "      if not in_mst[v] and w < key[v] then" },
    { key: "prim_relax", text: "          key[v] = w; parent[v] = u; table.insert(pq, {key[v], v})" },
    { key: "prim_relax", text: "      end" },
    { key: "prim_relax", text: "  end" },
    { key: "prim_extract", text: "  ::continue::" },
    { key: "prim_extract", text: "end" },
    { key: "prim_done", text: "-- MST constructed" },
  ],
  perl: [
    { key: "prim_init", text: "use strict; use warnings;" },
    { key: "prim_init", text: "my @key = (inf) x $n; my @parent = (-1) x $n; my @in_mst = (0) x $n;" },
    { key: "prim_init", text: "$key[$s] = 0; my @pq = ([0, $s]);" },
    { key: "prim_extract", text: "while (@pq) {" },
    { key: "prim_extract", text: "  @pq = sort { $a->[0] <=> $b->[0] } @pq;" },
    { key: "prim_extract", text: "  my ($key_u, $u) = @{shift @pq};" },
    { key: "prim_extract", text: "  next if $in_mst[$u];" },
    { key: "prim_extract", text: "  $in_mst[$u] = 1;" },
    { key: "prim_relax", text: "  for my $edge (@{$adj[$u]}) {" },
    { key: "prim_relax", text: "      my ($v, $w) = @$edge;" },
    { key: "prim_relax", text: "      if (!$in_mst[$v] && $w < $key[$v]) {" },
    { key: "prim_relax", text: "          $key[$v] = $w; $parent[$v] = $u; push @pq, [$key[$v], $v];" },
    { key: "prim_relax", text: "      }" },
    { key: "prim_relax", text: "  }" },
    { key: "prim_extract", text: "}" },
    { key: "prim_done", text: "# MST constructed" },
  ],
  r: [
    { key: "prim_init", text: "key <- rep(Inf, n); parent <- rep(NA, n); inMST <- rep(FALSE, n)" },
    { key: "prim_init", text: "key[s] <- 0" },
    { key: "prim_init", text: "pq <- data.frame(key = 0, node = s)" },
    { key: "prim_extract", text: "while (nrow(pq) > 0) {" },
    { key: "prim_extract", text: "  pq <- pq[order(pq$key), ]" },
    { key: "prim_extract", text: "  key_u <- pq$key[1]; u <- pq$node[1]; pq <- pq[-1, ]" },
    { key: "prim_extract", text: "  if (inMST[u]) next" },
    { key: "prim_extract", text: "  inMST[u] <- TRUE" },
    { key: "prim_relax", text: "  for (edge in adj[[u]]) {" },
    { key: "prim_relax", text: "      v <- edge$v; w <- edge$w" },
    { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
    { key: "prim_relax", text: "          key[v] <- w; parent[v] <- u" },
    { key: "prim_relax", text: "          pq <- rbind(pq, data.frame(key = key[v], node = v))" },
    { key: "prim_relax", text: "      }" },
    { key: "prim_relax", text: "  }" },
    { key: "prim_extract", text: "}" },
    { key: "prim_done", text: "# MST constructed" },
  ],
  matlab: [
    { key: "prim_init", text: "key = inf(1, n); parent = zeros(1, n); inMST = false(1, n);" },
    { key: "prim_init", text: "key(s) = 0; pq = [0, s];" },
    { key: "prim_extract", text: "while ~isempty(pq)" },
    { key: "prim_extract", text: "  [~, idx] = min(pq(:, 1)); key_u = pq(idx, 1); u = pq(idx, 2);" },
    { key: "prim_extract", text: "  pq(idx, :) = [];" },
    { key: "prim_extract", text: "  if inMST(u), continue, end" },
    { key: "prim_extract", text: "  inMST(u) = true;" },
    { key: "prim_relax", text: "  for edge = adj{u}" },
    { key: "prim_relax", text: "      v = edge(1); w = edge(2);" },
    { key: "prim_relax", text: "      if ~inMST(v) && w < key(v)" },
    { key: "prim_relax", text: "          key(v) = w; parent(v) = u;" },
    { key: "prim_relax", text: "          pq = [pq; key(v), v];" },
    { key: "prim_relax", text: "      end" },
    { key: "prim_relax", text: "  end" },
    { key: "prim_extract", text: "end" },
    { key: "prim_done", text: "% MST constructed" },
  ],
  julia: [
    { key: "prim_init", text: "using DataStructures" },
    { key: "prim_init", text: "key = fill(Inf, n); parent = fill(nothing, n); inMST = falses(n)" },
    { key: "prim_init", text: "key[s] = 0" },
    { key: "prim_init", text: "pq = PriorityQueue(Base.Order.Forward, [(key[s], s)])" },
    { key: "prim_extract", text: "while !isempty(pq)" },
    { key: "prim_extract", text: "  (key_u, u) = dequeue!(pq)" },
    { key: "prim_extract", text: "  inMST[u] && continue" },
    { key: "prim_extract", text: "  inMST[u] = true" },
    { key: "prim_relax", text: "  for (v, w) in adj[u]" },
    { key: "prim_relax", text: "      inMST[v] && continue" },
    { key: "prim_relax", text: "      if w < key[v]" },
    { key: "prim_relax", text: "          key[v] = w; parent[v] = u" },
    { key: "prim_relax", text: "          enqueue!(pq, key[v], v)" },
    { key: "prim_relax", text: "      end" },
    { key: "prim_relax", text: "  end" },
    { key: "prim_extract", text: "end" },
    { key: "prim_done", text: "# MST constructed" },
  ],
};
