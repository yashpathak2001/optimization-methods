export const CODE_TEMPLATES = 
  {
    cpp: {
      relaxation: [
        { key: "init", text: "vector<double> d(n, INF); vector<int> parent(n, -1);" },
        { key: "init", text: "d[s] = 0;" },
        { key: "relax_outer", text: "for (int i = 0; i < n - 1; ++i) {" },
        {
          key: "relax",
          text: "  for (auto &e : edges) { int u = e.u, v = e.v; double w = e.w;",
        },
        { key: "relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "relax", text: "    }" },
        { key: "relax_outer", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "vector<double> d(n, INF); vector<int> parent(n, -1);" },
        { key: "bf_init", text: "d[s] = 0;" },
        { key: "bf_outer", text: "for (int i = 0; i < n - 1; ++i) {" },
        {
          key: "bf_relax",
          text: "  for (auto &e : edges) { int u = e.u, v = e.v; double w = e.w;",
        },
        { key: "bf_relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "bf_relax", text: "    }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for (auto &e : edges) {" },
        { key: "bf_neg_cycle", text: "  if (d[e.u] + e.w < d[e.v]) {" },
        { key: "bf_neg_cycle", text: "    // negative cycle reachable from s" },
        { key: "bf_neg_cycle", text: "  }" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        {
          key: "fifo_init",
          text: "vector<double> d(n, INF); vector<int> parent(n, -1); d[s] = 0;",
        },
        {
          key: "fifo_init",
          text: "queue<int> q; vector<bool> inQ(n, false); q.push(s); inQ[s] = true;",
        },
        { key: "fifo_pop", text: "while (!q.empty()) {" },
        { key: "fifo_pop", text: "  int u = q.front(); q.pop(); inQ[u] = false;" },
        { key: "fifo_relax", text: "  for (auto &e : adj[u]) {" },
        { key: "fifo_relax", text: "    int v = e.to; double w = e.w;" },
        { key: "fifo_relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "fifo_relax", text: "      if (!inQ[v]) { q.push(v); inQ[v] = true; }" },
        { key: "fifo_relax", text: "    }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "#include <queue>" },
        { key: "dijkstra_init", text: "#include <vector>" },
        { key: "dijkstra_init", text: "vector<double> d(n, INF); vector<int> parent(n, -1);" },
        { key: "dijkstra_init", text: "d[s] = 0;" },
        { key: "dijkstra_init", text: "priority_queue<pair<double, int>, vector<pair<double, int>>, greater<>> pq;" },
        { key: "dijkstra_init", text: "pq.push({0, s});" },
        { key: "dijkstra_extract", text: "while (!pq.empty()) {" },
        { key: "dijkstra_extract", text: "  auto [dist_u, u] = pq.top(); pq.pop();" },
        { key: "dijkstra_extract", text: "  if (dist_u > d[u]) continue;" },
        { key: "dijkstra_relax", text: "  for (auto &[v, w] : adj[u]) {" },
        { key: "dijkstra_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "dijkstra_relax", text: "          pq.push({d[v], v});" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
        { key: "dijkstra_done", text: "// All reachable nodes processed" },
      ],
      prim: [
        { key: "prim_init", text: "#include <queue>" },
        { key: "prim_init", text: "vector<double> key(n, INF); vector<int> parent(n, -1); vector<bool> inMST(n, false);" },
        { key: "prim_init", text: "key[s] = 0;" },
        { key: "prim_init", text: "priority_queue<pair<double, int>, vector<pair<double, int>>, greater<>> pq; pq.push({0, s});" },
        { key: "prim_extract", text: "while (!pq.empty()) {" },
        { key: "prim_extract", text: "  auto [key_u, u] = pq.top(); pq.pop();" },
        { key: "prim_extract", text: "  if (inMST[u]) continue;" },
        { key: "prim_extract", text: "  inMST[u] = true;" },
        { key: "prim_relax", text: "  for (auto &[v, w] : adj[u]) {" },
        { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
        { key: "prim_relax", text: "          pq.push({key[v], v});" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "#include <queue>" },
        { key: "bfs_init", text: "vector<int> d(n, INF); vector<int> parent(n, -1); vector<bool> visited(n, false);" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true;" },
        { key: "bfs_init", text: "queue<int> q; q.push(s);" },
        { key: "bfs_pop", text: "while (!q.empty()) {" },
        { key: "bfs_pop", text: "  int u = q.front(); q.pop();" },
        { key: "bfs_relax", text: "  for (int v : adj[u]) {" },
        { key: "bfs_relax", text: "      if (!visited[v]) {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.push(v);" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "vector<bool> visited(n, false); vector<int> parent(n, -1);" },
        { key: "dfs_init", text: "void dfs(int u) {" },
        { key: "dfs_visit", text: "  visited[u] = true;" },
        { key: "dfs_relax", text: "  for (int v : adj[u]) {" },
        { key: "dfs_relax", text: "      if (!visited[v]) {" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    c: {
      relaxation: [
        { key: "init", text: "for (int i = 0; i < n; ++i) { d[i] = INF; parent[i] = -1; }" },
        { key: "init", text: "d[s] = 0;" },
        { key: "relax_outer", text: "for (int i = 0; i < n - 1; ++i) {" },
        {
          key: "relax",
          text: "  for (int e = 0; e < m; ++e) { int u = U[e], v = V[e]; double w = W[e];",
        },
        { key: "relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "relax", text: "    }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "for (int i = 0; i < n; ++i) { d[i] = INF; parent[i] = -1; }" },
        { key: "bf_init", text: "d[s] = 0;" },
        { key: "bf_outer", text: "for (int i = 0; i < n - 1; ++i) {" },
        {
          key: "bf_relax",
          text: "  for (int e = 0; e < m; ++e) { int u = U[e], v = V[e]; double w = W[e];",
        },
        { key: "bf_relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "bf_relax", text: "    }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for (int e = 0; e < m; ++e) {" },
        { key: "bf_neg_cycle", text: "  if (d[U[e]] + W[e] < d[V[e]]) {" },
        { key: "bf_neg_cycle", text: "    // negative cycle" },
        { key: "bf_neg_cycle", text: "  }" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        {
          key: "fifo_init",
          text: "for (int i = 0; i < n; ++i) { d[i] = INF; inQ[i] = false; parent[i] = -1; }",
        },
        { key: "fifo_init", text: "d[s] = 0; push(q, s); inQ[s] = true;" },
        { key: "fifo_pop", text: "while (!empty(q)) {" },
        { key: "fifo_pop", text: "  int u = front(q); pop(q); inQ[u] = false;" },
        { key: "fifo_relax", text: "  for (each edge (u,v,w)) {" },
        { key: "fifo_relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "fifo_relax", text: "      if (!inQ[v]) { push(q, v); inQ[v] = true; }" },
        { key: "fifo_relax", text: "    }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "// Note: C doesn't have built-in priority queue" },
        { key: "dijkstra_init", text: "// Use a min-heap implementation or array-based approach" },
        { key: "dijkstra_init", text: "double d[n]; int parent[n]; bool visited[n];" },
        { key: "dijkstra_init", text: "for (int i = 0; i < n; i++) { d[i] = INF; parent[i] = -1; visited[i] = false; }" },
        { key: "dijkstra_init", text: "d[s] = 0;" },
        { key: "dijkstra_extract", text: "for (int count = 0; count < n; count++) {" },
        { key: "dijkstra_extract", text: "  int u = -1; double min_dist = INF;" },
        { key: "dijkstra_extract", text: "  for (int i = 0; i < n; i++)" },
        { key: "dijkstra_extract", text: "      if (!visited[i] && d[i] < min_dist) { u = i; min_dist = d[i]; }" },
        { key: "dijkstra_extract", text: "  if (u == -1) break; visited[u] = true;" },
        { key: "dijkstra_relax", text: "  for (each edge (u, v, w) in adj[u]) {" },
        { key: "dijkstra_relax", text: "      if (!visited[v] && d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "// Note: C doesn't have built-in priority queue" },
        { key: "prim_init", text: "// Use array-based approach or implement min-heap" },
        { key: "prim_init", text: "double key[n]; int parent[n]; bool inMST[n];" },
        { key: "prim_init", text: "for (int i = 0; i < n; i++) { key[i] = INF; parent[i] = -1; inMST[i] = false; }" },
        { key: "prim_init", text: "key[s] = 0;" },
        { key: "prim_extract", text: "for (int count = 0; count < n; count++) {" },
        { key: "prim_extract", text: "  int u = -1; double min_key = INF;" },
        { key: "prim_extract", text: "  for (int i = 0; i < n; i++)" },
        { key: "prim_extract", text: "      if (!inMST[i] && key[i] < min_key) { u = i; min_key = key[i]; }" },
        { key: "prim_extract", text: "  if (u == -1) break; inMST[u] = true;" },
        { key: "prim_relax", text: "  for (each edge (u, v, w) in adj[u]) {" },
        { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "// Note: C doesn't have built-in queue" },
        { key: "bfs_init", text: "// Use array-based queue or implement queue structure" },
        { key: "bfs_init", text: "int d[n], parent[n]; bool visited[n];" },
        { key: "bfs_init", text: "for (int i = 0; i < n; i++) { d[i] = INF; parent[i] = -1; visited[i] = false; }" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true; int q[n], front = 0, rear = 0; q[rear++] = s;" },
        { key: "bfs_pop", text: "while (front < rear) {" },
        { key: "bfs_pop", text: "  int u = q[front++];" },
        { key: "bfs_relax", text: "  for (each neighbor v of u) {" },
        { key: "bfs_relax", text: "      if (!visited[v]) {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q[rear++] = v;" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "bool visited[n]; int parent[n];" },
        { key: "dfs_init", text: "for (int i = 0; i < n; i++) { visited[i] = false; parent[i] = -1; }" },
        { key: "dfs_init", text: "void dfs(int u) {" },
        { key: "dfs_visit", text: "  visited[u] = true;" },
        { key: "dfs_relax", text: "  for (each neighbor v of u) {" },
        { key: "dfs_relax", text: "      if (!visited[v]) {" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    java: {
      relaxation: [
        { key: "init", text: "double[] d = new double[n]; int[] parent = new int[n];" },
        { key: "init", text: "Arrays.fill(d, INF); Arrays.fill(parent, -1); d[s] = 0;" },
        { key: "relax_outer", text: "for (int i = 0; i < n - 1; i++) {" },
        {
          key: "relax",
          text: "  for (Edge e : edges) { int u = e.u, v = e.v; double w = e.w;",
        },
        { key: "relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "relax", text: "    }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "double[] d = new double[n]; int[] parent = new int[n];" },
        { key: "bf_init", text: "Arrays.fill(d, INF); Arrays.fill(parent, -1); d[s] = 0;" },
        { key: "bf_outer", text: "for (int i = 0; i < n - 1; i++) {" },
        {
          key: "bf_relax",
          text: "  for (Edge e : edges) { int u = e.u, v = e.v; double w = e.w;",
        },
        { key: "bf_relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "bf_relax", text: "    }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for (Edge e : edges) {" },
        { key: "bf_neg_cycle", text: "  if (d[e.u] + e.w < d[e.v]) {" },
        { key: "bf_neg_cycle", text: "    // negative cycle" },
        { key: "bf_neg_cycle", text: "  }" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        {
          key: "fifo_init",
          text: "double[] d = new double[n]; boolean[] inQ = new boolean[n]; int[] parent = new int[n];",
        },
        {
          key: "fifo_init",
          text: "Arrays.fill(d, INF); Arrays.fill(parent, -1); d[s] = 0;",
        },
        {
          key: "fifo_init",
          text: "Queue<Integer> q = new ArrayDeque<>(); q.add(s); inQ[s] = true;",
        },
        { key: "fifo_pop", text: "while (!q.isEmpty()) {" },
        { key: "fifo_pop", text: "  int u = q.remove(); inQ[u] = false;" },
        { key: "fifo_relax", text: "  for (Edge e : adj[u]) {" },
        { key: "fifo_relax", text: "    int v = e.v; double w = e.w;" },
        { key: "fifo_relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "fifo_relax", text: "      if (!inQ[v]) { q.add(v); inQ[v] = true; }" },
        { key: "fifo_relax", text: "    }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "import java.util.*;" },
        { key: "dijkstra_init", text: "double[] d = new double[n]; int[] parent = new int[n];" },
        { key: "dijkstra_init", text: "Arrays.fill(d, Double.POSITIVE_INFINITY); Arrays.fill(parent, -1);" },
        { key: "dijkstra_init", text: "d[s] = 0;" },
        { key: "dijkstra_init", text: "PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Double.compare(a[0], b[0]));" },
        { key: "dijkstra_init", text: "pq.offer(new int[]{0, s});" },
        { key: "dijkstra_extract", text: "while (!pq.isEmpty()) {" },
        { key: "dijkstra_extract", text: "  int[] curr = pq.poll(); double dist_u = curr[0]; int u = curr[1];" },
        { key: "dijkstra_extract", text: "  if (dist_u > d[u]) continue;" },
        { key: "dijkstra_relax", text: "  for (Edge e : adj[u]) {" },
        { key: "dijkstra_relax", text: "      int v = e.v; double w = e.w;" },
        { key: "dijkstra_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "dijkstra_relax", text: "          pq.offer(new int[]{(int)d[v], v});" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
        { key: "dijkstra_done", text: "// All reachable nodes processed" },
      ],
      prim: [
        { key: "prim_init", text: "import java.util.*;" },
        { key: "prim_init", text: "double[] key = new double[n]; int[] parent = new int[n]; boolean[] inMST = new boolean[n];" },
        { key: "prim_init", text: "Arrays.fill(key, Double.POSITIVE_INFINITY); Arrays.fill(parent, -1); key[s] = 0;" },
        { key: "prim_init", text: "PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Double.compare(a[0], b[0]));" },
        { key: "prim_init", text: "pq.offer(new int[]{0, s});" },
        { key: "prim_extract", text: "while (!pq.isEmpty()) {" },
        { key: "prim_extract", text: "  int[] curr = pq.poll(); double key_u = curr[0]; int u = curr[1];" },
        { key: "prim_extract", text: "  if (inMST[u]) continue;" },
        { key: "prim_extract", text: "  inMST[u] = true;" },
        { key: "prim_relax", text: "  for (Edge e : adj[u]) {" },
        { key: "prim_relax", text: "      int v = e.v; double w = e.w;" },
        { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
        { key: "prim_relax", text: "          pq.offer(new int[]{(int)key[v], v});" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "double[] d = new double[n]; int[] parent = new int[n]; boolean[] visited = new boolean[n];" },
        { key: "bfs_init", text: "Arrays.fill(d, Double.POSITIVE_INFINITY); Arrays.fill(parent, -1); d[s] = 0; visited[s] = true;" },
        { key: "bfs_init", text: "Queue<Integer> q = new ArrayDeque<>(); q.add(s);" },
        { key: "bfs_pop", text: "while (!q.isEmpty()) {" },
        { key: "bfs_pop", text: "  int u = q.remove();" },
        { key: "bfs_relax", text: "  for (Edge e : adj[u]) { int v = e.v;" },
        { key: "bfs_relax", text: "      if (!visited[v]) {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.add(v);" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "boolean[] visited = new boolean[n]; int[] parent = new int[n]; Arrays.fill(parent, -1);" },
        { key: "dfs_init", text: "void dfs(int u) {" },
        { key: "dfs_visit", text: "  visited[u] = true;" },
        { key: "dfs_relax", text: "  for (Edge e : adj[u]) { int v = e.v;" },
        { key: "dfs_relax", text: "      if (!visited[v]) {" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    python: {
      relaxation: [
        { key: "init", text: "d = {v: float('inf') for v in V}; parent = {v: None for v in V}" },
        { key: "init", text: "d[s] = 0" },
        { key: "relax_outer", text: "for _ in range(len(V) - 1):" },
        { key: "relax", text: "  for (u, v, w) in E:" },
        { key: "relax", text: "      if d[u] + w < d[v]:" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u" },
      ],
      "bellman-ford": [
        {
          key: "bf_init",
          text: "d = {v: float('inf') for v in V}; parent = {v: None for v in V}",
        },
        { key: "bf_init", text: "d[s] = 0" },
        { key: "bf_outer", text: "for _ in range(len(V) - 1):" },
        { key: "bf_relax", text: "  for (u, v, w) in E:" },
        { key: "bf_relax", text: "      if d[u] + w < d[v]:" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "bf_check", text: "for (u, v, w) in E:" },
        { key: "bf_neg_cycle", text: "  if d[u] + w < d[v]: print('negative cycle')" },
      ],
      "bellman-ford-fifo": [
        {
          key: "fifo_init",
          text: "d = {v: float('inf') for v in V}; parent = {v: None for v in V}",
        },
        { key: "fifo_init", text: "d[s] = 0" },
        { key: "fifo_init", text: "from collections import deque" },
        { key: "fifo_init", text: "Q = deque([s]); inQ = {v: False for v in V}; inQ[s] = True" },
        { key: "fifo_pop", text: "while Q:" },
        { key: "fifo_pop", text: "  u = Q.popleft(); inQ[u] = False" },
        { key: "fifo_relax", text: "  for (v, w) in adj[u]:" },
        { key: "fifo_relax", text: "      if d[u] + w < d[v]:" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "fifo_relax", text: "          if not inQ[v]: Q.append(v); inQ[v] = True" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "import heapq" },
        { key: "dijkstra_init", text: "d = {v: float('inf') for v in V}; parent = {v: None for v in V}" },
        { key: "dijkstra_init", text: "d[s] = 0" },
        { key: "dijkstra_init", text: "pq = [(0, s)]" },
        { key: "dijkstra_extract", text: "while pq:" },
        { key: "dijkstra_extract", text: "  dist_u, u = heapq.heappop(pq)" },
        { key: "dijkstra_extract", text: "  if dist_u > d[u]: continue" },
        { key: "dijkstra_relax", text: "  for (v, w) in adj[u]:" },
        { key: "dijkstra_relax", text: "      if d[u] + w < d[v]:" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "dijkstra_relax", text: "          heapq.heappush(pq, (d[v], v))" },
        { key: "dijkstra_done", text: "# All reachable nodes processed" },
      ],
      prim: [
        { key: "prim_init", text: "import heapq" },
        { key: "prim_init", text: "key = {v: float('inf') for v in V}; parent = {v: None for v in V}" },
        { key: "prim_init", text: "key[s] = 0" },
        { key: "prim_init", text: "pq = [(0, s)]; in_mst = set()" },
        { key: "prim_extract", text: "while pq:" },
        { key: "prim_extract", text: "  key_u, u = heapq.heappop(pq)" },
        { key: "prim_extract", text: "  if u in in_mst: continue" },
        { key: "prim_extract", text: "  in_mst.add(u)" },
        { key: "prim_relax", text: "  for (v, w) in adj[u]:" },
        { key: "prim_relax", text: "      if v not in in_mst and w < key[v]:" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u" },
        { key: "prim_relax", text: "          heapq.heappush(pq, (key[v], v))" },
        { key: "prim_done", text: "# MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "from collections import deque" },
        { key: "bfs_init", text: "d = {v: float('inf') for v in V}; parent = {v: None for v in V}" },
        { key: "bfs_init", text: "visited = {v: False for v in V}; d[s] = 0; visited[s] = True" },
        { key: "bfs_init", text: "Q = deque([s])" },
        { key: "bfs_pop", text: "while Q:" },
        { key: "bfs_pop", text: "  u = Q.popleft()" },
        { key: "bfs_relax", text: "  for (v, _) in adj[u]:" },
        { key: "bfs_relax", text: "      if not visited[v]:" },
        { key: "bfs_relax", text: "          visited[v] = True; d[v] = d[u] + 1; parent[v] = u; Q.append(v)" },
      ],
      dfs: [
        { key: "dfs_init", text: "visited = {v: False for v in V}; parent = {v: None for v in V}" },
        { key: "dfs_init", text: "def dfs(u):" },
        { key: "dfs_visit", text: "  visited[u] = True" },
        { key: "dfs_relax", text: "  for (v, _) in adj[u]:" },
        { key: "dfs_relax", text: "      if not visited[v]:" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v)" },
      ],
    },
    rust: {
      relaxation: [
        { key: "init", text: "let mut d = vec![f64::INFINITY; n]; let mut parent = vec![None; n];" },
        { key: "init", text: "d[s] = 0.0;" },
        { key: "relax_outer", text: "for _ in 0..n - 1 {" },
        { key: "relax", text: "  for &(u, v, w) in &edges {" },
        { key: "relax", text: "      if d[u] + w < d[v] {" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = Some(u);" },
        { key: "relax", text: "      }" },
        { key: "relax_outer", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "let mut d = vec![f64::INFINITY; n]; let mut parent = vec![None; n];" },
        { key: "bf_init", text: "d[s] = 0.0;" },
        { key: "bf_outer", text: "for _ in 0..n - 1 {" },
        { key: "bf_relax", text: "  for &(u, v, w) in &edges {" },
        { key: "bf_relax", text: "      if d[u] + w < d[v] {" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = Some(u);" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for &(u, v, w) in &edges {" },
        { key: "bf_neg_cycle", text: "  if d[u] + w < d[v] { println!(\"negative cycle\"); }" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "let mut d = vec![f64::INFINITY; n]; let mut parent = vec![None; n];" },
        { key: "fifo_init", text: "d[s] = 0.0;" },
        { key: "fifo_init", text: "use std::collections::VecDeque;" },
        { key: "fifo_init", text: "let mut q = VecDeque::new(); let mut in_q = vec![false; n];" },
        { key: "fifo_init", text: "q.push_back(s); in_q[s] = true;" },
        { key: "fifo_pop", text: "while let Some(u) = q.pop_front() {" },
        { key: "fifo_pop", text: "  in_q[u] = false;" },
        { key: "fifo_relax", text: "  for &(v, w) in &adj[u] {" },
        { key: "fifo_relax", text: "      if d[u] + w < d[v] {" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = Some(u);" },
        { key: "fifo_relax", text: "          if !in_q[v] { q.push_back(v); in_q[v] = true; }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
        { key: "fifo_done", text: "// Algorithm completed" },
        { key: "fifo_check", text: "// Check for negative cycles" },
        { key: "fifo_check_edge", text: "for &(u, v, w) in &edges {" },
        { key: "fifo_neg_cycle", text: "  if d[u] + w < d[v] { println!(\"negative cycle\"); }" },
        { key: "fifo_check_edge", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "use std::collections::BinaryHeap;" },
        { key: "dijkstra_init", text: "let mut d = vec![f64::INFINITY; n]; let mut parent = vec![None; n];" },
        { key: "dijkstra_init", text: "d[s] = 0.0;" },
        { key: "dijkstra_init", text: "let mut pq = BinaryHeap::new();" },
        { key: "dijkstra_init", text: "pq.push(std::cmp::Reverse((0.0, s)));" },
        { key: "dijkstra_extract", text: "while let Some(std::cmp::Reverse((dist_u, u))) = pq.pop() {" },
        { key: "dijkstra_extract", text: "  if dist_u > d[u] { continue; }" },
        { key: "dijkstra_relax", text: "  for &(v, w) in &adj[u] {" },
        { key: "dijkstra_relax", text: "      if d[u] + w < d[v] {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = Some(u);" },
        { key: "dijkstra_relax", text: "          pq.push(std::cmp::Reverse((d[v], v)));" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "use std::collections::BinaryHeap;" },
        { key: "prim_init", text: "let mut key = vec![f64::INFINITY; n]; let mut parent = vec![None; n]; let mut in_mst = vec![false; n];" },
        { key: "prim_init", text: "key[s] = 0.0;" },
        { key: "prim_init", text: "let mut pq = BinaryHeap::new(); pq.push(std::cmp::Reverse((0.0, s)));" },
        { key: "prim_extract", text: "while let Some(std::cmp::Reverse((key_u, u))) = pq.pop() {" },
        { key: "prim_extract", text: "  if in_mst[u] { continue; }" },
        { key: "prim_extract", text: "  in_mst[u] = true;" },
        { key: "prim_relax", text: "  for &(v, w) in &adj[u] {" },
        { key: "prim_relax", text: "      if !in_mst[v] && w < key[v] {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = Some(u);" },
        { key: "prim_relax", text: "          pq.push(std::cmp::Reverse((key[v], v)));" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "use std::collections::VecDeque;" },
        { key: "bfs_init", text: "let mut d = vec![i32::MAX; n]; let mut parent = vec![None; n]; let mut visited = vec![false; n];" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true;" },
        { key: "bfs_init", text: "let mut q = VecDeque::new(); q.push_back(s);" },
        { key: "bfs_pop", text: "while let Some(u) = q.pop_front() {" },
        { key: "bfs_relax", text: "  for &v in &adj[u] {" },
        { key: "bfs_relax", text: "      if !visited[v] {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = Some(u); q.push_back(v);" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "let mut visited = vec![false; n]; let mut parent = vec![None; n];" },
        { key: "dfs_init", text: "fn dfs(u: usize, adj: &Vec<Vec<usize>>, visited: &mut Vec<bool>, parent: &mut Vec<Option<usize>>) {" },
        { key: "dfs_visit", text: "  visited[u] = true;" },
        { key: "dfs_relax", text: "  for &v in &adj[u] {" },
        { key: "dfs_relax", text: "      if !visited[v] {" },
        { key: "dfs_relax", text: "          parent[v] = Some(u); dfs(v, adj, visited, parent);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    javascript: {
      relaxation: [
        { key: "init", text: "const d = Array(n).fill(Infinity); const parent = Array(n).fill(null);" },
        { key: "init", text: "d[s] = 0;" },
        { key: "relax_outer", text: "for (let i = 0; i < n - 1; i++) {" },
        { key: "relax", text: "  for (const [u, v, w] of edges) {" },
        { key: "relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "const d = Array(n).fill(Infinity); const parent = Array(n).fill(null);" },
        { key: "bf_init", text: "d[s] = 0;" },
        { key: "bf_outer", text: "for (let i = 0; i < n - 1; i++) {" },
        { key: "bf_relax", text: "  for (const [u, v, w] of edges) {" },
        { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for (const [u, v, w] of edges) {" },
        { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) console.log('negative cycle');" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "const d = Array(n).fill(Infinity); const parent = Array(n).fill(null);" },
        { key: "fifo_init", text: "d[s] = 0;" },
        { key: "fifo_init", text: "const q = [s]; const inQ = Array(n).fill(false); inQ[s] = true;" },
        { key: "fifo_pop", text: "while (q.length > 0) {" },
        { key: "fifo_pop", text: "  const u = q.shift(); inQ[u] = false;" },
        { key: "fifo_relax", text: "  for (const [v, w] of adj[u]) {" },
        { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "fifo_relax", text: "          if (!inQ[v]) { q.push(v); inQ[v] = true; }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
        { key: "fifo_done", text: "// Algorithm completed" },
        { key: "fifo_check", text: "// Check for negative cycles" },
        { key: "fifo_check_edge", text: "for (const [u, v, w] of edges) {" },
        { key: "fifo_neg_cycle", text: "  if (d[u] + w < d[v]) console.log('negative cycle');" },
        { key: "fifo_check_edge", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "const d = Array(n).fill(Infinity); const parent = Array(n).fill(null);" },
        { key: "dijkstra_init", text: "d[s] = 0;" },
        { key: "dijkstra_init", text: "const pq = [[0, s]];" },
        { key: "dijkstra_extract", text: "while (pq.length > 0) {" },
        { key: "dijkstra_extract", text: "  pq.sort((a, b) => a[0] - b[0]);" },
        { key: "dijkstra_extract", text: "  const [dist_u, u] = pq.shift();" },
        { key: "dijkstra_extract", text: "  if (dist_u > d[u]) continue;" },
        { key: "dijkstra_relax", text: "  for (const [v, w] of adj[u]) {" },
        { key: "dijkstra_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "dijkstra_relax", text: "          pq.push([d[v], v]);" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
        { key: "dijkstra_done", text: "// All reachable nodes processed" },
      ],
    },
    typescript: {
      relaxation: [
        { key: "init", text: "const d: number[] = Array(n).fill(Infinity); const parent: (number | null)[] = Array(n).fill(null);" },
        { key: "init", text: "d[s] = 0;" },
        { key: "relax_outer", text: "for (let i = 0; i < n - 1; i++) {" },
        { key: "relax", text: "  for (const [u, v, w]: [number, number, number] of edges) {" },
        { key: "relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "const d: number[] = Array(n).fill(Infinity); const parent: (number | null)[] = Array(n).fill(null);" },
        { key: "bf_init", text: "d[s] = 0;" },
        { key: "bf_outer", text: "for (let i = 0; i < n - 1; i++) {" },
        { key: "bf_relax", text: "  for (const [u, v, w]: [number, number, number] of edges) {" },
        { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for (const [u, v, w]: [number, number, number] of edges) {" },
        { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) console.log('negative cycle');" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "const d: number[] = Array(n).fill(Infinity); const parent: (number | null)[] = Array(n).fill(null);" },
        { key: "fifo_init", text: "d[s] = 0;" },
        { key: "fifo_init", text: "const q: number[] = [s]; const inQ: boolean[] = Array(n).fill(false); inQ[s] = true;" },
        { key: "fifo_pop", text: "while (q.length > 0) {" },
        { key: "fifo_pop", text: "  const u = q.shift()!; inQ[u] = false;" },
        { key: "fifo_relax", text: "  for (const [v, w]: [number, number] of adj[u]) {" },
        { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "fifo_relax", text: "          if (!inQ[v]) { q.push(v); inQ[v] = true; }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
        { key: "fifo_done", text: "// Algorithm completed" },
        { key: "fifo_check", text: "// Check for negative cycles" },
        { key: "fifo_check_edge", text: "for (const [u, v, w]: [number, number, number] of edges) {" },
        { key: "fifo_neg_cycle", text: "  if (d[u] + w < d[v]) console.log('negative cycle');" },
        { key: "fifo_check_edge", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "const d: number[] = Array(n).fill(Infinity); const parent: (number | null)[] = Array(n).fill(null);" },
        { key: "dijkstra_init", text: "d[s] = 0;" },
        { key: "dijkstra_init", text: "const pq: [number, number][] = [[0, s]];" },
        { key: "dijkstra_extract", text: "while (pq.length > 0) {" },
        { key: "dijkstra_extract", text: "  pq.sort((a, b) => a[0] - b[0]);" },
        { key: "dijkstra_extract", text: "  const [dist_u, u] = pq.shift()!;" },
        { key: "dijkstra_extract", text: "  if (dist_u > d[u]) continue;" },
        { key: "dijkstra_relax", text: "  for (const [v, w]: [number, number] of adj[u]) {" },
        { key: "dijkstra_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "dijkstra_relax", text: "          pq.push([d[v], v]);" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "const key = Array(n).fill(Infinity); const parent = Array(n).fill(null); const inMST = Array(n).fill(false);" },
        { key: "prim_init", text: "key[s] = 0;" },
        { key: "prim_init", text: "const pq = [[0, s]];" },
        { key: "prim_extract", text: "while (pq.length > 0) {" },
        { key: "prim_extract", text: "  pq.sort((a, b) => a[0] - b[0]);" },
        { key: "prim_extract", text: "  const [key_u, u] = pq.shift();" },
        { key: "prim_extract", text: "  if (inMST[u]) continue;" },
        { key: "prim_extract", text: "  inMST[u] = true;" },
        { key: "prim_relax", text: "  for (const [v, w] of adj[u]) {" },
        { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
        { key: "prim_relax", text: "          pq.push([key[v], v]);" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "const d = Array(n).fill(Infinity); const parent = Array(n).fill(null);" },
        { key: "bfs_init", text: "const visited = Array(n).fill(false);" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true; const q = [s];" },
        { key: "bfs_pop", text: "while (q.length > 0) {" },
        { key: "bfs_pop", text: "  const u = q.shift();" },
        { key: "bfs_relax", text: "  for (const [v] of adj[u]) {" },
        { key: "bfs_relax", text: "      if (!visited[v]) {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.push(v);" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "const visited = Array(n).fill(false); const parent = Array(n).fill(null);" },
        { key: "dfs_init", text: "function dfs(u) {" },
        { key: "dfs_visit", text: "  visited[u] = true;" },
        { key: "dfs_relax", text: "  for (const [v] of adj[u]) {" },
        { key: "dfs_relax", text: "      if (!visited[v]) {" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    go: {
      relaxation: [
        { key: "init", text: "d := make([]float64, n); parent := make([]int, n)" },
        { key: "init", text: "for i := range d { d[i] = math.Inf(1); parent[i] = -1 }" },
        { key: "init", text: "d[s] = 0" },
        { key: "relax_outer", text: "for i := 0; i < n-1; i++ {" },
        { key: "relax", text: "  for _, e := range edges {" },
        { key: "relax", text: "      u, v, w := e.u, e.v, e.w" },
        { key: "relax", text: "      if d[u] + w < d[v] {" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "d := make([]float64, n); parent := make([]int, n)" },
        { key: "bf_init", text: "for i := range d { d[i] = math.Inf(1); parent[i] = -1 }" },
        { key: "bf_init", text: "d[s] = 0" },
        { key: "bf_outer", text: "for i := 0; i < n-1; i++ {" },
        { key: "bf_relax", text: "  for _, e := range edges {" },
        { key: "bf_relax", text: "      u, v, w := e.u, e.v, e.w" },
        { key: "bf_relax", text: "      if d[u] + w < d[v] {" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for _, e := range edges {" },
        { key: "bf_neg_cycle", text: "  if d[e.u] + e.w < d[e.v] { fmt.Println(\"negative cycle\") }" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "d := make([]float64, n); parent := make([]int, n); inQ := make([]bool, n)" },
        { key: "fifo_init", text: "for i := range d { d[i] = math.Inf(1); parent[i] = -1 }" },
        { key: "fifo_init", text: "d[s] = 0; q := []int{s}; inQ[s] = true" },
        { key: "fifo_pop", text: "for len(q) > 0 {" },
        { key: "fifo_pop", text: "  u := q[0]; q = q[1:]; inQ[u] = false" },
        { key: "fifo_relax", text: "  for _, e := range adj[u] {" },
        { key: "fifo_relax", text: "      v, w := e.v, e.w" },
        { key: "fifo_relax", text: "      if d[u] + w < d[v] {" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "fifo_relax", text: "          if !inQ[v] { q = append(q, v); inQ[v] = true }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
        { key: "fifo_done", text: "// Algorithm completed" },
        { key: "fifo_check", text: "// Check for negative cycles" },
        { key: "fifo_check_edge", text: "for _, e := range edges {" },
        { key: "fifo_neg_cycle", text: "  if d[e.u] + e.w < d[e.v] { fmt.Println(\"negative cycle\") }" },
        { key: "fifo_check_edge", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "import (\"container/heap\")" },
        { key: "dijkstra_init", text: "d := make([]float64, n); parent := make([]int, n)" },
        { key: "dijkstra_init", text: "for i := range d { d[i] = math.Inf(1); parent[i] = -1 }" },
        { key: "dijkstra_init", text: "d[s] = 0" },
        { key: "dijkstra_init", text: "pq := &PriorityQueue{}; heap.Init(pq); heap.Push(pq, Item{0, s})" },
        { key: "dijkstra_extract", text: "for pq.Len() > 0 {" },
        { key: "dijkstra_extract", text: "  item := heap.Pop(pq).(Item); dist_u, u := item.priority, item.value" },
        { key: "dijkstra_extract", text: "  if dist_u > d[u] { continue }" },
        { key: "dijkstra_relax", text: "  for _, e := range adj[u] {" },
        { key: "dijkstra_relax", text: "      v, w := e.v, e.w" },
        { key: "dijkstra_relax", text: "      if d[u] + w < d[v] {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "dijkstra_relax", text: "          heap.Push(pq, Item{d[v], v})" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "import (\"container/heap\")" },
        { key: "prim_init", text: "key := make([]float64, n); parent := make([]int, n); inMST := make([]bool, n)" },
        { key: "prim_init", text: "for i := range key { key[i] = math.Inf(1); parent[i] = -1 }" },
        { key: "prim_init", text: "key[s] = 0" },
        { key: "prim_init", text: "pq := &PriorityQueue{}; heap.Init(pq); heap.Push(pq, Item{0, s})" },
        { key: "prim_extract", text: "for pq.Len() > 0 {" },
        { key: "prim_extract", text: "  item := heap.Pop(pq).(Item); key_u, u := item.priority, item.value" },
        { key: "prim_extract", text: "  if inMST[u] { continue }" },
        { key: "prim_extract", text: "  inMST[u] = true" },
        { key: "prim_relax", text: "  for _, e := range adj[u] {" },
        { key: "prim_relax", text: "      v, w := e.v, e.w" },
        { key: "prim_relax", text: "      if !inMST[v] && w < key[v] {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u" },
        { key: "prim_relax", text: "          heap.Push(pq, Item{key[v], v})" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "d := make([]int, n); parent := make([]int, n); visited := make([]bool, n)" },
        { key: "bfs_init", text: "for i := range d { d[i] = math.MaxInt32; parent[i] = -1 }" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true; q := []int{s}" },
        { key: "bfs_pop", text: "for len(q) > 0 {" },
        { key: "bfs_pop", text: "  u := q[0]; q = q[1:]" },
        { key: "bfs_relax", text: "  for _, v := range adj[u] {" },
        { key: "bfs_relax", text: "      if !visited[v] {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q = append(q, v)" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "visited := make([]bool, n); parent := make([]int, n)" },
        { key: "dfs_init", text: "for i := range parent { parent[i] = -1 }" },
        { key: "dfs_init", text: "var dfs func(int)" },
        { key: "dfs_init", text: "dfs = func(u int) {" },
        { key: "dfs_visit", text: "  visited[u] = true" },
        { key: "dfs_relax", text: "  for _, v := range adj[u] {" },
        { key: "dfs_relax", text: "      if !visited[v] {" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v)" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    kotlin: {
      relaxation: [
        { key: "init", text: "val d = DoubleArray(n) { Double.POSITIVE_INFINITY }" },
        { key: "init", text: "val parent = IntArray(n) { -1 }" },
        { key: "init", text: "d[s] = 0.0" },
        { key: "relax_outer", text: "repeat(n - 1) {" },
        { key: "relax", text: "  edges.forEach { (u, v, w) ->" },
        { key: "relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "val d = DoubleArray(n) { Double.POSITIVE_INFINITY }" },
        { key: "bf_init", text: "val parent = IntArray(n) { -1 }" },
        { key: "bf_init", text: "d[s] = 0.0" },
        { key: "bf_outer", text: "repeat(n - 1) {" },
        { key: "bf_relax", text: "  edges.forEach { (u, v, w) ->" },
        { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "edges.forEach { (u, v, w) ->" },
        { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) println(\"negative cycle\")" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "val d = DoubleArray(n) { Double.POSITIVE_INFINITY }" },
        { key: "fifo_init", text: "val parent = IntArray(n) { -1 }" },
        { key: "fifo_init", text: "d[s] = 0.0" },
        { key: "fifo_init", text: "val q = ArrayDeque<Int>(); val inQ = BooleanArray(n)" },
        { key: "fifo_init", text: "q.add(s); inQ[s] = true" },
        { key: "fifo_pop", text: "while (q.isNotEmpty()) {" },
        { key: "fifo_pop", text: "  val u = q.removeFirst(); inQ[u] = false" },
        { key: "fifo_relax", text: "  adj[u].forEach { (v, w) ->" },
        { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "fifo_relax", text: "          if (!inQ[v]) { q.add(v); inQ[v] = true }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "import java.util.*" },
        { key: "dijkstra_init", text: "val d = DoubleArray(n) { Double.POSITIVE_INFINITY }" },
        { key: "dijkstra_init", text: "val parent = IntArray(n) { -1 }" },
        { key: "dijkstra_init", text: "d[s] = 0.0" },
        { key: "dijkstra_init", text: "val pq = PriorityQueue<Pair<Double, Int>>(compareBy { it.first })" },
        { key: "dijkstra_init", text: "pq.add(0.0 to s)" },
        { key: "dijkstra_extract", text: "while (pq.isNotEmpty()) {" },
        { key: "dijkstra_extract", text: "  val (dist_u, u) = pq.poll()" },
        { key: "dijkstra_extract", text: "  if (dist_u > d[u]) continue" },
        { key: "dijkstra_relax", text: "  adj[u].forEach { (v, w) ->" },
        { key: "dijkstra_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "dijkstra_relax", text: "          pq.add(d[v] to v)" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "import java.util.*" },
        { key: "prim_init", text: "val key = DoubleArray(n) { Double.POSITIVE_INFINITY }" },
        { key: "prim_init", text: "val parent = IntArray(n) { -1 }" },
        { key: "prim_init", text: "val inMST = BooleanArray(n)" },
        { key: "prim_init", text: "key[s] = 0.0" },
        { key: "prim_init", text: "val pq = PriorityQueue<Pair<Double, Int>>(compareBy { it.first })" },
        { key: "prim_init", text: "pq.add(0.0 to s)" },
        { key: "prim_extract", text: "while (pq.isNotEmpty()) {" },
        { key: "prim_extract", text: "  val (key_u, u) = pq.poll()" },
        { key: "prim_extract", text: "  if (inMST[u]) continue" },
        { key: "prim_extract", text: "  inMST[u] = true" },
        { key: "prim_relax", text: "  adj[u].forEach { (v, w) ->" },
        { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u" },
        { key: "prim_relax", text: "          pq.add(key[v] to v)" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "val d = IntArray(n) { Int.MAX_VALUE }" },
        { key: "bfs_init", text: "val parent = IntArray(n) { -1 }" },
        { key: "bfs_init", text: "val visited = BooleanArray(n)" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true; val q = ArrayDeque<Int>(); q.add(s)" },
        { key: "bfs_pop", text: "while (q.isNotEmpty()) {" },
        { key: "bfs_pop", text: "  val u = q.removeFirst()" },
        { key: "bfs_relax", text: "  adj[u].forEach { v ->" },
        { key: "bfs_relax", text: "      if (!visited[v]) {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.add(v)" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "val visited = BooleanArray(n); val parent = IntArray(n) { -1 }" },
        { key: "dfs_init", text: "fun dfs(u: Int) {" },
        { key: "dfs_visit", text: "  visited[u] = true" },
        { key: "dfs_relax", text: "  adj[u].forEach { v ->" },
        { key: "dfs_relax", text: "      if (!visited[v]) {" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v)" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    swift: {
      relaxation: [
        { key: "init", text: "var d = Array(repeating: Double.infinity, count: n)" },
        { key: "init", text: "var parent = Array(repeating: -1, count: n)" },
        { key: "init", text: "d[s] = 0" },
        { key: "relax_outer", text: "for _ in 0..<n - 1 {" },
        { key: "relax", text: "  for (u, v, w) in edges {" },
        { key: "relax", text: "      if d[u] + w < d[v] {" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "var d = Array(repeating: Double.infinity, count: n)" },
        { key: "bf_init", text: "var parent = Array(repeating: -1, count: n)" },
        { key: "bf_init", text: "d[s] = 0" },
        { key: "bf_outer", text: "for _ in 0..<n - 1 {" },
        { key: "bf_relax", text: "  for (u, v, w) in edges {" },
        { key: "bf_relax", text: "      if d[u] + w < d[v] {" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for (u, v, w) in edges {" },
        { key: "bf_neg_cycle", text: "  if d[u] + w < d[v] { print(\"negative cycle\") }" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "var d = Array(repeating: Double.infinity, count: n)" },
        { key: "fifo_init", text: "var parent = Array(repeating: -1, count: n)" },
        { key: "fifo_init", text: "d[s] = 0" },
        { key: "fifo_init", text: "var q = [s]; var inQ = Array(repeating: false, count: n); inQ[s] = true" },
        { key: "fifo_pop", text: "while !q.isEmpty {" },
        { key: "fifo_pop", text: "  let u = q.removeFirst(); inQ[u] = false" },
        { key: "fifo_relax", text: "  for (v, w) in adj[u] {" },
        { key: "fifo_relax", text: "      if d[u] + w < d[v] {" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "fifo_relax", text: "          if !inQ[v] { q.append(v); inQ[v] = true }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
        { key: "fifo_done", text: "// Algorithm completed" },
        { key: "fifo_check", text: "// Check for negative cycles" },
        { key: "fifo_check_edge", text: "for (u, v, w) in edges {" },
        { key: "fifo_neg_cycle", text: "  if d[u] + w < d[v] { print(\"negative cycle\") }" },
        { key: "fifo_check_edge", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "import Foundation" },
        { key: "dijkstra_init", text: "var d = Array(repeating: Double.infinity, count: n)" },
        { key: "dijkstra_init", text: "var parent = Array(repeating: -1, count: n)" },
        { key: "dijkstra_init", text: "d[s] = 0" },
        { key: "dijkstra_init", text: "var pq = [(0.0, s)]" },
        { key: "dijkstra_extract", text: "while !pq.isEmpty {" },
        { key: "dijkstra_extract", text: "  pq.sort { $0.0 < $1.0 }" },
        { key: "dijkstra_extract", text: "  let (dist_u, u) = pq.removeFirst()" },
        { key: "dijkstra_extract", text: "  if dist_u > d[u] { continue }" },
        { key: "dijkstra_relax", text: "  for (v, w) in adj[u] {" },
        { key: "dijkstra_relax", text: "      if d[u] + w < d[v] {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "dijkstra_relax", text: "          pq.append((d[v], v))" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "import Foundation" },
        { key: "prim_init", text: "var key = Array(repeating: Double.infinity, count: n)" },
        { key: "prim_init", text: "var parent = Array(repeating: -1, count: n)" },
        { key: "prim_init", text: "var inMST = Array(repeating: false, count: n)" },
        { key: "prim_init", text: "key[s] = 0" },
        { key: "prim_init", text: "var pq = [(0.0, s)]" },
        { key: "prim_extract", text: "while !pq.isEmpty {" },
        { key: "prim_extract", text: "  pq.sort { $0.0 < $1.0 }" },
        { key: "prim_extract", text: "  let (key_u, u) = pq.removeFirst()" },
        { key: "prim_extract", text: "  if inMST[u] { continue }" },
        { key: "prim_extract", text: "  inMST[u] = true" },
        { key: "prim_relax", text: "  for (v, w) in adj[u] {" },
        { key: "prim_relax", text: "      if !inMST[v] && w < key[v] {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u" },
        { key: "prim_relax", text: "          pq.append((key[v], v))" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "import Foundation" },
        { key: "bfs_init", text: "var d = Array(repeating: Int.max, count: n)" },
        { key: "bfs_init", text: "var parent = Array(repeating: -1, count: n)" },
        { key: "bfs_init", text: "var visited = Array(repeating: false, count: n)" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true; var q = [s]" },
        { key: "bfs_pop", text: "while !q.isEmpty {" },
        { key: "bfs_pop", text: "  let u = q.removeFirst()" },
        { key: "bfs_relax", text: "  for v in adj[u] {" },
        { key: "bfs_relax", text: "      if !visited[v] {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.append(v)" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "var visited = Array(repeating: false, count: n)" },
        { key: "dfs_init", text: "var parent = Array(repeating: -1, count: n)" },
        { key: "dfs_init", text: "func dfs(_ u: Int) {" },
        { key: "dfs_visit", text: "  visited[u] = true" },
        { key: "dfs_relax", text: "  for v in adj[u] {" },
        { key: "dfs_relax", text: "      if !visited[v] {" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v)" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    csharp: {
      relaxation: [
        { key: "init", text: "double[] d = new double[n]; int[] parent = new int[n];" },
        { key: "init", text: "Array.Fill(d, double.PositiveInfinity); Array.Fill(parent, -1); d[s] = 0;" },
        { key: "relax_outer", text: "for (int i = 0; i < n - 1; i++) {" },
        { key: "relax", text: "  foreach (var (u, v, w) in edges) {" },
        { key: "relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "double[] d = new double[n]; int[] parent = new int[n];" },
        { key: "bf_init", text: "Array.Fill(d, double.PositiveInfinity); Array.Fill(parent, -1); d[s] = 0;" },
        { key: "bf_outer", text: "for (int i = 0; i < n - 1; i++) {" },
        { key: "bf_relax", text: "  foreach (var (u, v, w) in edges) {" },
        { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "foreach (var (u, v, w) in edges) {" },
        { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) Console.WriteLine(\"negative cycle\");" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "double[] d = new double[n]; int[] parent = new int[n]; bool[] inQ = new bool[n];" },
        { key: "fifo_init", text: "Array.Fill(d, double.PositiveInfinity); Array.Fill(parent, -1); d[s] = 0;" },
        { key: "fifo_init", text: "var q = new Queue<int>(); q.Enqueue(s); inQ[s] = true;" },
        { key: "fifo_pop", text: "while (q.Count > 0) {" },
        { key: "fifo_pop", text: "  int u = q.Dequeue(); inQ[u] = false;" },
        { key: "fifo_relax", text: "  foreach (var (v, w) in adj[u]) {" },
        { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "fifo_relax", text: "          if (!inQ[v]) { q.Enqueue(v); inQ[v] = true; }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
        { key: "fifo_done", text: "// Algorithm completed" },
        { key: "fifo_check", text: "// Check for negative cycles" },
        { key: "fifo_check_edge", text: "foreach (var (u, v, w) in edges) {" },
        { key: "fifo_neg_cycle", text: "  if (d[u] + w < d[v]) Console.WriteLine(\"negative cycle\");" },
        { key: "fifo_check_edge", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "using System.Collections.Generic;" },
        { key: "dijkstra_init", text: "double[] d = new double[n]; int[] parent = new int[n];" },
        { key: "dijkstra_init", text: "Array.Fill(d, double.PositiveInfinity); Array.Fill(parent, -1);" },
        { key: "dijkstra_init", text: "d[s] = 0;" },
        { key: "dijkstra_init", text: "var pq = new PriorityQueue<int, double>();" },
        { key: "dijkstra_init", text: "pq.Enqueue(s, 0);" },
        { key: "dijkstra_extract", text: "while (pq.Count > 0) {" },
        { key: "dijkstra_extract", text: "  pq.TryDequeue(out int u, out double dist_u);" },
        { key: "dijkstra_extract", text: "  if (dist_u > d[u]) continue;" },
        { key: "dijkstra_relax", text: "  foreach (var (v, w) in adj[u]) {" },
        { key: "dijkstra_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "dijkstra_relax", text: "          pq.Enqueue(v, d[v]);" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "using System.Collections.Generic;" },
        { key: "prim_init", text: "double[] key = new double[n]; int[] parent = new int[n]; bool[] inMST = new bool[n];" },
        { key: "prim_init", text: "Array.Fill(key, double.PositiveInfinity); Array.Fill(parent, -1); key[s] = 0;" },
        { key: "prim_init", text: "var pq = new PriorityQueue<int, double>(); pq.Enqueue(s, 0);" },
        { key: "prim_extract", text: "while (pq.Count > 0) {" },
        { key: "prim_extract", text: "  pq.TryDequeue(out int u, out double key_u);" },
        { key: "prim_extract", text: "  if (inMST[u]) continue;" },
        { key: "prim_extract", text: "  inMST[u] = true;" },
        { key: "prim_relax", text: "  foreach (var (v, w) in adj[u]) {" },
        { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
        { key: "prim_relax", text: "          pq.Enqueue(v, key[v]);" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "using System.Collections.Generic;" },
        { key: "bfs_init", text: "int[] d = new int[n]; int[] parent = new int[n]; bool[] visited = new bool[n];" },
        { key: "bfs_init", text: "Array.Fill(d, int.MaxValue); Array.Fill(parent, -1); d[s] = 0; visited[s] = true;" },
        { key: "bfs_init", text: "Queue<int> q = new Queue<int>(); q.Enqueue(s);" },
        { key: "bfs_pop", text: "while (q.Count > 0) {" },
        { key: "bfs_pop", text: "  int u = q.Dequeue();" },
        { key: "bfs_relax", text: "  foreach (int v in adj[u]) {" },
        { key: "bfs_relax", text: "      if (!visited[v]) {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.Enqueue(v);" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "bool[] visited = new bool[n]; int[] parent = new int[n];" },
        { key: "dfs_init", text: "Array.Fill(parent, -1);" },
        { key: "dfs_init", text: "void Dfs(int u) {" },
        { key: "dfs_visit", text: "  visited[u] = true;" },
        { key: "dfs_relax", text: "  foreach (int v in adj[u]) {" },
        { key: "dfs_relax", text: "      if (!visited[v]) {" },
        { key: "dfs_relax", text: "          parent[v] = u; Dfs(v);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    ruby: {
      relaxation: [
        { key: "init", text: "d = Array.new(n, Float::INFINITY); parent = Array.new(n, nil)" },
        { key: "init", text: "d[s] = 0" },
        { key: "relax_outer", text: "(n - 1).times do" },
        { key: "relax", text: "  edges.each do |u, v, w|" },
        { key: "relax", text: "      if d[u] + w < d[v]" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "relax", text: "      end" },
        { key: "relax", text: "  end" },
        { key: "relax_outer", text: "end" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "d = Array.new(n, Float::INFINITY); parent = Array.new(n, nil)" },
        { key: "bf_init", text: "d[s] = 0" },
        { key: "bf_outer", text: "(n - 1).times do" },
        { key: "bf_relax", text: "  edges.each do |u, v, w|" },
        { key: "bf_relax", text: "      if d[u] + w < d[v]" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "bf_relax", text: "      end" },
        { key: "bf_relax", text: "  end" },
        { key: "bf_outer", text: "end" },
        { key: "bf_check", text: "edges.each do |u, v, w|" },
        { key: "bf_neg_cycle", text: "  puts 'negative cycle' if d[u] + w < d[v]" },
        { key: "bf_check", text: "end" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "d = Array.new(n, Float::INFINITY); parent = Array.new(n, nil)" },
        { key: "fifo_init", text: "d[s] = 0" },
        { key: "fifo_init", text: "q = [s]; in_q = Array.new(n, false); in_q[s] = true" },
        { key: "fifo_pop", text: "until q.empty?" },
        { key: "fifo_pop", text: "  u = q.shift; in_q[u] = false" },
        { key: "fifo_relax", text: "  adj[u].each do |v, w|" },
        { key: "fifo_relax", text: "      if d[u] + w < d[v]" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "fifo_relax", text: "          unless in_q[v]; q << v; in_q[v] = true end" },
        { key: "fifo_relax", text: "      end" },
        { key: "fifo_relax", text: "  end" },
        { key: "fifo_pop", text: "end" },
        { key: "fifo_done", text: "# Algorithm completed" },
        { key: "fifo_check", text: "# Check for negative cycles" },
        { key: "fifo_check_edge", text: "edges.each do |u, v, w|" },
        { key: "fifo_neg_cycle", text: "  puts 'negative cycle' if d[u] + w < d[v]" },
        { key: "fifo_check_edge", text: "end" },
      ],
      bfs: [
        { key: "bfs_init", text: "require 'set'" },
        { key: "bfs_init", text: "d = Hash.new(Float::INFINITY); parent = {}; visited = Set.new" },
        { key: "bfs_init", text: "d[s] = 0; visited.add(s); q = [s]" },
        { key: "bfs_pop", text: "until q.empty?" },
        { key: "bfs_pop", text: "  u = q.shift" },
        { key: "bfs_relax", text: "  adj[u].each do |v, _|" },
        { key: "bfs_relax", text: "      unless visited.include?(v)" },
        { key: "bfs_relax", text: "          visited.add(v); d[v] = d[u] + 1; parent[v] = u; q << v" },
        { key: "bfs_relax", text: "      end" },
        { key: "bfs_relax", text: "  end" },
        { key: "bfs_pop", text: "end" },
      ],
      prim: [
        { key: "prim_init", text: "require 'set'" },
        { key: "prim_init", text: "key = Hash.new(Float::INFINITY); parent = {}; in_mst = Set.new" },
        { key: "prim_init", text: "key[s] = 0" },
        { key: "prim_init", text: "pq = [[0, s]]" },
        { key: "prim_extract", text: "until pq.empty?" },
        { key: "prim_extract", text: "  pq.sort_by! { |x| x[0] }" },
        { key: "prim_extract", text: "  key_u, u = pq.shift" },
        { key: "prim_extract", text: "  next if in_mst.include?(u)" },
        { key: "prim_extract", text: "  in_mst.add(u)" },
        { key: "prim_relax", text: "  adj[u].each do |v, w|" },
        { key: "prim_relax", text: "      unless in_mst.include?(v)" },
        { key: "prim_relax", text: "          if w < key[v]" },
        { key: "prim_relax", text: "              key[v] = w; parent[v] = u; pq << [key[v], v]" },
        { key: "prim_relax", text: "          end" },
        { key: "prim_relax", text: "      end" },
        { key: "prim_relax", text: "  end" },
        { key: "prim_extract", text: "end" },
        { key: "prim_done", text: "# MST constructed" },
      ],
      dfs: [
        { key: "dfs_init", text: "visited = Set.new; parent = {}" },
        { key: "dfs_init", text: "def dfs(u)" },
        { key: "dfs_visit", text: "  visited.add(u)" },
        { key: "dfs_relax", text: "  adj[u].each do |v, _|" },
        { key: "dfs_relax", text: "      unless visited.include?(v)" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v)" },
        { key: "dfs_relax", text: "      end" },
        { key: "dfs_relax", text: "  end" },
        { key: "dfs_visit", text: "end" },
      ],
    },
    php: {
      relaxation: [
        { key: "init", text: "$d = array_fill(0, $n, INF); $parent = array_fill(0, $n, null);" },
        { key: "init", text: "$d[$s] = 0;" },
        { key: "relax_outer", text: "for ($i = 0; $i < $n - 1; $i++) {" },
        { key: "relax", text: "  foreach ($edges as [$u, $v, $w]) {" },
        { key: "relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
        { key: "relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "$d = array_fill(0, $n, INF); $parent = array_fill(0, $n, null);" },
        { key: "bf_init", text: "$d[$s] = 0;" },
        { key: "bf_outer", text: "for ($i = 0; $i < $n - 1; $i++) {" },
        { key: "bf_relax", text: "  foreach ($edges as [$u, $v, $w]) {" },
        { key: "bf_relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
        { key: "bf_relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "foreach ($edges as [$u, $v, $w]) {" },
        { key: "bf_neg_cycle", text: "  if ($d[$u] + $w < $d[$v]) echo 'negative cycle';" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "$d = array_fill(0, $n, INF); $parent = array_fill(0, $n, null);" },
        { key: "fifo_init", text: "$d[$s] = 0;" },
        { key: "fifo_init", text: "$q = [$s]; $inQ = array_fill(0, $n, false); $inQ[$s] = true;" },
        { key: "fifo_pop", text: "while (!empty($q)) {" },
        { key: "fifo_pop", text: "  $u = array_shift($q); $inQ[$u] = false;" },
        { key: "fifo_relax", text: "  foreach ($adj[$u] as [$v, $w]) {" },
        { key: "fifo_relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
        { key: "fifo_relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
        { key: "fifo_relax", text: "          if (!$inQ[$v]) { $q[] = $v; $inQ[$v] = true; }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
        { key: "fifo_done", text: "// Algorithm completed" },
        { key: "fifo_check", text: "// Check for negative cycles" },
        { key: "fifo_check_edge", text: "foreach ($edges as [$u, $v, $w]) {" },
        { key: "fifo_neg_cycle", text: "  if ($d[$u] + $w < $d[$v]) echo 'negative cycle';" },
        { key: "fifo_check_edge", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "$d = array_fill(0, $n, INF); $parent = array_fill(0, $n, -1);" },
        { key: "dijkstra_init", text: "$d[$s] = 0;" },
        { key: "dijkstra_init", text: "$pq = new SplPriorityQueue(); $pq->setExtractFlags(SplPriorityQueue::EXTR_BOTH);" },
        { key: "dijkstra_init", text: "$pq->insert($s, 0);" },
        { key: "dijkstra_extract", text: "while (!$pq->isEmpty()) {" },
        { key: "dijkstra_extract", text: "  $item = $pq->extract(); $u = $item['data']; $dist_u = -$item['priority'];" },
        { key: "dijkstra_extract", text: "  if ($dist_u > $d[$u]) continue;" },
        { key: "dijkstra_relax", text: "  foreach ($adj[$u] as $v => $w) {" },
        { key: "dijkstra_relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
        { key: "dijkstra_relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
        { key: "dijkstra_relax", text: "          $pq->insert($v, -$d[$v]);" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "$key = array_fill(0, $n, INF); $parent = array_fill(0, $n, -1); $inMST = array_fill(0, $n, false);" },
        { key: "prim_init", text: "$key[$s] = 0;" },
        { key: "prim_init", text: "$pq = [[0, $s]];" },
        { key: "prim_extract", text: "while (!empty($pq)) {" },
        { key: "prim_extract", text: "  usort($pq, function($a, $b) { return $a[0] - $b[0]; });" },
        { key: "prim_extract", text: "  list($key_u, $u) = array_shift($pq);" },
        { key: "prim_extract", text: "  if ($inMST[$u]) continue;" },
        { key: "prim_extract", text: "  $inMST[$u] = true;" },
        { key: "prim_relax", text: "  foreach ($adj[$u] as [$v, $w]) {" },
        { key: "prim_relax", text: "      if (!$inMST[$v] && $w < $key[$v]) {" },
        { key: "prim_relax", text: "          $key[$v] = $w; $parent[$v] = $u;" },
        { key: "prim_relax", text: "          array_push($pq, [$key[$v], $v]);" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "$d = array_fill(0, $n, INF); $parent = array_fill(0, $n, -1); $visited = array_fill(0, $n, false);" },
        { key: "bfs_init", text: "$d[$s] = 0; $visited[$s] = true; $q = [$s];" },
        { key: "bfs_pop", text: "while (!empty($q)) {" },
        { key: "bfs_pop", text: "  $u = array_shift($q);" },
        { key: "bfs_relax", text: "  foreach ($adj[$u] as $v) {" },
        { key: "bfs_relax", text: "      if (!$visited[$v]) {" },
        { key: "bfs_relax", text: "          $visited[$v] = true; $d[$v] = $d[$u] + 1; $parent[$v] = $u; array_push($q, $v);" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "$visited = array_fill(0, $n, false); $parent = array_fill(0, $n, -1);" },
        { key: "dfs_init", text: "function dfs($u) {" },
        { key: "dfs_visit", text: "  $visited[$u] = true;" },
        { key: "dfs_relax", text: "  foreach ($adj[$u] as $v) {" },
        { key: "dfs_relax", text: "      if (!$visited[$v]) {" },
        { key: "dfs_relax", text: "          $parent[$v] = $u; dfs($v);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    scala: {
      relaxation: [
        { key: "init", text: "val d = Array.fill(n)(Double.PositiveInfinity); val parent = Array.fill(n)(-1)" },
        { key: "init", text: "d(s) = 0" },
        { key: "relax_outer", text: "for (_ <- 0 until n - 1) {" },
        { key: "relax", text: "  edges.foreach { case (u, v, w) =>" },
        { key: "relax", text: "      if (d(u) + w < d(v)) {" },
        { key: "relax", text: "          d(v) = d(u) + w; parent(v) = u" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "val d = Array.fill(n)(Double.PositiveInfinity); val parent = Array.fill(n)(-1)" },
        { key: "bf_init", text: "d(s) = 0" },
        { key: "bf_outer", text: "for (_ <- 0 until n - 1) {" },
        { key: "bf_relax", text: "  edges.foreach { case (u, v, w) =>" },
        { key: "bf_relax", text: "      if (d(u) + w < d(v)) {" },
        { key: "bf_relax", text: "          d(v) = d(u) + w; parent(v) = u" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "edges.foreach { case (u, v, w) =>" },
        { key: "bf_neg_cycle", text: "  if (d(u) + w < d(v)) println(\"negative cycle\")" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "val d = Array.fill(n)(Double.PositiveInfinity); val parent = Array.fill(n)(-1)" },
        { key: "fifo_init", text: "d(s) = 0" },
        { key: "fifo_init", text: "import scala.collection.mutable.Queue" },
        { key: "fifo_init", text: "val q = Queue(s); val inQ = Array.fill(n)(false); inQ(s) = true" },
        { key: "fifo_pop", text: "while (q.nonEmpty) {" },
        { key: "fifo_pop", text: "  val u = q.dequeue(); inQ(u) = false" },
        { key: "fifo_relax", text: "  adj(u).foreach { case (v, w) =>" },
        { key: "fifo_relax", text: "      if (d(u) + w < d(v)) {" },
        { key: "fifo_relax", text: "          d(v) = d(u) + w; parent(v) = u" },
        { key: "fifo_relax", text: "          if (!inQ(v)) { q.enqueue(v); inQ(v) = true }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
        { key: "fifo_done", text: "// Algorithm completed" },
        { key: "fifo_check", text: "// Check for negative cycles" },
        { key: "fifo_check_edge", text: "edges.foreach { case (u, v, w) =>" },
        { key: "fifo_neg_cycle", text: "  if (d(u) + w < d(v)) println(\"negative cycle\")" },
        { key: "fifo_check_edge", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "import scala.collection.mutable" },
        { key: "dijkstra_init", text: "val d = Array.fill(n)(Double.PositiveInfinity)" },
        { key: "dijkstra_init", text: "val parent = Array.fill(n)(-1)" },
        { key: "dijkstra_init", text: "d(s) = 0.0" },
        { key: "dijkstra_init", text: "val pq = mutable.PriorityQueue((0.0, s))(Ordering.by(-_._1))" },
        { key: "dijkstra_extract", text: "while (pq.nonEmpty) {" },
        { key: "dijkstra_extract", text: "  val (dist_u, u) = pq.dequeue" },
        { key: "dijkstra_extract", text: "  if (dist_u > d(u)) return" },
        { key: "dijkstra_relax", text: "  adj(u).foreach { case (v, w) =>" },
        { key: "dijkstra_relax", text: "      if (d(u) + w < d(v)) {" },
        { key: "dijkstra_relax", text: "          d(v) = d(u) + w; parent(v) = u" },
        { key: "dijkstra_relax", text: "          pq.enqueue((d(v), v))" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "import scala.collection.mutable" },
        { key: "prim_init", text: "val key = Array.fill(n)(Double.PositiveInfinity)" },
        { key: "prim_init", text: "val parent = Array.fill(n)(-1)" },
        { key: "prim_init", text: "val inMST = Array.fill(n)(false)" },
        { key: "prim_init", text: "key(s) = 0.0" },
        { key: "prim_init", text: "val pq = mutable.PriorityQueue((0.0, s))(Ordering.by(-_._1))" },
        { key: "prim_extract", text: "while (pq.nonEmpty) {" },
        { key: "prim_extract", text: "  val (key_u, u) = pq.dequeue" },
        { key: "prim_extract", text: "  if (inMST(u)) return" },
        { key: "prim_extract", text: "  inMST(u) = true" },
        { key: "prim_relax", text: "  adj(u).foreach { case (v, w) =>" },
        { key: "prim_relax", text: "      if (!inMST(v) && w < key(v)) {" },
        { key: "prim_relax", text: "          key(v) = w; parent(v) = u" },
        { key: "prim_relax", text: "          pq.enqueue((key(v), v))" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "import scala.collection.mutable" },
        { key: "bfs_init", text: "val d = Array.fill(n)(Int.MaxValue)" },
        { key: "bfs_init", text: "val parent = Array.fill(n)(-1)" },
        { key: "bfs_init", text: "val visited = Array.fill(n)(false)" },
        { key: "bfs_init", text: "d(s) = 0; visited(s) = true; val q = mutable.Queue(s)" },
        { key: "bfs_pop", text: "while (q.nonEmpty) {" },
        { key: "bfs_pop", text: "  val u = q.dequeue" },
        { key: "bfs_relax", text: "  adj(u).foreach { v =>" },
        { key: "bfs_relax", text: "      if (!visited(v)) {" },
        { key: "bfs_relax", text: "          visited(v) = true; d(v) = d(u) + 1; parent(v) = u; q.enqueue(v)" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "val visited = Array.fill(n)(false); val parent = Array.fill(n)(-1)" },
        { key: "dfs_init", text: "def dfs(u: Int): Unit = {" },
        { key: "dfs_visit", text: "  visited(u) = true" },
        { key: "dfs_relax", text: "  adj(u).foreach { v =>" },
        { key: "dfs_relax", text: "      if (!visited(v)) {" },
        { key: "dfs_relax", text: "          parent(v) = u; dfs(v)" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    haskell: {
      relaxation: [
        { key: "init", text: "d = replicate n (1/0) :: [Double]" },
        { key: "init", text: "parent = replicate n Nothing :: [Maybe Int]" },
        { key: "init", text: "d' = take s d ++ [0] ++ drop (s+1) d" },
        { key: "relax_outer", text: "relaxAll edges dist par = foldl relax (dist, par) edges" },
        { key: "relax", text: "relax (d, p) (u, v, w) | d!!u + w < d!!v = (update d v (d!!u + w), update p v (Just u))" },
        { key: "relax", text: "                | otherwise = (d, p)" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "d = replicate n (1/0) :: [Double]" },
        { key: "bf_init", text: "parent = replicate n Nothing :: [Maybe Int]" },
        { key: "bf_init", text: "d' = take s d ++ [0] ++ drop (s+1) d" },
        { key: "bf_outer", text: "bf dist par = foldl (\\acc _ -> relaxAll edges acc) (dist, par) [1..n-1]" },
        { key: "bf_relax", text: "relaxAll edges (d, p) = foldl relax (d, p) edges" },
        { key: "bf_relax", text: "relax (d, p) (u, v, w) | d!!u + w < d!!v = (update d v (d!!u + w), update p v (Just u))" },
        { key: "bf_relax", text: "                | otherwise = (d, p)" },
        { key: "bf_check", text: "hasNegCycle edges d = any (\\(u, v, w) -> d!!u + w < d!!v) edges" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "d = replicate n (1/0) :: [Double]" },
        { key: "fifo_init", text: "parent = replicate n Nothing :: [Maybe Int]" },
        { key: "fifo_init", text: "d' = take s d ++ [0] ++ drop (s+1) d" },
        { key: "fifo_init", text: "q = [s]; inQ = replicate n False" },
        { key: "fifo_pop", text: "bfFIFO q inQ d p | null q = (d, p)" },
        { key: "fifo_pop", text: "              | otherwise = let (u:qs) = q in process u qs" },
        { key: "fifo_relax", text: "process u qs = foldl relaxEdge (qs, d, p) (adj u)" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "import Data.Heap (MinHeap, empty, insert, view)" },
        { key: "dijkstra_init", text: "import qualified Data.Heap as H" },
        { key: "dijkstra_init", text: "let d = replicate n (1/0) in let parent = replicate n (-1) in" },
        { key: "dijkstra_init", text: "let d' = update d s 0 in" },
        { key: "dijkstra_init", text: "let pq = H.singleton (0, s) in" },
        { key: "dijkstra_extract", text: "dijkstra d parent pq = case H.view pq of" },
        { key: "dijkstra_extract", text: "  Nothing -> (d, parent)" },
        { key: "dijkstra_extract", text: "  Just ((dist_u, u), pq') ->" },
        { key: "dijkstra_extract", text: "    if dist_u > d !! u then dijkstra d parent pq'" },
        { key: "dijkstra_relax", text: "    else let relax (v, w) (d'', parent'', pq'') =" },
        { key: "dijkstra_relax", text: "            if d'' !! u + w < d'' !! v then" },
        { key: "dijkstra_relax", text: "              (update d'' v (d'' !! u + w), update parent'' v u, H.insert (d'' !! u + w, v) pq'')" },
        { key: "dijkstra_relax", text: "            else (d'', parent'', pq'')" },
        { key: "dijkstra_relax", text: "          in foldr relax (d, parent, pq') (adj !! u)" },
      ],
      prim: [
        { key: "prim_init", text: "import Data.Heap (MinHeap, empty, insert, view)" },
        { key: "prim_init", text: "import qualified Data.Heap as H" },
        { key: "prim_init", text: "let key = replicate n (1/0) in let parent = replicate n (-1) in" },
        { key: "prim_init", text: "let key' = update key s 0 in" },
        { key: "prim_init", text: "let pq = H.singleton (0, s) in" },
        { key: "prim_extract", text: "prim key parent pq = case H.view pq of" },
        { key: "prim_extract", text: "  Nothing -> (key, parent)" },
        { key: "prim_extract", text: "  Just ((key_u, u), pq') ->" },
        { key: "prim_extract", text: "    if inMST u then prim key parent pq'" },
        { key: "prim_relax", text: "    else let relax (v, w) (key'', parent'', pq'') =" },
        { key: "prim_relax", text: "            if not (inMST v) && w < key'' !! v then" },
        { key: "prim_relax", text: "              (update key'' v w, update parent'' v u, H.insert (w, v) pq'')" },
        { key: "prim_relax", text: "            else (key'', parent'', pq'')" },
        { key: "prim_relax", text: "          in foldr relax (key, parent, pq') (adj !! u)" },
        { key: "prim_done", text: "-- MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "import Data.Sequence (Seq, (|>), (<|), empty, null)" },
        { key: "bfs_init", text: "d = replicate n maxBound :: [Int]" },
        { key: "bfs_init", text: "parent = replicate n Nothing :: [Maybe Int]" },
        { key: "bfs_init", text: "visited = replicate n False" },
        { key: "bfs_init", text: "d' = take s d ++ [0] ++ drop (s+1) d" },
        { key: "bfs_init", text: "visited' = take s visited ++ [True] ++ drop (s+1) visited" },
        { key: "bfs_init", text: "q = s <| empty" },
        { key: "bfs_pop", text: "bfs d parent visited q | null q = (d, parent)" },
        { key: "bfs_pop", text: "              | otherwise = let (u :< qs) = viewl q in process u qs" },
        { key: "bfs_relax", text: "process u qs = foldl relax (qs, d, parent, visited) (adj u)" },
        { key: "bfs_relax", text: "relax (q, d, p, v) n | not (v !! n) = (n <| q, update d n (d !! u + 1), update p n (Just u), update v n True)" },
        { key: "bfs_relax", text: "                | otherwise = (q, d, p, v)" },
      ],
      dfs: [
        { key: "dfs_init", text: "visited = replicate n False :: [Bool]" },
        { key: "dfs_init", text: "parent = replicate n Nothing :: [Maybe Int]" },
        { key: "dfs_init", text: "dfs u visited parent = let visited' = update visited u True in" },
        { key: "dfs_visit", text: "  foldl (\\acc v -> if not (visited !! v) then dfs v (update acc v True) (update parent v (Just u)) else acc) visited' (adj u)" },
      ],
    },
    ocaml: {
      relaxation: [
        { key: "init", text: "let d = Array.make n infinity in" },
        { key: "init", text: "let parent = Array.make n None in" },
        { key: "init", text: "d.(s) <- 0.0;" },
        { key: "relax_outer", text: "for _ = 0 to n - 2 do" },
        { key: "relax", text: "  List.iter (fun (u, v, w) ->" },
        { key: "relax", text: "      if d.(u) +. w < d.(v) then (" },
        { key: "relax", text: "          d.(v) <- d.(u) +. w; parent.(v) <- Some u" },
        { key: "relax", text: "      )" },
        { key: "relax", text: "  ) edges" },
        { key: "relax_outer", text: "done" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "let d = Array.make n infinity in" },
        { key: "bf_init", text: "let parent = Array.make n None in" },
        { key: "bf_init", text: "d.(s) <- 0.0;" },
        { key: "bf_outer", text: "for _ = 0 to n - 2 do" },
        { key: "bf_relax", text: "  List.iter (fun (u, v, w) ->" },
        { key: "bf_relax", text: "      if d.(u) +. w < d.(v) then (" },
        { key: "bf_relax", text: "          d.(v) <- d.(u) +. w; parent.(v) <- Some u" },
        { key: "bf_relax", text: "      )" },
        { key: "bf_relax", text: "  ) edges" },
        { key: "bf_outer", text: "done" },
        { key: "bf_check", text: "List.iter (fun (u, v, w) ->" },
        { key: "bf_neg_cycle", text: "  if d.(u) +. w < d.(v) then print_string \"negative cycle\"" },
        { key: "bf_check", text: ") edges" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "let d = Array.make n infinity in" },
        { key: "fifo_init", text: "let parent = Array.make n None in" },
        { key: "fifo_init", text: "d.(s) <- 0.0;" },
        { key: "fifo_init", text: "let q = Queue.create () in" },
        { key: "fifo_init", text: "let in_q = Array.make n false in" },
        { key: "fifo_init", text: "Queue.push s q; in_q.(s) <- true;" },
        { key: "fifo_pop", text: "while not (Queue.is_empty q) do" },
        { key: "fifo_pop", text: "  let u = Queue.pop q in in_q.(u) <- false;" },
        { key: "fifo_relax", text: "  List.iter (fun (v, w) ->" },
        { key: "fifo_relax", text: "      if d.(u) +. w < d.(v) then (" },
        { key: "fifo_relax", text: "          d.(v) <- d.(u) +. w; parent.(v) <- Some u;" },
        { key: "fifo_relax", text: "          if not in_q.(v) then (Queue.push v q; in_q.(v) <- true)" },
        { key: "fifo_relax", text: "      )" },
        { key: "fifo_relax", text: "  ) adj.(u)" },
        { key: "fifo_pop", text: "done" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "module Heap = BatHeap" },
        { key: "dijkstra_init", text: "let d = Array.make n infinity in" },
        { key: "dijkstra_init", text: "let parent = Array.make n (-1) in" },
        { key: "dijkstra_init", text: "d.(s) <- 0.0;" },
        { key: "dijkstra_init", text: "let pq = Heap.empty |> Heap.insert (0.0, s) in" },
        { key: "dijkstra_extract", text: "let rec dijkstra d parent pq = match Heap.find_min pq with" },
        { key: "dijkstra_extract", text: "  | None -> (d, parent)" },
        { key: "dijkstra_extract", text: "  | Some (dist_u, u) ->" },
        { key: "dijkstra_extract", text: "    let pq' = Heap.delete_min pq in" },
        { key: "dijkstra_extract", text: "    if dist_u > d.(u) then dijkstra d parent pq'" },
        { key: "dijkstra_relax", text: "    else let relax (v, w) (d'', parent'', pq'') =" },
        { key: "dijkstra_relax", text: "            if d''.(u) +. w < d''.(v) then" },
        { key: "dijkstra_relax", text: "              (d''.(v) <- d''.(u) +. w; parent''.(v) <- u; Heap.insert (d''.(v), v) pq'')" },
        { key: "dijkstra_relax", text: "            else (d'', parent'', pq'')" },
        { key: "dijkstra_relax", text: "        in List.fold_right relax adj.(u) (d, parent, pq')" },
      ],
      prim: [
        { key: "prim_init", text: "module Heap = BatHeap" },
        { key: "prim_init", text: "let key = Array.make n infinity in" },
        { key: "prim_init", text: "let parent = Array.make n (-1) in" },
        { key: "prim_init", text: "let in_mst = Array.make n false in" },
        { key: "prim_init", text: "key.(s) <- 0.0;" },
        { key: "prim_init", text: "let pq = Heap.empty |> Heap.insert (0.0, s) in" },
        { key: "prim_extract", text: "let rec prim key parent in_mst pq = match Heap.find_min pq with" },
        { key: "prim_extract", text: "  | None -> (key, parent)" },
        { key: "prim_extract", text: "  | Some (key_u, u) ->" },
        { key: "prim_extract", text: "    let pq' = Heap.delete_min pq in" },
        { key: "prim_extract", text: "    if in_mst.(u) then prim key parent in_mst pq'" },
        { key: "prim_extract", text: "    else (in_mst.(u) <- true;" },
        { key: "prim_relax", text: "     let relax (v, w) (key'', parent'', pq'') =" },
        { key: "prim_relax", text: "            if not in_mst.(v) && w < key''.(v) then" },
        { key: "prim_relax", text: "              (key''.(v) <- w; parent''.(v) <- u; Heap.insert (w, v) pq'')" },
        { key: "prim_relax", text: "            else (key'', parent'', pq'')" },
        { key: "prim_relax", text: "     in List.fold_right relax adj.(u) (key, parent, pq'))" },
        { key: "prim_done", text: "(* MST constructed *)" },
      ],
      bfs: [
        { key: "bfs_init", text: "module Queue = BatQueue" },
        { key: "bfs_init", text: "let d = Array.make n max_int in" },
        { key: "bfs_init", text: "let parent = Array.make n None in" },
        { key: "bfs_init", text: "let visited = Array.make n false in" },
        { key: "bfs_init", text: "d.(s) <- 0; visited.(s) <- true;" },
        { key: "bfs_init", text: "let q = Queue.empty |> Queue.push s in" },
        { key: "bfs_pop", text: "let rec bfs d parent visited q = match Queue.is_empty q with" },
        { key: "bfs_pop", text: "  | true -> (d, parent)" },
        { key: "bfs_pop", text: "  | false -> let (u, q') = Queue.pop q in process u q' d parent visited" },
        { key: "bfs_relax", text: "and process u q d parent visited = List.fold_left (fun (q', d', p', v') v ->" },
        { key: "bfs_relax", text: "    if not v'.(v) then (Queue.push v q', d'.(v) <- d'.(u) + 1; p'.(v) <- Some u; v'.(v) <- true; (q', d', p', v'))" },
        { key: "bfs_relax", text: "    else (q', d', p', v')) (q, d, parent, visited) (adj u)" },
      ],
      dfs: [
        { key: "dfs_init", text: "let visited = Array.make n false in" },
        { key: "dfs_init", text: "let parent = Array.make n None in" },
        { key: "dfs_init", text: "let rec dfs u visited parent =" },
        { key: "dfs_visit", text: "  visited.(u) <- true;" },
        { key: "dfs_relax", text: "  List.iter (fun v ->" },
        { key: "dfs_relax", text: "      if not visited.(v) then (parent.(v) <- Some u; dfs v visited parent)" },
        { key: "dfs_relax", text: "  ) (adj u)" },
      ],
    },
    fsharp: {
      relaxation: [
        { key: "init", text: "let d = Array.create n System.Double.PositiveInfinity" },
        { key: "init", text: "let parent = Array.create n None" },
        { key: "init", text: "d.[s] <- 0.0" },
        { key: "relax_outer", text: "for _ in 0 .. n - 2 do" },
        { key: "relax", text: "  edges |> List.iter (fun (u, v, w) ->" },
        { key: "relax", text: "      if d.[u] + w < d.[v] then (" },
        { key: "relax", text: "          d.[v] <- d.[u] + w; parent.[v] <- Some u" },
        { key: "relax", text: "      )" },
        { key: "relax", text: "  )" },
        { key: "relax_outer", text: "done" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "let d = Array.create n System.Double.PositiveInfinity" },
        { key: "bf_init", text: "let parent = Array.create n None" },
        { key: "bf_init", text: "d.[s] <- 0.0" },
        { key: "bf_outer", text: "for _ in 0 .. n - 2 do" },
        { key: "bf_relax", text: "  edges |> List.iter (fun (u, v, w) ->" },
        { key: "bf_relax", text: "      if d.[u] + w < d.[v] then (" },
        { key: "bf_relax", text: "          d.[v] <- d.[u] + w; parent.[v] <- Some u" },
        { key: "bf_relax", text: "      )" },
        { key: "bf_relax", text: "  )" },
        { key: "bf_outer", text: "done" },
        { key: "bf_check", text: "edges |> List.iter (fun (u, v, w) ->" },
        { key: "bf_neg_cycle", text: "  if d.[u] + w < d.[v] then printfn \"negative cycle\"" },
        { key: "bf_check", text: ")" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "let d = Array.create n System.Double.PositiveInfinity" },
        { key: "fifo_init", text: "let parent = Array.create n None" },
        { key: "fifo_init", text: "d.[s] <- 0.0" },
        { key: "fifo_init", text: "let q = System.Collections.Generic.Queue<int>()" },
        { key: "fifo_init", text: "let inQ = Array.create n false" },
        { key: "fifo_init", text: "q.Enqueue(s); inQ.[s] <- true" },
        { key: "fifo_pop", text: "while q.Count > 0 do" },
        { key: "fifo_pop", text: "  let u = q.Dequeue() in inQ.[u] <- false" },
        { key: "fifo_relax", text: "  adj.[u] |> List.iter (fun (v, w) ->" },
        { key: "fifo_relax", text: "      if d.[u] + w < d.[v] then (" },
        { key: "fifo_relax", text: "          d.[v] <- d.[u] + w; parent.[v] <- Some u;" },
        { key: "fifo_relax", text: "          if not inQ.[v] then (q.Enqueue(v); inQ.[v] <- true)" },
        { key: "fifo_relax", text: "      )" },
        { key: "fifo_relax", text: "  )" },
        { key: "fifo_pop", text: "done" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "open System.Collections.Generic" },
        { key: "dijkstra_init", text: "let d = Array.create n System.Double.MaxValue" },
        { key: "dijkstra_init", text: "let parent = Array.create n -1" },
        { key: "dijkstra_init", text: "d.[s] <- 0.0" },
        { key: "dijkstra_init", text: "let pq = SortedSet<(float * int)>(compare)" },
        { key: "dijkstra_init", text: "pq.Add((0.0, s)) |> ignore" },
        { key: "dijkstra_extract", text: "while pq.Count > 0 do" },
        { key: "dijkstra_extract", text: "  let (dist_u, u) = pq.Min; pq.Remove((dist_u, u)) |> ignore" },
        { key: "dijkstra_extract", text: "  if dist_u > d.[u] then ()" },
        { key: "dijkstra_relax", text: "  else adj.[u] |> List.iter (fun (v, w) ->" },
        { key: "dijkstra_relax", text: "      if d.[u] + w < d.[v] then" },
        { key: "dijkstra_relax", text: "        d.[v] <- d.[u] + w; parent.[v] <- u" },
        { key: "dijkstra_relax", text: "        pq.Add((d.[v], v)) |> ignore)" },
      ],
      prim: [
        { key: "prim_init", text: "open System.Collections.Generic" },
        { key: "prim_init", text: "let key = Array.create n System.Double.PositiveInfinity" },
        { key: "prim_init", text: "let parent = Array.create n -1" },
        { key: "prim_init", text: "let inMST = Array.create n false" },
        { key: "prim_init", text: "key.[s] <- 0.0" },
        { key: "prim_init", text: "let pq = SortedSet<(float * int)>(compare); pq.Add((0.0, s)) |> ignore" },
        { key: "prim_extract", text: "while pq.Count > 0 do" },
        { key: "prim_extract", text: "  let (key_u, u) = pq.Min; pq.Remove((key_u, u)) |> ignore" },
        { key: "prim_extract", text: "  if inMST.[u] then ()" },
        { key: "prim_extract", text: "  else inMST.[u] <- true" },
        { key: "prim_relax", text: "  adj.[u] |> List.iter (fun (v, w) ->" },
        { key: "prim_relax", text: "      if not inMST.[v] && w < key.[v] then" },
        { key: "prim_relax", text: "        key.[v] <- w; parent.[v] <- u" },
        { key: "prim_relax", text: "        pq.Add((key.[v], v)) |> ignore)" },
      ],
      bfs: [
        { key: "bfs_init", text: "open System.Collections.Generic" },
        { key: "bfs_init", text: "let d = Array.create n System.Int32.MaxValue" },
        { key: "bfs_init", text: "let parent = Array.create n -1" },
        { key: "bfs_init", text: "let visited = Array.create n false" },
        { key: "bfs_init", text: "d.[s] <- 0; visited.[s] <- true" },
        { key: "bfs_init", text: "let q = Queue<int>(); q.Enqueue(s)" },
        { key: "bfs_pop", text: "while q.Count > 0 do" },
        { key: "bfs_pop", text: "  let u = q.Dequeue()" },
        { key: "bfs_relax", text: "  adj.[u] |> List.iter (fun v ->" },
        { key: "bfs_relax", text: "      if not visited.[v] then" },
        { key: "bfs_relax", text: "        visited.[v] <- true; d.[v] <- d.[u] + 1; parent.[v] <- u; q.Enqueue(v))" },
      ],
      dfs: [
        { key: "dfs_init", text: "let visited = Array.create n false" },
        { key: "dfs_init", text: "let parent = Array.create n -1" },
        { key: "dfs_init", text: "let rec dfs u =" },
        { key: "dfs_visit", text: "  visited.[u] <- true" },
        { key: "dfs_relax", text: "  adj.[u] |> List.iter (fun v ->" },
        { key: "dfs_relax", text: "      if not visited.[v] then" },
        { key: "dfs_relax", text: "        parent.[v] <- u; dfs v)" },
      ],
    },
    dart: {
      relaxation: [
        { key: "init", text: "List<double> d = List.filled(n, double.infinity);" },
        { key: "init", text: "List<int?> parent = List.filled(n, null);" },
        { key: "init", text: "d[s] = 0;" },
        { key: "relax_outer", text: "for (int i = 0; i < n - 1; i++) {" },
        { key: "relax", text: "  for (var (u, v, w) in edges) {" },
        { key: "relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "List<double> d = List.filled(n, double.infinity);" },
        { key: "bf_init", text: "List<int?> parent = List.filled(n, null);" },
        { key: "bf_init", text: "d[s] = 0;" },
        { key: "bf_outer", text: "for (int i = 0; i < n - 1; i++) {" },
        { key: "bf_relax", text: "  for (var (u, v, w) in edges) {" },
        { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for (var (u, v, w) in edges) {" },
        { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) print('negative cycle');" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "List<double> d = List.filled(n, double.infinity);" },
        { key: "fifo_init", text: "List<int?> parent = List.filled(n, null);" },
        { key: "fifo_init", text: "d[s] = 0;" },
        { key: "fifo_init", text: "var q = <int>[s]; var inQ = List.filled(n, false); inQ[s] = true;" },
        { key: "fifo_pop", text: "while (q.isNotEmpty) {" },
        { key: "fifo_pop", text: "  int u = q.removeAt(0); inQ[u] = false;" },
        { key: "fifo_relax", text: "  for (var (v, w) in adj[u]) {" },
        { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "fifo_relax", text: "          if (!inQ[v]) { q.add(v); inQ[v] = true; }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "import 'dart:collection';" },
        { key: "dijkstra_init", text: "List<double> d = List.filled(n, double.infinity);" },
        { key: "dijkstra_init", text: "List<int> parent = List.filled(n, -1);" },
        { key: "dijkstra_init", text: "d[s] = 0;" },
        { key: "dijkstra_init", text: "var pq = PriorityQueue<MapEntry<int, double>>((a, b) => a.value.compareTo(b.value));" },
        { key: "dijkstra_init", text: "pq.addEntry(MapEntry(s, 0));" },
        { key: "dijkstra_extract", text: "while (pq.isNotEmpty) {" },
        { key: "dijkstra_extract", text: "  var entry = pq.removeFirst(); int u = entry.key; double dist_u = entry.value;" },
        { key: "dijkstra_extract", text: "  if (dist_u > d[u]) continue;" },
        { key: "dijkstra_relax", text: "  for (var e in adj[u]) {" },
        { key: "dijkstra_relax", text: "      int v = e[0]; double w = e[1];" },
        { key: "dijkstra_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "dijkstra_relax", text: "          pq.addEntry(MapEntry(v, d[v]));" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "import 'dart:collection';" },
        { key: "prim_init", text: "List<double> key = List.filled(n, double.infinity);" },
        { key: "prim_init", text: "List<int> parent = List.filled(n, -1);" },
        { key: "prim_init", text: "List<bool> inMST = List.filled(n, false);" },
        { key: "prim_init", text: "key[s] = 0;" },
        { key: "prim_init", text: "var pq = PriorityQueue<MapEntry<int, double>>((a, b) => a.value.compareTo(b.value));" },
        { key: "prim_init", text: "pq.addEntry(MapEntry(s, 0));" },
        { key: "prim_extract", text: "while (pq.isNotEmpty) {" },
        { key: "prim_extract", text: "  var entry = pq.removeFirst(); int u = entry.key; double key_u = entry.value;" },
        { key: "prim_extract", text: "  if (inMST[u]) continue;" },
        { key: "prim_extract", text: "  inMST[u] = true;" },
        { key: "prim_relax", text: "  for (var e in adj[u]) {" },
        { key: "prim_relax", text: "      int v = e[0]; double w = e[1];" },
        { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
        { key: "prim_relax", text: "          pq.addEntry(MapEntry(v, key[v]));" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "import 'dart:collection';" },
        { key: "bfs_init", text: "List<int> d = List.filled(n, 999999);" },
        { key: "bfs_init", text: "List<int> parent = List.filled(n, -1);" },
        { key: "bfs_init", text: "List<bool> visited = List.filled(n, false);" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true; var q = Queue<int>(); q.add(s);" },
        { key: "bfs_pop", text: "while (q.isNotEmpty) {" },
        { key: "bfs_pop", text: "  int u = q.removeFirst();" },
        { key: "bfs_relax", text: "  for (int v in adj[u]) {" },
        { key: "bfs_relax", text: "      if (!visited[v]) {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.add(v);" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "List<bool> visited = List.filled(n, false);" },
        { key: "dfs_init", text: "List<int?> parent = List.filled(n, null);" },
        { key: "dfs_init", text: "void dfs(int u) {" },
        { key: "dfs_visit", text: "  visited[u] = true;" },
        { key: "dfs_relax", text: "  for (int v in adj[u]) {" },
        { key: "dfs_relax", text: "      if (!visited[v]) {" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    lua: {
      relaxation: [
        { key: "init", text: "local d = {}; local parent = {}" },
        { key: "init", text: "for i = 1, n do d[i] = math.huge; parent[i] = nil end" },
        { key: "init", text: "d[s] = 0" },
        { key: "relax_outer", text: "for _ = 1, n - 1 do" },
        { key: "relax", text: "  for _, edge in ipairs(edges) do" },
        { key: "relax", text: "      local u, v, w = edge[1], edge[2], edge[3]" },
        { key: "relax", text: "      if d[u] + w < d[v] then" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "relax", text: "      end" },
        { key: "relax", text: "  end" },
        { key: "relax_outer", text: "end" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "local d = {}; local parent = {}" },
        { key: "bf_init", text: "for i = 1, n do d[i] = math.huge; parent[i] = nil end" },
        { key: "bf_init", text: "d[s] = 0" },
        { key: "bf_outer", text: "for _ = 1, n - 1 do" },
        { key: "bf_relax", text: "  for _, edge in ipairs(edges) do" },
        { key: "bf_relax", text: "      local u, v, w = edge[1], edge[2], edge[3]" },
        { key: "bf_relax", text: "      if d[u] + w < d[v] then" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "bf_relax", text: "      end" },
        { key: "bf_relax", text: "  end" },
        { key: "bf_outer", text: "end" },
        { key: "bf_check", text: "for _, edge in ipairs(edges) do" },
        { key: "bf_neg_cycle", text: "  local u, v, w = edge[1], edge[2], edge[3]" },
        { key: "bf_neg_cycle", text: "  if d[u] + w < d[v] then print('negative cycle') end" },
        { key: "bf_check", text: "end" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "local d = {}; local parent = {}; local inQ = {}" },
        { key: "fifo_init", text: "for i = 1, n do d[i] = math.huge; parent[i] = nil; inQ[i] = false end" },
        { key: "fifo_init", text: "d[s] = 0; local q = {s}; inQ[s] = true" },
        { key: "fifo_pop", text: "while #q > 0 do" },
        { key: "fifo_pop", text: "  local u = table.remove(q, 1); inQ[u] = false" },
        { key: "fifo_relax", text: "  for _, edge in ipairs(adj[u]) do" },
        { key: "fifo_relax", text: "      local v, w = edge[1], edge[2]" },
        { key: "fifo_relax", text: "      if d[u] + w < d[v] then" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "fifo_relax", text: "          if not inQ[v] then table.insert(q, v); inQ[v] = true end" },
        { key: "fifo_relax", text: "      end" },
        { key: "fifo_relax", text: "  end" },
        { key: "fifo_pop", text: "end" },
      ],
      bfs: [
        { key: "bfs_init", text: "local d = {}; local parent = {}; local visited = {}" },
        { key: "bfs_init", text: "for i = 1, n do d[i] = math.huge; parent[i] = nil; visited[i] = false end" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true; local q = {s}" },
        { key: "bfs_pop", text: "while #q > 0 do" },
        { key: "bfs_pop", text: "  local u = table.remove(q, 1)" },
        { key: "bfs_relax", text: "  for _, v in ipairs(adj[u]) do" },
        { key: "bfs_relax", text: "      if not visited[v] then" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; table.insert(q, v)" },
        { key: "bfs_relax", text: "      end" },
        { key: "bfs_relax", text: "  end" },
        { key: "bfs_pop", text: "end" },
      ],
      prim: [
        { key: "prim_init", text: "local key = {}; local parent = {}; local in_mst = {}" },
        { key: "prim_init", text: "for i = 1, n do key[i] = math.huge; parent[i] = nil; in_mst[i] = false end" },
        { key: "prim_init", text: "key[s] = 0; local pq = {{0, s}}" },
        { key: "prim_extract", text: "while #pq > 0 do" },
        { key: "prim_extract", text: "  table.sort(pq, function(a, b) return a[1] < b[1] end)" },
        { key: "prim_extract", text: "  local key_u, u = table.remove(pq, 1)[1], table.remove(pq, 1)[2]" },
        { key: "prim_extract", text: "  if in_mst[u] then goto continue end" },
        { key: "prim_extract", text: "  in_mst[u] = true" },
        { key: "prim_relax", text: "  for _, edge in ipairs(adj[u]) do" },
        { key: "prim_relax", text: "      local v, w = edge[1], edge[2]" },
        { key: "prim_relax", text: "      if not in_mst[v] and w < key[v] then" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u; table.insert(pq, {key[v], v})" },
        { key: "prim_relax", text: "      end" },
        { key: "prim_relax", text: "  end" },
        { key: "prim_extract", text: "  ::continue::" },
        { key: "prim_extract", text: "end" },
        { key: "prim_done", text: "-- MST constructed" },
      ],
      dfs: [
        { key: "dfs_init", text: "local visited = {}; local parent = {}" },
        { key: "dfs_init", text: "for i = 1, n do visited[i] = false; parent[i] = nil end" },
        { key: "dfs_init", text: "local function dfs(u)" },
        { key: "dfs_visit", text: "  visited[u] = true" },
        { key: "dfs_relax", text: "  for _, v in ipairs(adj[u]) do" },
        { key: "dfs_relax", text: "      if not visited[v] then" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v)" },
        { key: "dfs_relax", text: "      end" },
        { key: "dfs_relax", text: "  end" },
        { key: "dfs_visit", text: "end" },
      ],
    },
    perl: {
      relaxation: [
        { key: "init", text: "my @d = (inf) x $n; my @parent = (undef) x $n;" },
        { key: "init", text: "$d[$s] = 0;" },
        { key: "relax_outer", text: "for my $i (0 .. $n - 2) {" },
        { key: "relax", text: "  for my $edge (@edges) {" },
        { key: "relax", text: "      my ($u, $v, $w) = @$edge;" },
        { key: "relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
        { key: "relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "my @d = (inf) x $n; my @parent = (undef) x $n;" },
        { key: "bf_init", text: "$d[$s] = 0;" },
        { key: "bf_outer", text: "for my $i (0 .. $n - 2) {" },
        { key: "bf_relax", text: "  for my $edge (@edges) {" },
        { key: "bf_relax", text: "      my ($u, $v, $w) = @$edge;" },
        { key: "bf_relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
        { key: "bf_relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for my $edge (@edges) {" },
        { key: "bf_neg_cycle", text: "  my ($u, $v, $w) = @$edge;" },
        { key: "bf_neg_cycle", text: "  if ($d[$u] + $w < $d[$v]) { print \"negative cycle\\n\" }" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "my @d = (inf) x $n; my @parent = (undef) x $n; my @inQ = (0) x $n;" },
        { key: "fifo_init", text: "$d[$s] = 0; my @q = ($s); $inQ[$s] = 1;" },
        { key: "fifo_pop", text: "while (@q) {" },
        { key: "fifo_pop", text: "  my $u = shift @q; $inQ[$u] = 0;" },
        { key: "fifo_relax", text: "  for my $edge (@{$adj[$u]}) {" },
        { key: "fifo_relax", text: "      my ($v, $w) = @$edge;" },
        { key: "fifo_relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
        { key: "fifo_relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
        { key: "fifo_relax", text: "          if (!$inQ[$v]) { push @q, $v; $inQ[$v] = 1 }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "use strict; use warnings;" },
        { key: "dijkstra_init", text: "my @d = (inf) x $n; my @parent = (-1) x $n;" },
        { key: "dijkstra_init", text: "$d[$s] = 0;" },
        { key: "dijkstra_init", text: "my @pq = ([0, $s]);" },
        { key: "dijkstra_extract", text: "while (@pq) {" },
        { key: "dijkstra_extract", text: "  @pq = sort { $a->[0] <=> $b->[0] } @pq;" },
        { key: "dijkstra_extract", text: "  my ($dist_u, $u) = @{shift @pq};" },
        { key: "dijkstra_extract", text: "  next if $dist_u > $d[$u];" },
        { key: "dijkstra_relax", text: "  for my $edge (@{$adj[$u]}) {" },
        { key: "dijkstra_relax", text: "      my ($v, $w) = @$edge;" },
        { key: "dijkstra_relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
        { key: "dijkstra_relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
        { key: "dijkstra_relax", text: "          push @pq, [$d[$v], $v];" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "use strict; use warnings;" },
        { key: "prim_init", text: "my @key = (inf) x $n; my @parent = (-1) x $n; my @in_mst = (0) x $n;" },
        { key: "prim_init", text: "$key[$s] = 0; my @pq = ([0, $s]);" },
        { key: "prim_extract", text: "while (@pq) {" },
        { key: "prim_extract", text: "  @pq = sort { $a->[0] <=> $b->[0] } @pq;" },
        { key: "prim_extract", text: "  my ($key_u, $u) = @{shift @pq};" },
        { key: "prim_extract", text: "  next if $in_mst[$u];" },
        { key: "prim_extract", text: "  $in_mst[$u] = 1;" },
        { key: "prim_relax", text: "  for my $edge (@{$adj[$u]}) {" },
        { key: "prim_relax", text: "      my ($v, $w) = @$edge;" },
        { key: "prim_relax", text: "      if (!$in_mst[$v] && $w < $key[$v]) {" },
        { key: "prim_relax", text: "          $key[$v] = $w; $parent[$v] = $u; push @pq, [$key[$v], $v];" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "# MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "use strict; use warnings;" },
        { key: "bfs_init", text: "my @d = (999999) x $n; my @parent = (-1) x $n; my @visited = (0) x $n;" },
        { key: "bfs_init", text: "$d[$s] = 0; $visited[$s] = 1; my @q = ($s);" },
        { key: "bfs_pop", text: "while (@q) {" },
        { key: "bfs_pop", text: "  my $u = shift @q;" },
        { key: "bfs_relax", text: "  for my $v (@{$adj[$u]}) {" },
        { key: "bfs_relax", text: "      if (!$visited[$v]) {" },
        { key: "bfs_relax", text: "          $visited[$v] = 1; $d[$v] = $d[$u] + 1; $parent[$v] = $u; push @q, $v;" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "my @visited = (0) x $n; my @parent = (-1) x $n;" },
        { key: "dfs_init", text: "sub dfs {" },
        { key: "dfs_init", text: "  my ($u) = @_;" },
        { key: "dfs_visit", text: "  $visited[$u] = 1;" },
        { key: "dfs_relax", text: "  for my $v (@{$adj[$u]}) {" },
        { key: "dfs_relax", text: "      if (!$visited[$v]) {" },
        { key: "dfs_relax", text: "          $parent[$v] = $u; dfs($v);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    r: {
      relaxation: [
        { key: "init", text: "d <- rep(Inf, n); parent <- rep(NA, n)" },
        { key: "init", text: "d[s] <- 0" },
        { key: "relax_outer", text: "for (i in 1:(n-1)) {" },
        { key: "relax", text: "  for (edge in edges) {" },
        { key: "relax", text: "      u <- edge[1]; v <- edge[2]; w <- edge[3]" },
        { key: "relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "relax", text: "          d[v] <- d[u] + w; parent[v] <- u" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "d <- rep(Inf, n); parent <- rep(NA, n)" },
        { key: "bf_init", text: "d[s] <- 0" },
        { key: "bf_outer", text: "for (i in 1:(n-1)) {" },
        { key: "bf_relax", text: "  for (edge in edges) {" },
        { key: "bf_relax", text: "      u <- edge[1]; v <- edge[2]; w <- edge[3]" },
        { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "          d[v] <- d[u] + w; parent[v] <- u" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for (edge in edges) {" },
        { key: "bf_neg_cycle", text: "  u <- edge[1]; v <- edge[2]; w <- edge[3]" },
        { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) cat(\"negative cycle\\n\")" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "d <- rep(Inf, n); parent <- rep(NA, n); inQ <- rep(FALSE, n)" },
        { key: "fifo_init", text: "d[s] <- 0; q <- c(s); inQ[s] <- TRUE" },
        { key: "fifo_pop", text: "while (length(q) > 0) {" },
        { key: "fifo_pop", text: "  u <- q[1]; q <- q[-1]; inQ[u] <- FALSE" },
        { key: "fifo_relax", text: "  for (edge in adj[[u]]) {" },
        { key: "fifo_relax", text: "      v <- edge[1]; w <- edge[2]" },
        { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "          d[v] <- d[u] + w; parent[v] <- u" },
        { key: "fifo_relax", text: "          if (!inQ[v]) { q <- c(q, v); inQ[v] <- TRUE }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "library(igraph)" },
        { key: "dijkstra_init", text: "d <- rep(Inf, n); parent <- rep(NA, n)" },
        { key: "dijkstra_init", text: "d[s] <- 0" },
        { key: "dijkstra_init", text: "pq <- data.frame(dist = 0, node = s)" },
        { key: "dijkstra_extract", text: "while (nrow(pq) > 0) {" },
        { key: "dijkstra_extract", text: "  pq <- pq[order(pq$dist), ]" },
        { key: "dijkstra_extract", text: "  dist_u <- pq$dist[1]; u <- pq$node[1]; pq <- pq[-1, ]" },
        { key: "dijkstra_extract", text: "  if (dist_u > d[u]) next" },
        { key: "dijkstra_relax", text: "  for (edge in adj[[u]]) {" },
        { key: "dijkstra_relax", text: "      v <- edge$v; w <- edge$w" },
        { key: "dijkstra_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] <- d[u] + w; parent[v] <- u" },
        { key: "dijkstra_relax", text: "          pq <- rbind(pq, data.frame(dist = d[v], node = v))" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "key <- rep(Inf, n); parent <- rep(NA, n); inMST <- rep(FALSE, n)" },
        { key: "prim_init", text: "key[s] <- 0" },
        { key: "prim_init", text: "pq <- data.frame(key = 0, node = s)" },
        { key: "prim_extract", text: "while (nrow(pq) > 0) {" },
        { key: "prim_extract", text: "  pq <- pq[order(pq$key), ]" },
        { key: "prim_extract", text: "  key_u <- pq$key[1]; u <- pq$node[1]; pq <- pq[-1, ]" },
        { key: "prim_extract", text: "  if (inMST[u]) next" },
        { key: "prim_extract", text: "  inMST[u] <- TRUE" },
        { key: "prim_relax", text: "  for (edge in adj[[u]]) {" },
        { key: "prim_relax", text: "      v <- edge$v; w <- edge$w" },
        { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
        { key: "prim_relax", text: "          key[v] <- w; parent[v] <- u" },
        { key: "prim_relax", text: "          pq <- rbind(pq, data.frame(key = key[v], node = v))" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "# MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "library(igraph)" },
        { key: "bfs_init", text: "d <- rep(Inf, n); parent <- rep(NA, n); visited <- rep(FALSE, n)" },
        { key: "bfs_init", text: "d[s] <- 0; visited[s] <- TRUE; q <- c(s)" },
        { key: "bfs_pop", text: "while (length(q) > 0) {" },
        { key: "bfs_pop", text: "  u <- q[1]; q <- q[-1]" },
        { key: "bfs_relax", text: "  for (v in adj[[u]]) {" },
        { key: "bfs_relax", text: "      if (!visited[v]) {" },
        { key: "bfs_relax", text: "          visited[v] <- TRUE; d[v] <- d[u] + 1; parent[v] <- u; q <- c(q, v)" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "visited <- rep(FALSE, n); parent <- rep(NA, n)" },
        { key: "dfs_init", text: "dfs <- function(u) {" },
        { key: "dfs_visit", text: "  visited[u] <<- TRUE" },
        { key: "dfs_relax", text: "  for (v in adj[[u]]) {" },
        { key: "dfs_relax", text: "      if (!visited[v]) {" },
        { key: "dfs_relax", text: "          parent[v] <<- u; dfs(v)" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    matlab: {
      relaxation: [
        { key: "init", text: "d = inf(1, n); parent = zeros(1, n);" },
        { key: "init", text: "d(s) = 0;" },
        { key: "relax_outer", text: "for i = 1:n-1" },
        { key: "relax", text: "  for e = 1:size(edges, 1)" },
        { key: "relax", text: "      u = edges(e, 1); v = edges(e, 2); w = edges(e, 3);" },
        { key: "relax", text: "      if d(u) + w < d(v)" },
        { key: "relax", text: "          d(v) = d(u) + w; parent(v) = u;" },
        { key: "relax", text: "      end" },
        { key: "relax", text: "  end" },
        { key: "relax_outer", text: "end" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "d = inf(1, n); parent = zeros(1, n);" },
        { key: "bf_init", text: "d(s) = 0;" },
        { key: "bf_outer", text: "for i = 1:n-1" },
        { key: "bf_relax", text: "  for e = 1:size(edges, 1)" },
        { key: "bf_relax", text: "      u = edges(e, 1); v = edges(e, 2); w = edges(e, 3);" },
        { key: "bf_relax", text: "      if d(u) + w < d(v)" },
        { key: "bf_relax", text: "          d(v) = d(u) + w; parent(v) = u;" },
        { key: "bf_relax", text: "      end" },
        { key: "bf_relax", text: "  end" },
        { key: "bf_outer", text: "end" },
        { key: "bf_check", text: "for e = 1:size(edges, 1)" },
        { key: "bf_neg_cycle", text: "  u = edges(e, 1); v = edges(e, 2); w = edges(e, 3);" },
        { key: "bf_neg_cycle", text: "  if d(u) + w < d(v), fprintf('negative cycle\\n'); end" },
        { key: "bf_check", text: "end" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "d = inf(1, n); parent = zeros(1, n); inQ = false(1, n);" },
        { key: "fifo_init", text: "d(s) = 0; q = [s]; inQ(s) = true;" },
        { key: "fifo_pop", text: "while ~isempty(q)" },
        { key: "fifo_pop", text: "  u = q(1); q = q(2:end); inQ(u) = false;" },
        { key: "fifo_relax", text: "  for e = 1:size(adj{u}, 1)" },
        { key: "fifo_relax", text: "      v = adj{u}(e, 1); w = adj{u}(e, 2);" },
        { key: "fifo_relax", text: "      if d(u) + w < d(v)" },
        { key: "fifo_relax", text: "          d(v) = d(u) + w; parent(v) = u;" },
        { key: "fifo_relax", text: "          if ~inQ(v), q = [q, v]; inQ(v) = true; end" },
        { key: "fifo_relax", text: "      end" },
        { key: "fifo_relax", text: "  end" },
        { key: "fifo_pop", text: "end" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "d = inf(1, n); parent = zeros(1, n);" },
        { key: "dijkstra_init", text: "d(s) = 0;" },
        { key: "dijkstra_init", text: "pq = [0, s];" },
        { key: "dijkstra_extract", text: "while ~isempty(pq)" },
        { key: "dijkstra_extract", text: "  [~, idx] = min(pq(:, 1)); dist_u = pq(idx, 1); u = pq(idx, 2);" },
        { key: "dijkstra_extract", text: "  pq(idx, :) = [];" },
        { key: "dijkstra_extract", text: "  if dist_u > d(u), continue, end" },
        { key: "dijkstra_relax", text: "  for edge = adj{u}" },
        { key: "dijkstra_relax", text: "      v = edge(1); w = edge(2);" },
        { key: "dijkstra_relax", text: "      if d(u) + w < d(v)" },
        { key: "dijkstra_relax", text: "          d(v) = d(u) + w; parent(v) = u;" },
        { key: "dijkstra_relax", text: "          pq = [pq; d(v), v];" },
        { key: "dijkstra_relax", text: "      end" },
        { key: "dijkstra_relax", text: "  end" },
        { key: "dijkstra_extract", text: "end" },
      ],
      prim: [
        { key: "prim_init", text: "key = inf(1, n); parent = zeros(1, n); inMST = false(1, n);" },
        { key: "prim_init", text: "key(s) = 0; pq = [0, s];" },
        { key: "prim_extract", text: "while ~isempty(pq)" },
        { key: "prim_extract", text: "  [~, idx] = min(pq(:, 1)); key_u = pq(idx, 1); u = pq(idx, 2);" },
        { key: "prim_extract", text: "  pq(idx, :) = [];" },
        { key: "prim_extract", text: "  if inMST(u), continue, end" },
        { key: "prim_extract", text: "  inMST(u) = true;" },
        { key: "prim_relax", text: "  for edge = adj{u}" },
        { key: "prim_relax", text: "      v = edge(1); w = edge(2);" },
        { key: "prim_relax", text: "      if ~inMST(v) && w < key(v)" },
        { key: "prim_relax", text: "          key(v) = w; parent(v) = u;" },
        { key: "prim_relax", text: "          pq = [pq; key(v), v];" },
        { key: "prim_relax", text: "      end" },
        { key: "prim_relax", text: "  end" },
        { key: "prim_extract", text: "end" },
        { key: "prim_done", text: "% MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "d = inf(1, n); parent = zeros(1, n); visited = false(1, n);" },
        { key: "bfs_init", text: "d(s) = 0; visited(s) = true; q = [s];" },
        { key: "bfs_pop", text: "while ~isempty(q)" },
        { key: "bfs_pop", text: "  u = q(1); q = q(2:end);" },
        { key: "bfs_relax", text: "  for v = adj{u}" },
        { key: "bfs_relax", text: "      if ~visited(v)" },
        { key: "bfs_relax", text: "          visited(v) = true; d(v) = d(u) + 1; parent(v) = u; q = [q, v];" },
        { key: "bfs_relax", text: "      end" },
        { key: "bfs_relax", text: "  end" },
        { key: "bfs_pop", text: "end" },
      ],
      dfs: [
        { key: "dfs_init", text: "visited = false(1, n); parent = zeros(1, n);" },
        { key: "dfs_init", text: "function dfs(u)" },
        { key: "dfs_visit", text: "  visited(u) = true;" },
        { key: "dfs_relax", text: "  for v = adj{u}" },
        { key: "dfs_relax", text: "      if ~visited(v)" },
        { key: "dfs_relax", text: "          parent(v) = u; dfs(v);" },
        { key: "dfs_relax", text: "      end" },
        { key: "dfs_relax", text: "  end" },
        { key: "dfs_visit", text: "end" },
      ],
    },
    julia: {
      relaxation: [
        { key: "init", text: "d = fill(Inf, n); parent = fill(nothing, n)" },
        { key: "init", text: "d[s] = 0" },
        { key: "relax_outer", text: "for _ in 1:n-1" },
        { key: "relax", text: "  for (u, v, w) in edges" },
        { key: "relax", text: "      if d[u] + w < d[v]" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "relax", text: "      end" },
        { key: "relax", text: "  end" },
        { key: "relax_outer", text: "end" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "d = fill(Inf, n); parent = fill(nothing, n)" },
        { key: "bf_init", text: "d[s] = 0" },
        { key: "bf_outer", text: "for _ in 1:n-1" },
        { key: "bf_relax", text: "  for (u, v, w) in edges" },
        { key: "bf_relax", text: "      if d[u] + w < d[v]" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "bf_relax", text: "      end" },
        { key: "bf_relax", text: "  end" },
        { key: "bf_outer", text: "end" },
        { key: "bf_check", text: "for (u, v, w) in edges" },
        { key: "bf_neg_cycle", text: "  if d[u] + w < d[v] println(\"negative cycle\") end" },
        { key: "bf_check", text: "end" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "d = fill(Inf, n); parent = fill(nothing, n); inQ = fill(false, n)" },
        { key: "fifo_init", text: "d[s] = 0; q = [s]; inQ[s] = true" },
        { key: "fifo_pop", text: "while !isempty(q)" },
        { key: "fifo_pop", text: "  u = popfirst!(q); inQ[u] = false" },
        { key: "fifo_relax", text: "  for (v, w) in adj[u]" },
        { key: "fifo_relax", text: "      if d[u] + w < d[v]" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "fifo_relax", text: "          if !inQ[v] push!(q, v); inQ[v] = true end" },
        { key: "fifo_relax", text: "      end" },
        { key: "fifo_relax", text: "  end" },
        { key: "fifo_pop", text: "end" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "using DataStructures" },
        { key: "dijkstra_init", text: "d = fill(Inf, n); parent = fill(nothing, n); visited = falses(n)" },
        { key: "dijkstra_init", text: "d[s] = 0" },
        { key: "dijkstra_init", text: "pq = PriorityQueue(Base.Order.Forward, [(d[s], s)])" },
        { key: "dijkstra_extract", text: "while !isempty(pq)" },
        { key: "dijkstra_extract", text: "  (dist_u, u) = dequeue!(pq)" },
        { key: "dijkstra_extract", text: "  visited[u] && continue" },
        { key: "dijkstra_extract", text: "  visited[u] = true" },
        { key: "dijkstra_relax", text: "  for (v, w) in adj[u]" },
        { key: "dijkstra_relax", text: "      visited[v] && continue" },
        { key: "dijkstra_relax", text: "      if d[u] + w < d[v]" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "dijkstra_relax", text: "          enqueue!(pq, d[v], v)" },
        { key: "dijkstra_relax", text: "      end" },
        { key: "dijkstra_relax", text: "  end" },
        { key: "dijkstra_extract", text: "end" },
      ],
      prim: [
        { key: "prim_init", text: "using DataStructures" },
        { key: "prim_init", text: "key = fill(Inf, n); parent = fill(nothing, n); inMST = falses(n)" },
        { key: "prim_init", text: "key[s] = 0" },
        { key: "prim_init", text: "pq = PriorityQueue(Base.Order.Forward, [(key[s], s)])" },
        { key: "prim_extract", text: "while !isempty(pq)" },
        { key: "prim_extract", text: "  (key_u, u) = dequeue!(pq)" },
        { key: "prim_extract", text: "  inMST[u] && continue" },
        { key: "prim_extract", text: "  inMST[u] = true" },
        { key: "prim_relax", text: "  for (v, w) in adj[u]" },
        { key: "prim_relax", text: "      inMST[v] && continue" },
        { key: "prim_relax", text: "      if w < key[v]" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u" },
        { key: "prim_relax", text: "          enqueue!(pq, key[v], v)" },
        { key: "prim_relax", text: "      end" },
        { key: "prim_relax", text: "  end" },
        { key: "prim_extract", text: "end" },
        { key: "prim_done", text: "# MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "using DataStructures" },
        { key: "bfs_init", text: "d = fill(Inf, n); parent = fill(nothing, n); visited = falses(n)" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true; q = Queue{Int}(); enqueue!(q, s)" },
        { key: "bfs_pop", text: "while !isempty(q)" },
        { key: "bfs_pop", text: "  u = dequeue!(q)" },
        { key: "bfs_relax", text: "  for v in adj[u]" },
        { key: "bfs_relax", text: "      if !visited[v]" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; enqueue!(q, v)" },
        { key: "bfs_relax", text: "      end" },
        { key: "bfs_relax", text: "  end" },
        { key: "bfs_pop", text: "end" },
      ],
      dfs: [
        { key: "dfs_init", text: "visited = falses(n); parent = fill(nothing, n)" },
        { key: "dfs_init", text: "function dfs(u)" },
        { key: "dfs_visit", text: "  visited[u] = true" },
        { key: "dfs_relax", text: "  for v in adj[u]" },
        { key: "dfs_relax", text: "      if !visited[v]" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v)" },
        { key: "dfs_relax", text: "      end" },
        { key: "dfs_relax", text: "  end" },
        { key: "dfs_visit", text: "end" },
      ],
    },
  };
