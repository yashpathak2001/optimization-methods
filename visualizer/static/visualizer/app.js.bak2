// Optimization Methods Visualizer
// Frontend logic: graph builder + algorithms + stepper + code highlighting

// --- Imports -------------------------------------------------------------
import { idToLabel, nodeBaseColor, formatDist, escapeHtml } from './utils/helpers.js';
import { createGraphStateManager } from './graph/state.js';
import {
  createRelaxationSteps,
  createBellmanFordSteps,
  createDijkstraSteps,
  createPrimSteps,
  createBFSSteps,
  createDFSSteps
} from './algorithms/index.js';
import { PSEUDO_TEMPLATES } from './pseudo-code/pseudo.js';
import { CODE_TEMPLATES } from './code-templates/templates.js';
import { ALGORITHM_INFO } from './algorithm-info/info.js';

// --- DOM helpers ---------------------------------------------------------
const $ = (id) => document.getElementById(id);

window.addEventListener("DOMContentLoaded", () => {
  const algorithmSelect = $("algorithm-select");
  const startNodeSelect = $("start-node-select");
  const speedRange = $("speed-range");
  const languageSelect = $("language-select");
  const pseudoPanel = $("pseudo-panel");
  const codePanel = $("code-panel");
  const defaultGraphSelect = $("default-graph-select");

  const btnAddNode = $("btn-add-node");
  const btnRemoveNode = $("btn-remove-node");
  const btnAddEdge = $("btn-add-edge");
  const btnResetGraph = $("btn-reset-graph");
  const btnRunAuto = $("btn-run-auto");
  const btnPrev = $("btn-prev");
  const btnNext = $("btn-next");
  const btnRestart = $("btn-restart");
  const btnCenterGraph = $("btn-center-graph");
  const btnCenterParent = $("btn-center-parent");

  const nodeLabelInput = $("node-label");
  const edgeFromInput = $("edge-from");
  const edgeToInput = $("edge-to");
  const edgeWeightInput = $("edge-weight");
  const chkDirected = $("chk-directed");
  const chkPhysics = $("chk-physics");

  const graphCanvas = $("graph-canvas");
  const parentCanvas = $("parent-canvas");
  const stepIndexLabel = $("step-index");
  const stepTotalLabel = $("step-total");
  const stepDescription = $("step-description");
  const distanceList = $("distance-list");
  const statusLabel = $("status-label");
  const speedValueLabel = $("speed-value");
  const timeBigOEl = $("time-big-o");
  const spaceBigOEl = $("space-big-o");
  const timeProgressEl = $("time-progress");
  const spaceProgressEl = $("space-progress");
  const variableListEl = $("variable-list");
  
  // New feature DOM elements
  const btnAlgorithmInfo = $("btn-algorithm-info");
  const btnHelp = $("btn-help");
  const btnExport = $("btn-export");
  const btnImport = $("btn-import");
  const btnCompare = $("btn-compare");
  const btnPause = $("btn-pause");
  const btnJump = $("btn-jump");
  const stepJumpInput = $("step-jump-input");
  const chkLabels = $("chk-labels");
  const importFileInput = $("import-file-input");
  
  const algorithmInfoPanel = $("algorithm-info-panel");
  const graphStatsPanel = $("graph-stats-panel");
  const pathReconstructionPanel = $("path-reconstruction-panel");
  const algorithmStatsPanel = $("algorithm-stats-panel");
  const performancePanel = $("performance-panel");
  const comparisonModal = $("comparison-modal");
  const tutorialModal = $("tutorial-modal");
  const pathTargetSelect = $("path-target-select");
  const pathDisplay = $("path-display");
  const pathVisual = $("path-visual");
  
  let labelsVisible = true;
  let isPaused = false;
  let comparisonMode = false;

  // --- Graph state manager -----------------------------------------------
  const graphStateManager = createGraphStateManager(nodeData, edgeData);
  const computeGraphFromState = graphStateManager.computeGraphFromState;

  // --- Graph state & vis-network setup -----------------------------------
  const nodeData = new vis.DataSet([]);
  const edgeData = new vis.DataSet([]);

  const physicsOptions = {
    enabled: true,
    solver: "forceAtlas2Based",
    forceAtlas2Based: {
      springLength: 110,
      gravitationalConstant: -55,
      centralGravity: 0.02,
      springConstant: 0.045,
    },
    stabilization: {
      iterations: 120,
      updateInterval: 20,
    },
  };

  const graphNetwork = new vis.Network(
    graphCanvas,
    { nodes: nodeData, edges: edgeData },
    {
      interaction: {
        hover: true,
        dragNodes: true,
        zoomView: true,
      },
      physics: physicsOptions,
      nodes: {
        shape: "dot",
        size: 22,
        font: { color: "#e5e7eb", size: 16 },
        borderWidth: 1,
      },
      edges: {
        arrows: { to: { enabled: true, scaleFactor: 0.8 } },
        smooth: { type: "dynamic" },
        font: { color: "#e5e7eb", size: 12, background: "rgba(15,23,42,0.85)" },
        width: 1.5,
      },
    }
  );

  const parentNetwork = new vis.Network(
    parentCanvas,
    { nodes: new vis.DataSet([]), edges: new vis.DataSet([]) },
    {
      interaction: {
        dragNodes: false,
        zoomView: true,
        selectable: false,
      },
      physics: {
        enabled: false,
      },
      layout: {
        hierarchical: {
          enabled: true,
          direction: "UD",
          sortMethod: "directed",
          nodeSpacing: 250,
          levelSeparation: 200,
          treeSpacing: 300,
          parentCentralization: true,
          shakeTowards: "leaves",
        },
      },
      nodes: {
        shape: "circle",
        size: 35,
        font: {
          color: "#e5e7eb",
          size: 16,
          face: "Arial",
          align: "right",
          vadjust: 0,
        },
        borderWidth: 2,
        margin: 12,
      },
      edges: {
        arrows: { to: { enabled: true, scaleFactor: 0.7 } },
        smooth: false,
        font: {
          size: 16,
          color: "#ffffff",
          strokeWidth: 0,
          align: "horizontal",
          vadjust: -10,
        },
        width: 2,
        labelHighlightBold: false,
      },
    }
  );

  if (btnCenterGraph) {
    btnCenterGraph.addEventListener("click", () => {
      const nodes = nodeData.get();
      if (!nodes.length) return;
      graphNetwork.fit({
        animation: {
          duration: 300,
          easingFunction: "easeInOutQuad",
        },
        padding: 80,
      });
    });
  }

  if (btnCenterParent) {
    btnCenterParent.addEventListener("click", () => {
      const parentNodes = parentNetwork.body.data.nodes.get();
      if (!parentNodes.length) return;
      parentNetwork.fit({
        animation: {
          duration: 300,
          easingFunction: "easeInOutQuad",
        },
        padding: 80,
      });
    });
  }

  // Zoom controls for parent network
  const btnZoomInParent = $("btn-zoom-in-parent");
  const btnZoomOutParent = $("btn-zoom-out-parent");
  
  if (btnZoomInParent) {
    btnZoomInParent.addEventListener("click", () => {
      const scale = parentNetwork.getScale();
      parentNetwork.moveTo({
        scale: Math.min(scale * 1.2, 5),
        animation: {
          duration: 200,
          easingFunction: "easeInOutQuad",
        },
      });
    });
  }

  if (btnZoomOutParent) {
    btnZoomOutParent.addEventListener("click", () => {
      const scale = parentNetwork.getScale();
      parentNetwork.moveTo({
        scale: Math.max(scale * 0.8, 0.1),
        animation: {
          duration: 200,
          easingFunction: "easeInOutQuad",
        },
      });
    });
  }

  // Zoom controls for graph network
  const btnZoomInGraph = $("btn-zoom-in-graph");
  const btnZoomOutGraph = $("btn-zoom-out-graph");
  
  if (btnZoomInGraph) {
    btnZoomInGraph.addEventListener("click", () => {
      const scale = graphNetwork.getScale();
      graphNetwork.moveTo({
        scale: Math.min(scale * 1.2, 5),
        animation: {
          duration: 200,
          easingFunction: "easeInOutQuad",
        },
      });
    });
  }

  if (btnZoomOutGraph) {
    btnZoomOutGraph.addEventListener("click", () => {
      const scale = graphNetwork.getScale();
      graphNetwork.moveTo({
        scale: Math.max(scale * 0.8, 0.1),
        animation: {
          duration: 200,
          easingFunction: "easeInOutQuad",
        },
      });
    });
  }

  chkPhysics.addEventListener("change", () => {
    graphNetwork.setOptions({
      physics: { ...physicsOptions, enabled: chkPhysics.checked },
    });
  });

  // --- Graph builder logic -----------------------------------------------
  let nextNodeId = 0;

  function refreshStartNodeOptions() {
    const nodes = nodeData.get();
    startNodeSelect.innerHTML = "";
    if (!nodes.length) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "No nodes in the graph";
      opt.disabled = true;
      opt.selected = true;
      startNodeSelect.appendChild(opt);
      startNodeSelect.disabled = true;
      updateStepControls();
      return;
    }
    startNodeSelect.disabled = false;
    for (const n of nodes) {
      const displayLabel = n.label || idToLabel(n.id);
      const opt = document.createElement("option");
      opt.value = String(n.id);
      opt.textContent = displayLabel;
      startNodeSelect.appendChild(opt);
    }
    updateStepControls();
  }

  function addNode() {
    const id = nextNodeId++;
    const customLabel =
      (nodeLabelInput && nodeLabelInput.value.trim()) || idToLabel(id);
    nodeData.add({
      id,
      label: customLabel,
      color: {
        background: "rgba(15,23,42,0.9)",
        border: nodeBaseColor(id),
        highlight: {
          background: nodeBaseColor(id),
          border: nodeBaseColor(id),
        },
      },
    });
    if (nodeLabelInput) {
      nodeLabelInput.value = "";
    }
    refreshStartNodeOptions();
  }

  function removeNode() {
    const all = nodeData.get();
    if (!all.length) return;
    const last = all[all.length - 1];
    nodeData.remove(last.id);
    const toRemove = edgeData
      .get()
      .filter((e) => e.from === last.id || e.to === last.id)
      .map((e) => e.id);
    edgeData.remove(toRemove);
    refreshStartNodeOptions();
  }

  function addEdgeManual() {
    const from = parseInt(edgeFromInput.value, 10);
    const to = parseInt(edgeToInput.value, 10);
    const w = parseFloat(edgeWeightInput.value);
    if (Number.isNaN(from) || Number.isNaN(to) || Number.isNaN(w)) {
      flashStatus("Enter valid from/to/weight for edge.", true);
      return;
    }
    if (!nodeData.get(from) || !nodeData.get(to)) {
      flashStatus("Both endpoints must exist as nodes.", true);
      return;
    }
    const directed = chkDirected.checked;
    const id = `${from}-${to}-${Date.now()}`;
    edgeData.add({
      id,
      from,
      to,
      arrows: directed ? "to" : "",
      label: String(w),
      weight: w,
    });
    if (!directed && from !== to) {
      const id2 = `${to}-${from}-${Date.now()}-r`;
      edgeData.add({
        id: id2,
        from: to,
        to: from,
        arrows: "",
        label: String(w),
        weight: w,
      });
    }
    edgeFromInput.value = "";
    edgeToInput.value = "";
    edgeWeightInput.value = "";
  }

  function resetGraph() {
    nodeData.clear();
    edgeData.clear();
    parentNetwork.body.data.nodes.clear();
    parentNetwork.body.data.edges.clear();
    nextNodeId = 0;
    defaultGraphSelect.value = "";
    refreshStartNodeOptions();
    clearSteps();
    updateDistancesDisplay({});
    flashStatus("Graph reset. Build a new graph or choose a preset.");
  }

  btnAddNode.addEventListener("click", addNode);
  btnRemoveNode.addEventListener("click", removeNode);
  btnAddEdge.addEventListener("click", addEdgeManual);
  btnResetGraph.addEventListener("click", resetGraph);

  // Default graphs
  function loadDefaultGraph(kind) {
    resetGraph();
    if (!kind) return;

    if (kind === "simple") {
      for (let i = 0; i < 5; i++) addNode();
      const edges = [
        [0, 1, 4],
        [0, 2, 2],
        [1, 2, 1],
        [1, 3, 5],
        [2, 3, 8],
        [2, 4, 10],
        [3, 4, 2],
      ];
      for (const [f, t, w] of edges) {
        edgeData.add({
          id: `${f}-${t}`,
          from: f,
          to: t,
          arrows: "to",
          label: String(w),
          weight: w,
        });
      }
      flashStatus("Loaded simple demo graph.");
    } else if (kind === "neg-cycle") {
      for (let i = 0; i < 4; i++) addNode();
      const edges = [
        [0, 1, 1],
        [1, 2, -1],
        [2, 3, -1],
        [3, 1, -1],
        [0, 3, 4],
      ];
      for (const [f, t, w] of edges) {
        edgeData.add({
          id: `${f}-${t}`,
          from: f,
          to: t,
          arrows: "to",
          label: String(w),
          weight: w,
        });
      }
      flashStatus("Loaded negative cycle example (Bellman-Ford will detect).");
    } else if (kind === "grid") {
      const rows = 2;
      const cols = 4;
      const ids = [];
      for (let r = 0; r < rows; r++) {
        ids[r] = [];
        for (let c = 0; c < cols; c++) {
          const id = nextNodeId++;
          nodeData.add({
            id,
            label: idToLabel(id),
            color: {
              background: "rgba(15,23,42,0.9)",
              border: nodeBaseColor(id),
            },
          });
          ids[r][c] = id;
        }
      }
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (c + 1 < cols) {
            edgeData.add({
              id: `${ids[r][c]}-${ids[r][c + 1]}`,
              from: ids[r][c],
              to: ids[r][c + 1],
              arrows: "to",
              label: "1",
              weight: 1,
            });
          }
          if (r + 1 < rows) {
            edgeData.add({
              id: `${ids[r][c]}-${ids[r + 1][c]}`,
              from: ids[r][c],
              to: ids[r + 1][c],
              arrows: "to",
              label: "2",
              weight: 2,
            });
          }
        }
      }
      refreshStartNodeOptions();
      flashStatus("Loaded grid-like graph.");
    } else if (kind === "tree-unweighted") {
      // A simple rooted tree with unit weights
      for (let i = 0; i < 7; i++) addNode();
      const edges = [
        [0, 1],
        [0, 2],
        [1, 3],
        [1, 4],
        [2, 5],
        [2, 6],
      ];
      for (const [f, t] of edges) {
        edgeData.add({
          id: `${f}-${t}`,
          from: f,
          to: t,
          arrows: "to",
          label: "1",
          weight: 1,
        });
      }
      flashStatus("Loaded unweighted tree.");
    } else if (kind === "tree-weighted") {
      // Same tree with varying positive weights
      for (let i = 0; i < 7; i++) addNode();
      const edges = [
        [0, 1, 2],
        [0, 2, 5],
        [1, 3, 1],
        [1, 4, 3],
        [2, 5, 4],
        [2, 6, 2],
      ];
      for (const [f, t, w] of edges) {
        edgeData.add({
          id: `${f}-${t}`,
          from: f,
          to: t,
          arrows: "to",
          label: String(w),
          weight: w,
        });
      }
      flashStatus("Loaded weighted tree.");
    } else if (kind === "complete-unweighted") {
      // Complete graph on 5 nodes with unit weights
      const n = 5;
      for (let i = 0; i < n; i++) addNode();
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          if (i === j) continue;
          edgeData.add({
            id: `${i}-${j}`,
            from: i,
            to: j,
            arrows: "to",
            label: "1",
            weight: 1,
          });
        }
      }
      flashStatus("Loaded unweighted complete graph (5 nodes).");
    } else if (kind === "complete-weighted") {
      // Complete graph on 5 nodes with random positive weights
      const n = 5;
      for (let i = 0; i < n; i++) addNode();
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          if (i === j) continue;
          const w = Math.floor(Math.random() * 9) + 1; // 1..9
          edgeData.add({
            id: `${i}-${j}`,
            from: i,
            to: j,
            arrows: "to",
            label: String(w),
            weight: w,
          });
        }
      }
      flashStatus("Loaded weighted complete graph (5 nodes).");
    }
    refreshStartNodeOptions();
  }

  defaultGraphSelect.addEventListener("change", () => {
    loadDefaultGraph(defaultGraphSelect.value);
  });

  // --- Algorithm step model ----------------------------------------------
  let steps = [];
  let currentStepIndex = 0;
  let autoPlayTimer = null;

  function clearSteps() {
    steps = [];
    currentStepIndex = 0;
    stepIndexLabel.textContent = "0";
    stepTotalLabel.textContent = "0";
    stepDescription.textContent =
      "Build a graph and press \"Auto Play\" or use \"Next\".";
    updateAlgorithmTable(new Map(), new Map());
    stopAutoPlay();
    updateStepControls();
    updateComplexityPanel(null);
    updateVariablePanel(null);
    // Reset new panels
    if (pathDisplay) pathDisplay.textContent = "";
    if (pathVisual) pathVisual.innerHTML = "";
    if (pathTargetSelect) pathTargetSelect.innerHTML = '<option value="">Select target...</option>';
    updateAlgorithmStatistics(null);
    updatePerformanceMetrics(null);
    updateGraphStatistics();
  }

  function stopAutoPlay() {
    if (autoPlayTimer) {
      clearInterval(autoPlayTimer);
      autoPlayTimer = null;
    }
  }

  // computeGraphFromState is now imported from graph/state.js

  // Algorithm functions are now imported from algorithms/
  // Keeping this comment for reference - actual implementations moved to algorithms/relaxation.js
  function createRelaxationSteps_OLD(source, variant) {
    const { nodes, edges } = computeGraphFromState();
    const dist = new Map();
    const parent = new Map();
    for (const n of nodes) {
      dist.set(n.id, Infinity);
      parent.set(n.id, null);
    }
    dist.set(source, 0);

    const flatEdges = edges.map((e) => ({
      from: e.from,
      to: e.to,
      w: e.weight ?? parseFloat(e.label),
      id: e.id,
    }));
    const totalPasses =
      variant === "relaxation" ? nodes.length - 1 : nodes.length * 2;
    const out = [];

    out.push({
      label: "Initialization",
      description: `Initialize all distances to ∞ except source ${idToLabel(
        source
      )}, which is 0.`,
      dist: new Map(dist),
      parent: new Map(parent),
      highlightEdge: null,
      highlightNode: source,
      codeKey: "init",
    });

    for (let i = 0; i < totalPasses; i++) {
      for (const e of flatEdges) {
        const { from, to, w } = e;
        const old = dist.get(to);
        const cand = dist.get(from) + w;
        const willRelax = cand < old;

        const step = {
          label: `Relax edge (${idToLabel(from)} → ${idToLabel(to)})`,
          description: willRelax
            ? `Relaxing edge ${idToLabel(
                from
              )}→${idToLabel(to)}: updating d[${idToLabel(
                to
              )}] from ${formatDist(old)} to ${formatDist(cand)}.`
            : `Checking edge ${idToLabel(
                from
              )}→${idToLabel(
                to
              )}: no update since current distance is better.`,
          dist: new Map(dist),
          parent: new Map(parent),
          highlightEdge: e.id,
          highlightNode: to,
          codeKey: "relax",
          relaxedNode: willRelax ? to : null,
          u: from,
          v: to,
          w: w,
        };

        if (willRelax) {
          dist.set(to, cand);
          parent.set(to, from);
          step.dist = new Map(dist);
          step.parent = new Map(parent);
        }
        out.push(step);
      }
    }
    return out;
  }

  function createBellmanFordSteps(source, useFIFO) {
    const { nodes, edges } = computeGraphFromState();
    const dist = new Map();
    const parent = new Map();
    for (const n of nodes) {
      dist.set(n.id, Infinity);
      parent.set(n.id, null);
    }
    dist.set(source, 0);

    const flatEdges = edges.map((e) => ({
      from: e.from,
      to: e.to,
      w: e.weight ?? parseFloat(e.label),
      id: e.id,
    }));

    const out = [];
    out.push({
      label: "Initialization",
      description:
        "Initialize distances and parents. Bellman-Ford can handle negative weights.",
      dist: new Map(dist),
      parent: new Map(parent),
      highlightEdge: null,
      highlightNode: source,
      codeKey: "bf_init",
    });

    if (!useFIFO) {
      const n = nodes.length;
      for (let i = 1; i <= n - 1; i++) {
        out.push({
          label: `Pass ${i}`,
          description: `Outer loop iteration ${i}/${n - 1}. Relax all edges.`,
          dist: new Map(dist),
          parent: new Map(parent),
          highlightEdge: null,
          highlightNode: null,
          codeKey: "bf_outer",
          iteration: i,
        });
        for (const e of flatEdges) {
          const old = dist.get(e.to);
          const cand = dist.get(e.from) + e.w;
          const willRelax = cand < old;
          const step = {
            label: `Relax edge (${idToLabel(e.from)} → ${idToLabel(e.to)})`,
            description: willRelax
              ? `Relaxing edge ${idToLabel(
                  e.from
                )}→${idToLabel(e.to)}: updating d[${idToLabel(
                  e.to
                )}] from ${formatDist(old)} to ${formatDist(cand)}.`
              : `Checking edge ${idToLabel(
                  e.from
                )}→${idToLabel(e.to)}: no update.`,
            dist: new Map(dist),
            parent: new Map(parent),
            highlightEdge: e.id,
            highlightNode: e.to,
            codeKey: "bf_relax",
            relaxedNode: willRelax ? e.to : null,
            u: e.from,
            v: e.to,
            w: e.w,
          };
          if (willRelax) {
            dist.set(e.to, cand);
            parent.set(e.to, e.from);
            step.dist = new Map(dist);
            step.parent = new Map(parent);
          }
          out.push(step);
        }
      }
      out.push({
        label: "Negative cycle check",
        description:
          "Finally, check once more: if any edge can still be relaxed, there is a negative cycle.",
        dist: new Map(dist),
        parent: new Map(parent),
        highlightEdge: null,
        highlightNode: null,
        codeKey: "bf_check",
      });
      for (const e of flatEdges) {
        const old = dist.get(e.to);
        const cand = dist.get(e.from) + e.w;
        const relax = cand < old;
        out.push({
          label: `Check edge (${idToLabel(e.from)} → ${idToLabel(e.to)})`,
          description: relax
            ? `Edge ${idToLabel(
                e.from
              )}→${idToLabel(
                e.to
              )} can still be relaxed: negative cycle detected.`
            : `Edge ${idToLabel(
                e.from
              )}→${idToLabel(e.to)} cannot be further relaxed.`,
          dist: new Map(dist),
          parent: new Map(parent),
          highlightEdge: e.id,
          highlightNode: e.to,
          codeKey: relax ? "bf_neg_cycle" : "bf_check_edge",
          negCycle: relax,
          u: e.from,
          v: e.to,
          w: e.w,
        });
      }
    } else {
      // FIFO queue variant
      const queue = [source];
      const inQueue = new Set([source]);
      out.push({
        label: "Queue init",
        description: `Initialize queue with source node ${idToLabel(source)}.`,
        dist: new Map(dist),
        parent: new Map(parent),
        highlightEdge: null,
        highlightNode: source,
        codeKey: "fifo_init",
      });

      let relaxCount = 0;
      const maxRelax = nodes.length * edges.length + 10;

      while (queue.length && relaxCount < maxRelax) {
        const u = queue.shift();
        inQueue.delete(u);
        out.push({
          label: `Pop ${idToLabel(u)} from queue`,
          description: `Processing node ${idToLabel(
            u
          )} from the front of the queue.`,
          dist: new Map(dist),
          parent: new Map(parent),
          highlightEdge: null,
          highlightNode: u,
          codeKey: "fifo_pop",
          u: u,
        });

        for (const e of flatEdges.filter((e) => e.from === u)) {
          const old = dist.get(e.to);
          const cand = dist.get(e.from) + e.w;
          const willRelax = cand < old;
          const step = {
            label: `Try relax (${idToLabel(e.from)} → ${idToLabel(e.to)})`,
            description: willRelax
              ? `Relaxing ${idToLabel(
                  e.from
                )}→${idToLabel(
                  e.to
                )} and pushing ${idToLabel(
                  e.to
                )} to queue (if not there).`
              : `No relaxation for ${idToLabel(
                  e.from
                )}→${idToLabel(e.to)}.`,
            dist: new Map(dist),
            parent: new Map(parent),
            highlightEdge: e.id,
            highlightNode: e.to,
            codeKey: "fifo_relax",
            relaxedNode: willRelax ? e.to : null,
            queueSnapshot: [...queue],
            u: e.from,
            v: e.to,
            w: e.w,
          };
          if (willRelax) {
            dist.set(e.to, cand);
            parent.set(e.to, e.from);
            relaxCount++;
            if (!inQueue.has(e.to)) {
              queue.push(e.to);
              inQueue.add(e.to);
            }
            step.dist = new Map(dist);
            step.parent = new Map(parent);
            step.queueSnapshot = [...queue];
          }
          out.push(step);
        }
      }
      const hasNegCycle = relaxCount >= maxRelax;
      out.push({
        label: hasNegCycle ? "Negative cycle detected" : "Done",
        description: hasNegCycle
          ? "Too many relaxations detected: negative cycle reachable from source."
          : "Queue is empty, FIFO Bellman-Ford terminates.",
        dist: new Map(dist),
        parent: new Map(parent),
        highlightEdge: null,
        highlightNode: null,
        codeKey: hasNegCycle ? "fifo_neg_cycle" : "fifo_done",
        negCycle: hasNegCycle,
      });
      
      // Additional check: verify if any edge can still be relaxed
      if (!hasNegCycle) {
        out.push({
          label: "Negative cycle check",
          description: "Check if any edge can still be relaxed (negative cycle detection).",
          dist: new Map(dist),
          parent: new Map(parent),
          highlightEdge: null,
          highlightNode: null,
          codeKey: "fifo_check",
        });
        for (const e of flatEdges) {
          const old = dist.get(e.to);
          const cand = dist.get(e.from) + e.w;
          const relax = cand < old;
          out.push({
            label: `Check edge (${idToLabel(e.from)} → ${idToLabel(e.to)})`,
            description: relax
              ? `Edge ${idToLabel(
                  e.from
                )}→${idToLabel(
                  e.to
                )} can still be relaxed: negative cycle detected.`
              : `Edge ${idToLabel(
                  e.from
                )}→${idToLabel(e.to)} cannot be further relaxed.`,
            dist: new Map(dist),
            parent: new Map(parent),
            highlightEdge: e.id,
            highlightNode: e.to,
            codeKey: relax ? "fifo_neg_cycle" : "fifo_check_edge",
            negCycle: relax,
            u: e.from,
            v: e.to,
            w: e.w,
          });
        }
      }
    }
    return out;
  }

  // formatDist is now imported from utils/helpers.js

  // --- New Algorithms: Dijkstra, Floyd-Warshall, A* --------------------
  // Algorithm functions are now imported from algorithms/
  function createDijkstraSteps_OLD(source) {
    const { nodes, edges } = computeGraphFromState();
    const dist = new Map();
    const parent = new Map();
    const visited = new Set();
    
    for (const n of nodes) {
      dist.set(n.id, Infinity);
      parent.set(n.id, null);
    }
    dist.set(source, 0);
    
    const flatEdges = edges.map((e) => ({
      from: e.from,
      to: e.to,
      w: e.weight ?? parseFloat(e.label),
      id: e.id,
    }));
    
    // Check for negative edges
    const hasNegative = flatEdges.some(e => e.w < 0);
    if (hasNegative) {
      return [{
        label: "Error: Negative edges detected",
        description: "Dijkstra's algorithm requires non-negative edge weights.",
        dist: new Map(dist),
        parent: new Map(parent),
        highlightEdge: null,
        highlightNode: null,
        codeKey: "error",
      }];
    }
    
    const out = [];
    out.push({
      label: "Initialization",
      description: `Initialize all distances to ∞ except source ${idToLabel(source)}, which is 0.`,
      dist: new Map(dist),
      parent: new Map(parent),
      highlightEdge: null,
      highlightNode: source,
      codeKey: "dijkstra_init",
    });
    
    // Priority queue simulation (using array for simplicity)
    const pq = nodes.map(n => ({ id: n.id, dist: dist.get(n.id) }));
    
    while (pq.length > 0) {
      // Extract minimum
      pq.sort((a, b) => dist.get(a.id) - dist.get(b.id));
      const u = pq.shift();
      
      if (visited.has(u.id)) continue;
      if (dist.get(u.id) === Infinity) break;
      
      visited.add(u.id);
      
      out.push({
        label: `Extract minimum: ${idToLabel(u.id)}`,
        description: `Selecting node ${idToLabel(u.id)} with distance ${formatDist(dist.get(u.id))}.`,
        dist: new Map(dist),
        parent: new Map(parent),
        highlightEdge: null,
        highlightNode: u.id,
        codeKey: "dijkstra_extract",
        u: u.id,
      });
      
      // Relax neighbors
      for (const e of flatEdges.filter(e => e.from === u.id && !visited.has(e.to))) {
        const old = dist.get(e.to);
        const cand = dist.get(u.id) + e.w;
        const willRelax = cand < old;
        
        const step = {
          label: `Relax edge (${idToLabel(u.id)} → ${idToLabel(e.to)})`,
          description: willRelax
            ? `Relaxing edge ${idToLabel(u.id)}→${idToLabel(e.to)}: updating d[${idToLabel(e.to)}] from ${formatDist(old)} to ${formatDist(cand)}.`
            : `Checking edge ${idToLabel(u.id)}→${idToLabel(e.to)}: no update.`,
          dist: new Map(dist),
          parent: new Map(parent),
          highlightEdge: e.id,
          highlightNode: e.to,
          codeKey: "dijkstra_relax",
          relaxedNode: willRelax ? e.to : null,
          u: u.id,
          v: e.to,
          w: e.w,
        };
        
        if (willRelax) {
          dist.set(e.to, cand);
          parent.set(e.to, u.id);
          step.dist = new Map(dist);
          step.parent = new Map(parent);
        }
        out.push(step);
      }
    }
    
    out.push({
      label: "Done",
      description: "All reachable nodes processed.",
      dist: new Map(dist),
      parent: new Map(parent),
      highlightEdge: null,
      highlightNode: null,
      codeKey: "dijkstra_done",
    });
    
    return out;
  }

  function createPrimSteps(source) {
    const { nodes, edges } = computeGraphFromState();
    const dist = new Map(); // Minimum edge weight to connect to MST
    const parent = new Map();
    const inMST = new Set();
    
    for (const n of nodes) {
      dist.set(n.id, Infinity);
      parent.set(n.id, null);
    }
    dist.set(source, 0);
    
    const flatEdges = edges.map((e) => ({
      from: e.from,
      to: e.to,
      w: e.weight ?? parseFloat(e.label),
      id: e.id,
    }));
    
    const out = [];
    out.push({
      label: "Initialization",
      description: `Initialize all edge weights to ∞ except source ${idToLabel(source)}, which is 0. Start building MST from source.`,
      dist: new Map(dist),
      parent: new Map(parent),
      highlightEdge: null,
      highlightNode: source,
      codeKey: "prim_init",
    });
    
    // Priority queue simulation (using array for simplicity)
    const pq = nodes.map(n => ({ id: n.id, dist: dist.get(n.id) }));
    
    while (pq.length > 0) {
      // Extract minimum
      pq.sort((a, b) => dist.get(a.id) - dist.get(b.id));
      const u = pq.shift();
      
      if (inMST.has(u.id)) continue;
      if (dist.get(u.id) === Infinity) break;
      
      inMST.add(u.id);
      
      out.push({
        label: `Add to MST: ${idToLabel(u.id)}`,
        description: `Adding node ${idToLabel(u.id)} to MST with minimum edge weight ${formatDist(dist.get(u.id))}.`,
        dist: new Map(dist),
        parent: new Map(parent),
        highlightEdge: null,
        highlightNode: u.id,
        codeKey: "prim_extract",
        u: u.id,
      });
      
      // Update neighbors (find minimum edge weights)
      for (const e of flatEdges.filter(e => 
        (e.from === u.id && !inMST.has(e.to)) || 
        (e.to === u.id && !inMST.has(e.from))
      )) {
        const v = e.from === u.id ? e.to : e.from;
        if (inMST.has(v)) continue;
        
        const old = dist.get(v);
        const cand = e.w;
        const willUpdate = cand < old;
        
        const step = {
          label: `Check edge (${idToLabel(u.id)} ↔ ${idToLabel(v)})`,
          description: willUpdate
            ? `Updating minimum edge weight to ${idToLabel(v)}: ${formatDist(old)} → ${formatDist(cand)}.`
            : `Edge ${idToLabel(u.id)}↔${idToLabel(v)} weight ${formatDist(cand)} is not better than current ${formatDist(old)}.`,
          dist: new Map(dist),
          parent: new Map(parent),
          highlightEdge: e.id,
          highlightNode: v,
          codeKey: "prim_relax",
          relaxedNode: willUpdate ? v : null,
          u: u.id,
          v: v,
          w: e.w,
        };
        
        if (willUpdate) {
          dist.set(v, cand);
          parent.set(v, u.id);
          step.dist = new Map(dist);
          step.parent = new Map(parent);
        }
        out.push(step);
      }
    }
    
    out.push({
      label: "Done",
      description: "Minimum Spanning Tree constructed.",
      dist: new Map(dist),
      parent: new Map(parent),
      highlightEdge: null,
      highlightNode: null,
      codeKey: "prim_done",
    });
    
    return out;
  }

  function createBFSSteps(source) {
    const { nodes, adj } = computeGraphFromState();
    const dist = new Map();
    const parent = new Map();
    const visited = new Set();

    for (const n of nodes) {
      dist.set(n.id, Infinity);
      parent.set(n.id, null);
    }
    dist.set(source, 0);

    const out = [];
    out.push({
      label: "Initialization",
      description: `Initialize all distances to ∞ except source ${idToLabel(
        source
      )}, which is 0. BFS treats all edges as weight 1 (number of hops).`,
      dist: new Map(dist),
      parent: new Map(parent),
      highlightEdge: null,
      highlightNode: source,
      codeKey: "bfs_init",
    });

    const queue = [source];
    visited.add(source);

    while (queue.length > 0) {
      const u = queue.shift();
      out.push({
        label: `Dequeue ${idToLabel(u)}`,
        description: `Remove node ${idToLabel(
          u
        )} from the front of the queue and explore its neighbors.`,
        dist: new Map(dist),
        parent: new Map(parent),
        highlightEdge: null,
        highlightNode: u,
        codeKey: "bfs_pop",
        u,
      });

      const neighbors = adj.get(u) || [];
      for (const { to: v } of neighbors) {
        const old = dist.get(v);
        const cand = dist.get(u) + 1;
        const willRelax = cand < old;
        const alreadyVisited = visited.has(v);

        const step = {
          label: `Explore edge (${idToLabel(u)} → ${idToLabel(v)})`,
          description: alreadyVisited
            ? `Neighbor ${idToLabel(
                v
              )} already discovered earlier, skip updating.`
            : willRelax
            ? `First time reaching ${idToLabel(
                v
              )}: set parent[${idToLabel(
                v
              )}] = ${idToLabel(u)} and distance = ${
                dist.get(u) + 1
              } (number of hops).`
            : `Checking neighbor ${idToLabel(
                v
              )}: no better distance found via ${idToLabel(u)}.`,
          dist: new Map(dist),
          parent: new Map(parent),
          highlightEdge: null,
          highlightNode: v,
          codeKey: "bfs_relax",
          relaxedNode: !alreadyVisited && willRelax ? v : null,
          u,
          v,
        };

        if (!alreadyVisited && willRelax) {
          dist.set(v, cand);
          parent.set(v, u);
          visited.add(v);
          queue.push(v);
          step.dist = new Map(dist);
          step.parent = new Map(parent);
        }
        out.push(step);
      }
    }

    out.push({
      label: "Done",
      description:
        "BFS is complete. All nodes reachable from the source have their minimum-hop distance and a parent in the BFS tree.",
      dist: new Map(dist),
      parent: new Map(parent),
      highlightEdge: null,
      highlightNode: null,
      codeKey: "bfs_done",
    });

    return out;
  }

  function createDFSSteps(source) {
    const { nodes, adj } = computeGraphFromState();
    const dist = new Map();
    const parent = new Map();
    const visited = new Set();

    for (const n of nodes) {
      dist.set(n.id, Infinity);
      parent.set(n.id, null);
    }
    dist.set(source, 0);

    const out = [];
    out.push({
      label: "Initialization",
      description: `Initialize all nodes as unvisited. Start DFS from source ${idToLabel(
        source
      )}.`,
      dist: new Map(dist),
      parent: new Map(parent),
      highlightEdge: null,
      highlightNode: source,
      codeKey: "dfs_init",
    });

    const stack = [source];

    while (stack.length > 0) {
      const u = stack.pop();
      if (visited.has(u)) continue;
      visited.add(u);

      out.push({
        label: `Visit ${idToLabel(u)}`,
        description: `Pop node ${idToLabel(
          u
        )} from the stack and mark it as visited.`,
        dist: new Map(dist),
        parent: new Map(parent),
        highlightEdge: null,
        highlightNode: u,
        codeKey: "dfs_visit",
        u,
      });

      const neighbors = (adj.get(u) || []).slice().reverse();
      for (const { to: v } of neighbors) {
        if (visited.has(v)) continue;
        const old = dist.get(v);
        const cand = dist.get(u) + 1;
        const willRelax = cand < old;

        const step = {
          label: `Explore edge (${idToLabel(u)} → ${idToLabel(v)})`,
          description: willRelax
            ? `First time visiting ${idToLabel(
                v
              )} from ${idToLabel(
                u
              )}. Set parent and push ${idToLabel(v)} on the stack.`
            : `Edge ${idToLabel(
                u
              )}→${idToLabel(v)} leads to an already discovered node.`,
          dist: new Map(dist),
          parent: new Map(parent),
          highlightEdge: null,
          highlightNode: v,
          codeKey: "dfs_relax",
          relaxedNode: willRelax ? v : null,
          u,
          v,
        };

        if (willRelax) {
          dist.set(v, cand);
          parent.set(v, u);
          stack.push(v);
          step.dist = new Map(dist);
          step.parent = new Map(parent);
        }
        out.push(step);
      }
    }

    out.push({
      label: "Done",
      description:
        "DFS is complete. All nodes reachable from the source belong to the DFS tree defined by the parent pointers.",
      dist: new Map(dist),
      parent: new Map(parent),
      highlightEdge: null,
      highlightNode: null,
      codeKey: "dfs_done",
    });

    return out;
  }

  function createFloydWarshallSteps() {
    const { nodes, edges } = computeGraphFromState();
    const n = nodes.length;
    const nodeIds = nodes.map(n => n.id).sort((a, b) => a - b);
    
    // Initialize distance matrix
    const dist = new Map();
    const next = new Map();
    
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        const key = `${nodeIds[i]}-${nodeIds[j]}`;
        if (i === j) {
          dist.set(key, 0);
        } else {
          dist.set(key, Infinity);
        }
        next.set(key, j);
      }
    }
    
    const flatEdges = edges.map((e) => ({
      from: e.from,
      to: e.to,
      w: e.weight ?? parseFloat(e.label),
      id: e.id,
    }));
    
    // Set direct edges
    for (const e of flatEdges) {
      const key = `${e.from}-${e.to}`;
      dist.set(key, e.w);
    }
    
    const out = [];
    out.push({
      label: "Initialization",
      description: "Initialize distance matrix: 0 for same node, ∞ for others, edge weights for direct edges.",
      dist: new Map(),
      parent: new Map(),
      highlightEdge: null,
      highlightNode: null,
      codeKey: "fw_init",
      fwMatrix: new Map(dist),
    });
    
    // Floyd-Warshall main loop
    for (let k = 0; k < n; k++) {
      const kId = nodeIds[k];
      out.push({
        label: `Iteration k=${idToLabel(kId)}`,
        description: `Considering paths through intermediate node ${idToLabel(kId)}.`,
        dist: new Map(),
        parent: new Map(),
        highlightEdge: null,
        highlightNode: kId,
        codeKey: "fw_outer",
        fwMatrix: new Map(dist),
        k: kId,
      });
      
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          const iId = nodeIds[i];
          const jId = nodeIds[j];
          const ikKey = `${iId}-${kId}`;
          const kjKey = `${kId}-${jId}`;
          const ijKey = `${iId}-${jId}`;
          
          const distIK = dist.get(ikKey);
          const distKJ = dist.get(kjKey);
          const distIJ = dist.get(ijKey);
          
          if (distIK !== Infinity && distKJ !== Infinity) {
            const newDist = distIK + distKJ;
            if (newDist < distIJ) {
              dist.set(ijKey, newDist);
              next.set(ijKey, next.get(ikKey));
              
              out.push({
                label: `Update: ${idToLabel(iId)} → ${idToLabel(jId)}`,
                description: `Path ${idToLabel(iId)}→${idToLabel(kId)}→${idToLabel(jId)} is shorter: ${formatDist(newDist)} < ${formatDist(distIJ)}`,
                dist: new Map(),
                parent: new Map(),
                highlightEdge: flatEdges.find(e => e.from === iId && e.to === jId)?.id || null,
                highlightNode: jId,
                codeKey: "fw_update",
                fwMatrix: new Map(dist),
                u: iId,
                v: jId,
                w: newDist,
              });
            }
          }
        }
      }
    }
    
    // Check for negative cycles
    let hasNegCycle = false;
    for (let i = 0; i < n; i++) {
      const key = `${nodeIds[i]}-${nodeIds[i]}`;
      if (dist.get(key) < 0) {
        hasNegCycle = true;
        break;
      }
    }
    
    out.push({
      label: hasNegCycle ? "Negative cycle detected" : "Done",
      description: hasNegCycle
        ? "Negative cycle detected (diagonal has negative values)."
        : "All-pairs shortest paths computed.",
      dist: new Map(),
      parent: new Map(),
      highlightEdge: null,
      highlightNode: null,
      codeKey: hasNegCycle ? "fw_neg_cycle" : "fw_done",
      fwMatrix: new Map(dist),
      negCycle: hasNegCycle,
    });
    
    return out;
  }

  function createAStarSteps(source, target) {
    const { nodes, edges } = computeGraphFromState();
    const dist = new Map();
    const parent = new Map();
    const gScore = new Map();
    const fScore = new Map();
    const openSet = new Set([source]);
    const closedSet = new Set();
    
    // Simple heuristic: Euclidean distance (or Manhattan if positions not available)
    function heuristic(a, b) {
      const nodeA = nodes.find(n => n.id === a);
      const nodeB = nodes.find(n => n.id === b);
      if (nodeA && nodeB && nodeA.x !== undefined && nodeB.x !== undefined) {
        const dx = nodeA.x - nodeB.x;
        const dy = nodeA.y - nodeB.y;
        return Math.sqrt(dx * dx + dy * dy) / 100; // Scale down
      }
      return 0; // Fallback: no heuristic
    }
    
    const targetId = target !== null && target !== undefined ? target : (nodes.find(n => n.id !== source)?.id || source);
    
    for (const n of nodes) {
      gScore.set(n.id, Infinity);
      fScore.set(n.id, Infinity);
      dist.set(n.id, Infinity);
      parent.set(n.id, null);
    }
    gScore.set(source, 0);
    fScore.set(source, heuristic(source, targetId));
    dist.set(source, 0);
    
    const flatEdges = edges.map((e) => ({
      from: e.from,
      to: e.to,
      w: e.weight ?? parseFloat(e.label),
      id: e.id,
    }));
    
    const out = [];
    out.push({
      label: "Initialization",
      description: `Initialize g(s)=0, f(s)=h(s), openSet={${idToLabel(source)}}.`,
      dist: new Map(dist),
      parent: new Map(parent),
      highlightEdge: null,
      highlightNode: source,
      codeKey: "astar_init",
    });
    
    while (openSet.size > 0) {
      // Find node with lowest fScore
      let current = null;
      let minF = Infinity;
      for (const id of openSet) {
        const f = fScore.get(id);
        if (f < minF) {
          minF = f;
          current = id;
        }
      }
      
      if (current === null) break;
      
      if (current === targetId) {
        out.push({
          label: "Path found",
          description: `Target ${idToLabel(targetId)} reached!`,
          dist: new Map(dist),
          parent: new Map(parent),
          highlightEdge: null,
          highlightNode: targetId,
          codeKey: "astar_found",
        });
        break;
      }
      
      openSet.delete(current);
      closedSet.add(current);
      
      out.push({
        label: `Process node: ${idToLabel(current)}`,
        description: `Selecting node ${idToLabel(current)} with f=${formatDist(fScore.get(current))}.`,
        dist: new Map(dist),
        parent: new Map(parent),
        highlightEdge: null,
        highlightNode: current,
        codeKey: "astar_extract",
        u: current,
      });
      
      for (const e of flatEdges.filter(e => e.from === current)) {
        if (closedSet.has(e.to)) continue;
        
        const tentativeG = gScore.get(current) + e.w;
        const oldG = gScore.get(e.to);
        
        if (tentativeG < oldG) {
          parent.set(e.to, current);
          gScore.set(e.to, tentativeG);
          fScore.set(e.to, tentativeG + heuristic(e.to, targetId));
          dist.set(e.to, tentativeG);
          
          if (!openSet.has(e.to)) {
            openSet.add(e.to);
          }
          
          out.push({
            label: `Update neighbor: ${idToLabel(e.to)}`,
            description: `Updating ${idToLabel(e.to)}: g=${formatDist(tentativeG)}, f=${formatDist(fScore.get(e.to))}.`,
            dist: new Map(dist),
            parent: new Map(parent),
            highlightEdge: e.id,
            highlightNode: e.to,
            codeKey: "astar_update",
            relaxedNode: e.to,
            u: current,
            v: e.to,
            w: e.w,
          });
        }
      }
    }
    
    if (openSet.size === 0 && current !== targetId) {
      out.push({
        label: "No path found",
        description: "Open set is empty, no path exists.",
        dist: new Map(dist),
        parent: new Map(parent),
        highlightEdge: null,
        highlightNode: null,
        codeKey: "astar_no_path",
      });
    }
    
    return out;
  }

  // --- Code templates & highlighting -------------------------------------
  // PSEUDO_TEMPLATES is now imported from pseudo-code/pseudo.js
  const PSEUDO_TEMPLATES_OLD = {
    relaxation: [
      { key: "init", text: "for each vertex v: d[v] = ∞, parent[v] = NIL" },
      { key: "init", text: "d[s] = 0" },
      {
        key: "relax_outer",
        text: "repeat |V|-1 times:",
      },
      {
        key: "relax",
        text: "  for each edge (u,v,w):",
      },
      {
        key: "relax",
        text: "      if d[u] + w < d[v]:",
      },
      {
        key: "relax",
        text: "          d[v] = d[u] + w; parent[v] = u",
      },
    ],
    "bellman-ford": [
      { key: "bf_init", text: "for each vertex v: d[v] = ∞, parent[v] = NIL" },
      { key: "bf_init", text: "d[s] = 0" },
      {
        key: "bf_outer",
        text: "for i from 1 to |V|-1:",
      },
      {
        key: "bf_relax",
        text: "  for each edge (u,v,w):",
      },
      {
        key: "bf_relax",
        text: "      if d[u] + w < d[v]:",
      },
      {
        key: "bf_relax",
        text: "          d[v] = d[u] + w; parent[v] = u",
      },
      {
        key: "bf_check",
        text: "for each edge (u,v,w):",
      },
      {
        key: "bf_neg_cycle",
        text: "  if d[u] + w < d[v]: report negative cycle",
      },
    ],
    "bellman-ford-fifo": [
      {
        key: "fifo_init",
        text: "for each vertex v: d[v] = ∞, parent[v] = NIL; d[s] = 0",
      },
      { key: "fifo_init", text: "initialize FIFO queue Q with only s" },
      { key: "fifo_pop", text: "while Q not empty:" },
      { key: "fifo_pop", text: "  u = pop_front(Q)" },
      {
        key: "fifo_relax",
        text: "  for each outgoing edge (u,v,w):",
      },
      {
        key: "fifo_relax",
        text: "      if d[u] + w < d[v]:",
      },
      {
        key: "fifo_relax",
        text: "          d[v] = d[u] + w; parent[v] = u",
      },
      {
        key: "fifo_relax",
        text: "          if v not in Q: push_back(Q, v)",
      },
    ],
    dijkstra: [
      { key: "dijkstra_init", text: "for each vertex v: d[v] = ∞, parent[v] = NIL" },
      { key: "dijkstra_init", text: "d[s] = 0" },
      { key: "dijkstra_init", text: "initialize priority queue PQ with (0, s)" },
      { key: "dijkstra_extract", text: "while PQ not empty:" },
      { key: "dijkstra_extract", text: "  (dist_u, u) = extract_min(PQ)" },
      { key: "dijkstra_extract", text: "  if dist_u > d[u]: continue  // skip outdated entry" },
      {
        key: "dijkstra_relax",
        text: "  for each outgoing edge (u,v,w):",
      },
      {
        key: "dijkstra_relax",
        text: "      if d[u] + w < d[v]:",
      },
      {
        key: "dijkstra_relax",
        text: "          d[v] = d[u] + w; parent[v] = u",
      },
      {
        key: "dijkstra_relax",
        text: "          insert(PQ, (d[v], v))",
      },
    ],
    prim: [
      { key: "prim_init", text: "for each vertex v: key[v] = ∞, parent[v] = NIL" },
      { key: "prim_init", text: "key[s] = 0  // Start from source s" },
      { key: "prim_init", text: "initialize priority queue PQ with all vertices" },
      { key: "prim_extract", text: "while PQ not empty:" },
      { key: "prim_extract", text: "  u = extract_min(PQ)  // Minimum key vertex" },
      { key: "prim_extract", text: "  add u to MST" },
      { key: "prim_relax", text: "  for each neighbor v of u:" },
      { key: "prim_relax", text: "      if v in PQ and weight(u,v) < key[v]:" },
      { key: "prim_relax", text: "          key[v] = weight(u,v); parent[v] = u" },
      { key: "prim_relax", text: "          update PQ with new key[v]" },
      { key: "prim_done", text: "// MST constructed" },
    ],
    bfs: [
      { key: "bfs_init", text: "for each vertex v: d[v] = ∞, parent[v] = NIL" },
      { key: "bfs_init", text: "d[s] = 0" },
      { key: "bfs_init", text: "initialize FIFO queue Q with only s" },
      { key: "bfs_pop", text: "while Q not empty:" },
      { key: "bfs_pop", text: "  u = pop_front(Q)" },
      {
        key: "bfs_relax",
        text: "  for each neighbor v of u:",
      },
      {
        key: "bfs_relax",
        text: "      if v not yet discovered:",
      },
      {
        key: "bfs_relax",
        text: "          d[v] = d[u] + 1; parent[v] = u; push_back(Q, v)",
      },
    ],
    dfs: [
      {
        key: "dfs_init",
        text: "for each vertex v: visited[v] = false, parent[v] = NIL",
      },
      { key: "dfs_init", text: "DFS(u):" },
      { key: "dfs_visit", text: "  visited[u] = true" },
      {
        key: "dfs_relax",
        text: "  for each neighbor v of u:",
      },
      {
        key: "dfs_relax",
        text: "      if not visited[v]:",
      },
      {
        key: "dfs_relax",
        text: "          parent[v] = u; DFS(v)",
      },
    ],
  };

  // CODE_TEMPLATES is now imported from code-templates/templates.js
  const CODE_TEMPLATES_OLD = {
    cpp: {
      relaxation: [
        { key: "init", text: "vector<double> d(n, INF); vector<int> parent(n, -1);" },
        { key: "init", text: "d[s] = 0;" },
        { key: "relax_outer", text: "for (int i = 0; i < n - 1; ++i) {" },
        {
          key: "relax",
          text: "  for (auto &e : edges) { int u = e.u, v = e.v; double w = e.w;",
        },
        { key: "relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "relax", text: "    }" },
        { key: "relax_outer", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "vector<double> d(n, INF); vector<int> parent(n, -1);" },
        { key: "bf_init", text: "d[s] = 0;" },
        { key: "bf_outer", text: "for (int i = 0; i < n - 1; ++i) {" },
        {
          key: "bf_relax",
          text: "  for (auto &e : edges) { int u = e.u, v = e.v; double w = e.w;",
        },
        { key: "bf_relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "bf_relax", text: "    }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for (auto &e : edges) {" },
        { key: "bf_neg_cycle", text: "  if (d[e.u] + e.w < d[e.v]) {" },
        { key: "bf_neg_cycle", text: "    // negative cycle reachable from s" },
        { key: "bf_neg_cycle", text: "  }" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        {
          key: "fifo_init",
          text: "vector<double> d(n, INF); vector<int> parent(n, -1); d[s] = 0;",
        },
        {
          key: "fifo_init",
          text: "queue<int> q; vector<bool> inQ(n, false); q.push(s); inQ[s] = true;",
        },
        { key: "fifo_pop", text: "while (!q.empty()) {" },
        { key: "fifo_pop", text: "  int u = q.front(); q.pop(); inQ[u] = false;" },
        { key: "fifo_relax", text: "  for (auto &e : adj[u]) {" },
        { key: "fifo_relax", text: "    int v = e.to; double w = e.w;" },
        { key: "fifo_relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "fifo_relax", text: "      if (!inQ[v]) { q.push(v); inQ[v] = true; }" },
        { key: "fifo_relax", text: "    }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "#include <queue>" },
        { key: "dijkstra_init", text: "#include <vector>" },
        { key: "dijkstra_init", text: "vector<double> d(n, INF); vector<int> parent(n, -1);" },
        { key: "dijkstra_init", text: "d[s] = 0;" },
        { key: "dijkstra_init", text: "priority_queue<pair<double, int>, vector<pair<double, int>>, greater<>> pq;" },
        { key: "dijkstra_init", text: "pq.push({0, s});" },
        { key: "dijkstra_extract", text: "while (!pq.empty()) {" },
        { key: "dijkstra_extract", text: "  auto [dist_u, u] = pq.top(); pq.pop();" },
        { key: "dijkstra_extract", text: "  if (dist_u > d[u]) continue;" },
        { key: "dijkstra_relax", text: "  for (auto &[v, w] : adj[u]) {" },
        { key: "dijkstra_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "dijkstra_relax", text: "          pq.push({d[v], v});" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
        { key: "dijkstra_done", text: "// All reachable nodes processed" },
      ],
      prim: [
        { key: "prim_init", text: "#include <queue>" },
        { key: "prim_init", text: "vector<double> key(n, INF); vector<int> parent(n, -1); vector<bool> inMST(n, false);" },
        { key: "prim_init", text: "key[s] = 0;" },
        { key: "prim_init", text: "priority_queue<pair<double, int>, vector<pair<double, int>>, greater<>> pq; pq.push({0, s});" },
        { key: "prim_extract", text: "while (!pq.empty()) {" },
        { key: "prim_extract", text: "  auto [key_u, u] = pq.top(); pq.pop();" },
        { key: "prim_extract", text: "  if (inMST[u]) continue;" },
        { key: "prim_extract", text: "  inMST[u] = true;" },
        { key: "prim_relax", text: "  for (auto &[v, w] : adj[u]) {" },
        { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
        { key: "prim_relax", text: "          pq.push({key[v], v});" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "#include <queue>" },
        { key: "bfs_init", text: "vector<int> d(n, INF); vector<int> parent(n, -1); vector<bool> visited(n, false);" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true;" },
        { key: "bfs_init", text: "queue<int> q; q.push(s);" },
        { key: "bfs_pop", text: "while (!q.empty()) {" },
        { key: "bfs_pop", text: "  int u = q.front(); q.pop();" },
        { key: "bfs_relax", text: "  for (int v : adj[u]) {" },
        { key: "bfs_relax", text: "      if (!visited[v]) {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.push(v);" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "vector<bool> visited(n, false); vector<int> parent(n, -1);" },
        { key: "dfs_init", text: "void dfs(int u) {" },
        { key: "dfs_visit", text: "  visited[u] = true;" },
        { key: "dfs_relax", text: "  for (int v : adj[u]) {" },
        { key: "dfs_relax", text: "      if (!visited[v]) {" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    c: {
      relaxation: [
        { key: "init", text: "for (int i = 0; i < n; ++i) { d[i] = INF; parent[i] = -1; }" },
        { key: "init", text: "d[s] = 0;" },
        { key: "relax_outer", text: "for (int i = 0; i < n - 1; ++i) {" },
        {
          key: "relax",
          text: "  for (int e = 0; e < m; ++e) { int u = U[e], v = V[e]; double w = W[e];",
        },
        { key: "relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "relax", text: "    }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "for (int i = 0; i < n; ++i) { d[i] = INF; parent[i] = -1; }" },
        { key: "bf_init", text: "d[s] = 0;" },
        { key: "bf_outer", text: "for (int i = 0; i < n - 1; ++i) {" },
        {
          key: "bf_relax",
          text: "  for (int e = 0; e < m; ++e) { int u = U[e], v = V[e]; double w = W[e];",
        },
        { key: "bf_relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "bf_relax", text: "    }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for (int e = 0; e < m; ++e) {" },
        { key: "bf_neg_cycle", text: "  if (d[U[e]] + W[e] < d[V[e]]) {" },
        { key: "bf_neg_cycle", text: "    // negative cycle" },
        { key: "bf_neg_cycle", text: "  }" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        {
          key: "fifo_init",
          text: "for (int i = 0; i < n; ++i) { d[i] = INF; inQ[i] = false; parent[i] = -1; }",
        },
        { key: "fifo_init", text: "d[s] = 0; push(q, s); inQ[s] = true;" },
        { key: "fifo_pop", text: "while (!empty(q)) {" },
        { key: "fifo_pop", text: "  int u = front(q); pop(q); inQ[u] = false;" },
        { key: "fifo_relax", text: "  for (each edge (u,v,w)) {" },
        { key: "fifo_relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "fifo_relax", text: "      if (!inQ[v]) { push(q, v); inQ[v] = true; }" },
        { key: "fifo_relax", text: "    }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "// Note: C doesn't have built-in priority queue" },
        { key: "dijkstra_init", text: "// Use a min-heap implementation or array-based approach" },
        { key: "dijkstra_init", text: "double d[n]; int parent[n]; bool visited[n];" },
        { key: "dijkstra_init", text: "for (int i = 0; i < n; i++) { d[i] = INF; parent[i] = -1; visited[i] = false; }" },
        { key: "dijkstra_init", text: "d[s] = 0;" },
        { key: "dijkstra_extract", text: "for (int count = 0; count < n; count++) {" },
        { key: "dijkstra_extract", text: "  int u = -1; double min_dist = INF;" },
        { key: "dijkstra_extract", text: "  for (int i = 0; i < n; i++)" },
        { key: "dijkstra_extract", text: "      if (!visited[i] && d[i] < min_dist) { u = i; min_dist = d[i]; }" },
        { key: "dijkstra_extract", text: "  if (u == -1) break; visited[u] = true;" },
        { key: "dijkstra_relax", text: "  for (each edge (u, v, w) in adj[u]) {" },
        { key: "dijkstra_relax", text: "      if (!visited[v] && d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "// Note: C doesn't have built-in priority queue" },
        { key: "prim_init", text: "// Use array-based approach or implement min-heap" },
        { key: "prim_init", text: "double key[n]; int parent[n]; bool inMST[n];" },
        { key: "prim_init", text: "for (int i = 0; i < n; i++) { key[i] = INF; parent[i] = -1; inMST[i] = false; }" },
        { key: "prim_init", text: "key[s] = 0;" },
        { key: "prim_extract", text: "for (int count = 0; count < n; count++) {" },
        { key: "prim_extract", text: "  int u = -1; double min_key = INF;" },
        { key: "prim_extract", text: "  for (int i = 0; i < n; i++)" },
        { key: "prim_extract", text: "      if (!inMST[i] && key[i] < min_key) { u = i; min_key = key[i]; }" },
        { key: "prim_extract", text: "  if (u == -1) break; inMST[u] = true;" },
        { key: "prim_relax", text: "  for (each edge (u, v, w) in adj[u]) {" },
        { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "// Note: C doesn't have built-in queue" },
        { key: "bfs_init", text: "// Use array-based queue or implement queue structure" },
        { key: "bfs_init", text: "int d[n], parent[n]; bool visited[n];" },
        { key: "bfs_init", text: "for (int i = 0; i < n; i++) { d[i] = INF; parent[i] = -1; visited[i] = false; }" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true; int q[n], front = 0, rear = 0; q[rear++] = s;" },
        { key: "bfs_pop", text: "while (front < rear) {" },
        { key: "bfs_pop", text: "  int u = q[front++];" },
        { key: "bfs_relax", text: "  for (each neighbor v of u) {" },
        { key: "bfs_relax", text: "      if (!visited[v]) {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q[rear++] = v;" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "bool visited[n]; int parent[n];" },
        { key: "dfs_init", text: "for (int i = 0; i < n; i++) { visited[i] = false; parent[i] = -1; }" },
        { key: "dfs_init", text: "void dfs(int u) {" },
        { key: "dfs_visit", text: "  visited[u] = true;" },
        { key: "dfs_relax", text: "  for (each neighbor v of u) {" },
        { key: "dfs_relax", text: "      if (!visited[v]) {" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    java: {
      relaxation: [
        { key: "init", text: "double[] d = new double[n]; int[] parent = new int[n];" },
        { key: "init", text: "Arrays.fill(d, INF); Arrays.fill(parent, -1); d[s] = 0;" },
        { key: "relax_outer", text: "for (int i = 0; i < n - 1; i++) {" },
        {
          key: "relax",
          text: "  for (Edge e : edges) { int u = e.u, v = e.v; double w = e.w;",
        },
        { key: "relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "relax", text: "    }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "double[] d = new double[n]; int[] parent = new int[n];" },
        { key: "bf_init", text: "Arrays.fill(d, INF); Arrays.fill(parent, -1); d[s] = 0;" },
        { key: "bf_outer", text: "for (int i = 0; i < n - 1; i++) {" },
        {
          key: "bf_relax",
          text: "  for (Edge e : edges) { int u = e.u, v = e.v; double w = e.w;",
        },
        { key: "bf_relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "bf_relax", text: "    }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for (Edge e : edges) {" },
        { key: "bf_neg_cycle", text: "  if (d[e.u] + e.w < d[e.v]) {" },
        { key: "bf_neg_cycle", text: "    // negative cycle" },
        { key: "bf_neg_cycle", text: "  }" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        {
          key: "fifo_init",
          text: "double[] d = new double[n]; boolean[] inQ = new boolean[n]; int[] parent = new int[n];",
        },
        {
          key: "fifo_init",
          text: "Arrays.fill(d, INF); Arrays.fill(parent, -1); d[s] = 0;",
        },
        {
          key: "fifo_init",
          text: "Queue<Integer> q = new ArrayDeque<>(); q.add(s); inQ[s] = true;",
        },
        { key: "fifo_pop", text: "while (!q.isEmpty()) {" },
        { key: "fifo_pop", text: "  int u = q.remove(); inQ[u] = false;" },
        { key: "fifo_relax", text: "  for (Edge e : adj[u]) {" },
        { key: "fifo_relax", text: "    int v = e.v; double w = e.w;" },
        { key: "fifo_relax", text: "    if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
        { key: "fifo_relax", text: "      if (!inQ[v]) { q.add(v); inQ[v] = true; }" },
        { key: "fifo_relax", text: "    }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "import java.util.*;" },
        { key: "dijkstra_init", text: "double[] d = new double[n]; int[] parent = new int[n];" },
        { key: "dijkstra_init", text: "Arrays.fill(d, Double.POSITIVE_INFINITY); Arrays.fill(parent, -1);" },
        { key: "dijkstra_init", text: "d[s] = 0;" },
        { key: "dijkstra_init", text: "PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Double.compare(a[0], b[0]));" },
        { key: "dijkstra_init", text: "pq.offer(new int[]{0, s});" },
        { key: "dijkstra_extract", text: "while (!pq.isEmpty()) {" },
        { key: "dijkstra_extract", text: "  int[] curr = pq.poll(); double dist_u = curr[0]; int u = curr[1];" },
        { key: "dijkstra_extract", text: "  if (dist_u > d[u]) continue;" },
        { key: "dijkstra_relax", text: "  for (Edge e : adj[u]) {" },
        { key: "dijkstra_relax", text: "      int v = e.v; double w = e.w;" },
        { key: "dijkstra_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "dijkstra_relax", text: "          pq.offer(new int[]{(int)d[v], v});" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
        { key: "dijkstra_done", text: "// All reachable nodes processed" },
      ],
      prim: [
        { key: "prim_init", text: "import java.util.*;" },
        { key: "prim_init", text: "double[] key = new double[n]; int[] parent = new int[n]; boolean[] inMST = new boolean[n];" },
        { key: "prim_init", text: "Arrays.fill(key, Double.POSITIVE_INFINITY); Arrays.fill(parent, -1); key[s] = 0;" },
        { key: "prim_init", text: "PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Double.compare(a[0], b[0]));" },
        { key: "prim_init", text: "pq.offer(new int[]{0, s});" },
        { key: "prim_extract", text: "while (!pq.isEmpty()) {" },
        { key: "prim_extract", text: "  int[] curr = pq.poll(); double key_u = curr[0]; int u = curr[1];" },
        { key: "prim_extract", text: "  if (inMST[u]) continue;" },
        { key: "prim_extract", text: "  inMST[u] = true;" },
        { key: "prim_relax", text: "  for (Edge e : adj[u]) {" },
        { key: "prim_relax", text: "      int v = e.v; double w = e.w;" },
        { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
        { key: "prim_relax", text: "          pq.offer(new int[]{(int)key[v], v});" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "double[] d = new double[n]; int[] parent = new int[n]; boolean[] visited = new boolean[n];" },
        { key: "bfs_init", text: "Arrays.fill(d, Double.POSITIVE_INFINITY); Arrays.fill(parent, -1); d[s] = 0; visited[s] = true;" },
        { key: "bfs_init", text: "Queue<Integer> q = new ArrayDeque<>(); q.add(s);" },
        { key: "bfs_pop", text: "while (!q.isEmpty()) {" },
        { key: "bfs_pop", text: "  int u = q.remove();" },
        { key: "bfs_relax", text: "  for (Edge e : adj[u]) { int v = e.v;" },
        { key: "bfs_relax", text: "      if (!visited[v]) {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.add(v);" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "boolean[] visited = new boolean[n]; int[] parent = new int[n]; Arrays.fill(parent, -1);" },
        { key: "dfs_init", text: "void dfs(int u) {" },
        { key: "dfs_visit", text: "  visited[u] = true;" },
        { key: "dfs_relax", text: "  for (Edge e : adj[u]) { int v = e.v;" },
        { key: "dfs_relax", text: "      if (!visited[v]) {" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    python: {
      relaxation: [
        { key: "init", text: "d = {v: float('inf') for v in V}; parent = {v: None for v in V}" },
        { key: "init", text: "d[s] = 0" },
        { key: "relax_outer", text: "for _ in range(len(V) - 1):" },
        { key: "relax", text: "  for (u, v, w) in E:" },
        { key: "relax", text: "      if d[u] + w < d[v]:" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u" },
      ],
      "bellman-ford": [
        {
          key: "bf_init",
          text: "d = {v: float('inf') for v in V}; parent = {v: None for v in V}",
        },
        { key: "bf_init", text: "d[s] = 0" },
        { key: "bf_outer", text: "for _ in range(len(V) - 1):" },
        { key: "bf_relax", text: "  for (u, v, w) in E:" },
        { key: "bf_relax", text: "      if d[u] + w < d[v]:" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "bf_check", text: "for (u, v, w) in E:" },
        { key: "bf_neg_cycle", text: "  if d[u] + w < d[v]: print('negative cycle')" },
      ],
      "bellman-ford-fifo": [
        {
          key: "fifo_init",
          text: "d = {v: float('inf') for v in V}; parent = {v: None for v in V}",
        },
        { key: "fifo_init", text: "d[s] = 0" },
        { key: "fifo_init", text: "from collections import deque" },
        { key: "fifo_init", text: "Q = deque([s]); inQ = {v: False for v in V}; inQ[s] = True" },
        { key: "fifo_pop", text: "while Q:" },
        { key: "fifo_pop", text: "  u = Q.popleft(); inQ[u] = False" },
        { key: "fifo_relax", text: "  for (v, w) in adj[u]:" },
        { key: "fifo_relax", text: "      if d[u] + w < d[v]:" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "fifo_relax", text: "          if not inQ[v]: Q.append(v); inQ[v] = True" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "import heapq" },
        { key: "dijkstra_init", text: "d = {v: float('inf') for v in V}; parent = {v: None for v in V}" },
        { key: "dijkstra_init", text: "d[s] = 0" },
        { key: "dijkstra_init", text: "pq = [(0, s)]" },
        { key: "dijkstra_extract", text: "while pq:" },
        { key: "dijkstra_extract", text: "  dist_u, u = heapq.heappop(pq)" },
        { key: "dijkstra_extract", text: "  if dist_u > d[u]: continue" },
        { key: "dijkstra_relax", text: "  for (v, w) in adj[u]:" },
        { key: "dijkstra_relax", text: "      if d[u] + w < d[v]:" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "dijkstra_relax", text: "          heapq.heappush(pq, (d[v], v))" },
        { key: "dijkstra_done", text: "# All reachable nodes processed" },
      ],
      prim: [
        { key: "prim_init", text: "import heapq" },
        { key: "prim_init", text: "key = {v: float('inf') for v in V}; parent = {v: None for v in V}" },
        { key: "prim_init", text: "key[s] = 0" },
        { key: "prim_init", text: "pq = [(0, s)]; in_mst = set()" },
        { key: "prim_extract", text: "while pq:" },
        { key: "prim_extract", text: "  key_u, u = heapq.heappop(pq)" },
        { key: "prim_extract", text: "  if u in in_mst: continue" },
        { key: "prim_extract", text: "  in_mst.add(u)" },
        { key: "prim_relax", text: "  for (v, w) in adj[u]:" },
        { key: "prim_relax", text: "      if v not in in_mst and w < key[v]:" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u" },
        { key: "prim_relax", text: "          heapq.heappush(pq, (key[v], v))" },
        { key: "prim_done", text: "# MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "from collections import deque" },
        { key: "bfs_init", text: "d = {v: float('inf') for v in V}; parent = {v: None for v in V}" },
        { key: "bfs_init", text: "visited = {v: False for v in V}; d[s] = 0; visited[s] = True" },
        { key: "bfs_init", text: "Q = deque([s])" },
        { key: "bfs_pop", text: "while Q:" },
        { key: "bfs_pop", text: "  u = Q.popleft()" },
        { key: "bfs_relax", text: "  for (v, _) in adj[u]:" },
        { key: "bfs_relax", text: "      if not visited[v]:" },
        { key: "bfs_relax", text: "          visited[v] = True; d[v] = d[u] + 1; parent[v] = u; Q.append(v)" },
      ],
      dfs: [
        { key: "dfs_init", text: "visited = {v: False for v in V}; parent = {v: None for v in V}" },
        { key: "dfs_init", text: "def dfs(u):" },
        { key: "dfs_visit", text: "  visited[u] = True" },
        { key: "dfs_relax", text: "  for (v, _) in adj[u]:" },
        { key: "dfs_relax", text: "      if not visited[v]:" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v)" },
      ],
    },
    rust: {
      relaxation: [
        { key: "init", text: "let mut d = vec![f64::INFINITY; n]; let mut parent = vec![None; n];" },
        { key: "init", text: "d[s] = 0.0;" },
        { key: "relax_outer", text: "for _ in 0..n - 1 {" },
        { key: "relax", text: "  for &(u, v, w) in &edges {" },
        { key: "relax", text: "      if d[u] + w < d[v] {" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = Some(u);" },
        { key: "relax", text: "      }" },
        { key: "relax_outer", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "let mut d = vec![f64::INFINITY; n]; let mut parent = vec![None; n];" },
        { key: "bf_init", text: "d[s] = 0.0;" },
        { key: "bf_outer", text: "for _ in 0..n - 1 {" },
        { key: "bf_relax", text: "  for &(u, v, w) in &edges {" },
        { key: "bf_relax", text: "      if d[u] + w < d[v] {" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = Some(u);" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for &(u, v, w) in &edges {" },
        { key: "bf_neg_cycle", text: "  if d[u] + w < d[v] { println!(\"negative cycle\"); }" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "let mut d = vec![f64::INFINITY; n]; let mut parent = vec![None; n];" },
        { key: "fifo_init", text: "d[s] = 0.0;" },
        { key: "fifo_init", text: "use std::collections::VecDeque;" },
        { key: "fifo_init", text: "let mut q = VecDeque::new(); let mut in_q = vec![false; n];" },
        { key: "fifo_init", text: "q.push_back(s); in_q[s] = true;" },
        { key: "fifo_pop", text: "while let Some(u) = q.pop_front() {" },
        { key: "fifo_pop", text: "  in_q[u] = false;" },
        { key: "fifo_relax", text: "  for &(v, w) in &adj[u] {" },
        { key: "fifo_relax", text: "      if d[u] + w < d[v] {" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = Some(u);" },
        { key: "fifo_relax", text: "          if !in_q[v] { q.push_back(v); in_q[v] = true; }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
        { key: "fifo_done", text: "// Algorithm completed" },
        { key: "fifo_check", text: "// Check for negative cycles" },
        { key: "fifo_check_edge", text: "for &(u, v, w) in &edges {" },
        { key: "fifo_neg_cycle", text: "  if d[u] + w < d[v] { println!(\"negative cycle\"); }" },
        { key: "fifo_check_edge", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "use std::collections::BinaryHeap;" },
        { key: "dijkstra_init", text: "let mut d = vec![f64::INFINITY; n]; let mut parent = vec![None; n];" },
        { key: "dijkstra_init", text: "d[s] = 0.0;" },
        { key: "dijkstra_init", text: "let mut pq = BinaryHeap::new();" },
        { key: "dijkstra_init", text: "pq.push(std::cmp::Reverse((0.0, s)));" },
        { key: "dijkstra_extract", text: "while let Some(std::cmp::Reverse((dist_u, u))) = pq.pop() {" },
        { key: "dijkstra_extract", text: "  if dist_u > d[u] { continue; }" },
        { key: "dijkstra_relax", text: "  for &(v, w) in &adj[u] {" },
        { key: "dijkstra_relax", text: "      if d[u] + w < d[v] {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = Some(u);" },
        { key: "dijkstra_relax", text: "          pq.push(std::cmp::Reverse((d[v], v)));" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "use std::collections::BinaryHeap;" },
        { key: "prim_init", text: "let mut key = vec![f64::INFINITY; n]; let mut parent = vec![None; n]; let mut in_mst = vec![false; n];" },
        { key: "prim_init", text: "key[s] = 0.0;" },
        { key: "prim_init", text: "let mut pq = BinaryHeap::new(); pq.push(std::cmp::Reverse((0.0, s)));" },
        { key: "prim_extract", text: "while let Some(std::cmp::Reverse((key_u, u))) = pq.pop() {" },
        { key: "prim_extract", text: "  if in_mst[u] { continue; }" },
        { key: "prim_extract", text: "  in_mst[u] = true;" },
        { key: "prim_relax", text: "  for &(v, w) in &adj[u] {" },
        { key: "prim_relax", text: "      if !in_mst[v] && w < key[v] {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = Some(u);" },
        { key: "prim_relax", text: "          pq.push(std::cmp::Reverse((key[v], v)));" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "use std::collections::VecDeque;" },
        { key: "bfs_init", text: "let mut d = vec![i32::MAX; n]; let mut parent = vec![None; n]; let mut visited = vec![false; n];" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true;" },
        { key: "bfs_init", text: "let mut q = VecDeque::new(); q.push_back(s);" },
        { key: "bfs_pop", text: "while let Some(u) = q.pop_front() {" },
        { key: "bfs_relax", text: "  for &v in &adj[u] {" },
        { key: "bfs_relax", text: "      if !visited[v] {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = Some(u); q.push_back(v);" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "let mut visited = vec![false; n]; let mut parent = vec![None; n];" },
        { key: "dfs_init", text: "fn dfs(u: usize, adj: &Vec<Vec<usize>>, visited: &mut Vec<bool>, parent: &mut Vec<Option<usize>>) {" },
        { key: "dfs_visit", text: "  visited[u] = true;" },
        { key: "dfs_relax", text: "  for &v in &adj[u] {" },
        { key: "dfs_relax", text: "      if !visited[v] {" },
        { key: "dfs_relax", text: "          parent[v] = Some(u); dfs(v, adj, visited, parent);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    javascript: {
      relaxation: [
        { key: "init", text: "const d = Array(n).fill(Infinity); const parent = Array(n).fill(null);" },
        { key: "init", text: "d[s] = 0;" },
        { key: "relax_outer", text: "for (let i = 0; i < n - 1; i++) {" },
        { key: "relax", text: "  for (const [u, v, w] of edges) {" },
        { key: "relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "const d = Array(n).fill(Infinity); const parent = Array(n).fill(null);" },
        { key: "bf_init", text: "d[s] = 0;" },
        { key: "bf_outer", text: "for (let i = 0; i < n - 1; i++) {" },
        { key: "bf_relax", text: "  for (const [u, v, w] of edges) {" },
        { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for (const [u, v, w] of edges) {" },
        { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) console.log('negative cycle');" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "const d = Array(n).fill(Infinity); const parent = Array(n).fill(null);" },
        { key: "fifo_init", text: "d[s] = 0;" },
        { key: "fifo_init", text: "const q = [s]; const inQ = Array(n).fill(false); inQ[s] = true;" },
        { key: "fifo_pop", text: "while (q.length > 0) {" },
        { key: "fifo_pop", text: "  const u = q.shift(); inQ[u] = false;" },
        { key: "fifo_relax", text: "  for (const [v, w] of adj[u]) {" },
        { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "fifo_relax", text: "          if (!inQ[v]) { q.push(v); inQ[v] = true; }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
        { key: "fifo_done", text: "// Algorithm completed" },
        { key: "fifo_check", text: "// Check for negative cycles" },
        { key: "fifo_check_edge", text: "for (const [u, v, w] of edges) {" },
        { key: "fifo_neg_cycle", text: "  if (d[u] + w < d[v]) console.log('negative cycle');" },
        { key: "fifo_check_edge", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "const d = Array(n).fill(Infinity); const parent = Array(n).fill(null);" },
        { key: "dijkstra_init", text: "d[s] = 0;" },
        { key: "dijkstra_init", text: "const pq = [[0, s]];" },
        { key: "dijkstra_extract", text: "while (pq.length > 0) {" },
        { key: "dijkstra_extract", text: "  pq.sort((a, b) => a[0] - b[0]);" },
        { key: "dijkstra_extract", text: "  const [dist_u, u] = pq.shift();" },
        { key: "dijkstra_extract", text: "  if (dist_u > d[u]) continue;" },
        { key: "dijkstra_relax", text: "  for (const [v, w] of adj[u]) {" },
        { key: "dijkstra_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "dijkstra_relax", text: "          pq.push([d[v], v]);" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
        { key: "dijkstra_done", text: "// All reachable nodes processed" },
      ],
    },
    typescript: {
      relaxation: [
        { key: "init", text: "const d: number[] = Array(n).fill(Infinity); const parent: (number | null)[] = Array(n).fill(null);" },
        { key: "init", text: "d[s] = 0;" },
        { key: "relax_outer", text: "for (let i = 0; i < n - 1; i++) {" },
        { key: "relax", text: "  for (const [u, v, w]: [number, number, number] of edges) {" },
        { key: "relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "const d: number[] = Array(n).fill(Infinity); const parent: (number | null)[] = Array(n).fill(null);" },
        { key: "bf_init", text: "d[s] = 0;" },
        { key: "bf_outer", text: "for (let i = 0; i < n - 1; i++) {" },
        { key: "bf_relax", text: "  for (const [u, v, w]: [number, number, number] of edges) {" },
        { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for (const [u, v, w]: [number, number, number] of edges) {" },
        { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) console.log('negative cycle');" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "const d: number[] = Array(n).fill(Infinity); const parent: (number | null)[] = Array(n).fill(null);" },
        { key: "fifo_init", text: "d[s] = 0;" },
        { key: "fifo_init", text: "const q: number[] = [s]; const inQ: boolean[] = Array(n).fill(false); inQ[s] = true;" },
        { key: "fifo_pop", text: "while (q.length > 0) {" },
        { key: "fifo_pop", text: "  const u = q.shift()!; inQ[u] = false;" },
        { key: "fifo_relax", text: "  for (const [v, w]: [number, number] of adj[u]) {" },
        { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "fifo_relax", text: "          if (!inQ[v]) { q.push(v); inQ[v] = true; }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
        { key: "fifo_done", text: "// Algorithm completed" },
        { key: "fifo_check", text: "// Check for negative cycles" },
        { key: "fifo_check_edge", text: "for (const [u, v, w]: [number, number, number] of edges) {" },
        { key: "fifo_neg_cycle", text: "  if (d[u] + w < d[v]) console.log('negative cycle');" },
        { key: "fifo_check_edge", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "const d: number[] = Array(n).fill(Infinity); const parent: (number | null)[] = Array(n).fill(null);" },
        { key: "dijkstra_init", text: "d[s] = 0;" },
        { key: "dijkstra_init", text: "const pq: [number, number][] = [[0, s]];" },
        { key: "dijkstra_extract", text: "while (pq.length > 0) {" },
        { key: "dijkstra_extract", text: "  pq.sort((a, b) => a[0] - b[0]);" },
        { key: "dijkstra_extract", text: "  const [dist_u, u] = pq.shift()!;" },
        { key: "dijkstra_extract", text: "  if (dist_u > d[u]) continue;" },
        { key: "dijkstra_relax", text: "  for (const [v, w]: [number, number] of adj[u]) {" },
        { key: "dijkstra_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "dijkstra_relax", text: "          pq.push([d[v], v]);" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "const key = Array(n).fill(Infinity); const parent = Array(n).fill(null); const inMST = Array(n).fill(false);" },
        { key: "prim_init", text: "key[s] = 0;" },
        { key: "prim_init", text: "const pq = [[0, s]];" },
        { key: "prim_extract", text: "while (pq.length > 0) {" },
        { key: "prim_extract", text: "  pq.sort((a, b) => a[0] - b[0]);" },
        { key: "prim_extract", text: "  const [key_u, u] = pq.shift();" },
        { key: "prim_extract", text: "  if (inMST[u]) continue;" },
        { key: "prim_extract", text: "  inMST[u] = true;" },
        { key: "prim_relax", text: "  for (const [v, w] of adj[u]) {" },
        { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
        { key: "prim_relax", text: "          pq.push([key[v], v]);" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "const d = Array(n).fill(Infinity); const parent = Array(n).fill(null);" },
        { key: "bfs_init", text: "const visited = Array(n).fill(false);" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true; const q = [s];" },
        { key: "bfs_pop", text: "while (q.length > 0) {" },
        { key: "bfs_pop", text: "  const u = q.shift();" },
        { key: "bfs_relax", text: "  for (const [v] of adj[u]) {" },
        { key: "bfs_relax", text: "      if (!visited[v]) {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.push(v);" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "const visited = Array(n).fill(false); const parent = Array(n).fill(null);" },
        { key: "dfs_init", text: "function dfs(u) {" },
        { key: "dfs_visit", text: "  visited[u] = true;" },
        { key: "dfs_relax", text: "  for (const [v] of adj[u]) {" },
        { key: "dfs_relax", text: "      if (!visited[v]) {" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    go: {
      relaxation: [
        { key: "init", text: "d := make([]float64, n); parent := make([]int, n)" },
        { key: "init", text: "for i := range d { d[i] = math.Inf(1); parent[i] = -1 }" },
        { key: "init", text: "d[s] = 0" },
        { key: "relax_outer", text: "for i := 0; i < n-1; i++ {" },
        { key: "relax", text: "  for _, e := range edges {" },
        { key: "relax", text: "      u, v, w := e.u, e.v, e.w" },
        { key: "relax", text: "      if d[u] + w < d[v] {" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "d := make([]float64, n); parent := make([]int, n)" },
        { key: "bf_init", text: "for i := range d { d[i] = math.Inf(1); parent[i] = -1 }" },
        { key: "bf_init", text: "d[s] = 0" },
        { key: "bf_outer", text: "for i := 0; i < n-1; i++ {" },
        { key: "bf_relax", text: "  for _, e := range edges {" },
        { key: "bf_relax", text: "      u, v, w := e.u, e.v, e.w" },
        { key: "bf_relax", text: "      if d[u] + w < d[v] {" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for _, e := range edges {" },
        { key: "bf_neg_cycle", text: "  if d[e.u] + e.w < d[e.v] { fmt.Println(\"negative cycle\") }" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "d := make([]float64, n); parent := make([]int, n); inQ := make([]bool, n)" },
        { key: "fifo_init", text: "for i := range d { d[i] = math.Inf(1); parent[i] = -1 }" },
        { key: "fifo_init", text: "d[s] = 0; q := []int{s}; inQ[s] = true" },
        { key: "fifo_pop", text: "for len(q) > 0 {" },
        { key: "fifo_pop", text: "  u := q[0]; q = q[1:]; inQ[u] = false" },
        { key: "fifo_relax", text: "  for _, e := range adj[u] {" },
        { key: "fifo_relax", text: "      v, w := e.v, e.w" },
        { key: "fifo_relax", text: "      if d[u] + w < d[v] {" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "fifo_relax", text: "          if !inQ[v] { q = append(q, v); inQ[v] = true }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
        { key: "fifo_done", text: "// Algorithm completed" },
        { key: "fifo_check", text: "// Check for negative cycles" },
        { key: "fifo_check_edge", text: "for _, e := range edges {" },
        { key: "fifo_neg_cycle", text: "  if d[e.u] + e.w < d[e.v] { fmt.Println(\"negative cycle\") }" },
        { key: "fifo_check_edge", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "import (\"container/heap\")" },
        { key: "dijkstra_init", text: "d := make([]float64, n); parent := make([]int, n)" },
        { key: "dijkstra_init", text: "for i := range d { d[i] = math.Inf(1); parent[i] = -1 }" },
        { key: "dijkstra_init", text: "d[s] = 0" },
        { key: "dijkstra_init", text: "pq := &PriorityQueue{}; heap.Init(pq); heap.Push(pq, Item{0, s})" },
        { key: "dijkstra_extract", text: "for pq.Len() > 0 {" },
        { key: "dijkstra_extract", text: "  item := heap.Pop(pq).(Item); dist_u, u := item.priority, item.value" },
        { key: "dijkstra_extract", text: "  if dist_u > d[u] { continue }" },
        { key: "dijkstra_relax", text: "  for _, e := range adj[u] {" },
        { key: "dijkstra_relax", text: "      v, w := e.v, e.w" },
        { key: "dijkstra_relax", text: "      if d[u] + w < d[v] {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "dijkstra_relax", text: "          heap.Push(pq, Item{d[v], v})" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "import (\"container/heap\")" },
        { key: "prim_init", text: "key := make([]float64, n); parent := make([]int, n); inMST := make([]bool, n)" },
        { key: "prim_init", text: "for i := range key { key[i] = math.Inf(1); parent[i] = -1 }" },
        { key: "prim_init", text: "key[s] = 0" },
        { key: "prim_init", text: "pq := &PriorityQueue{}; heap.Init(pq); heap.Push(pq, Item{0, s})" },
        { key: "prim_extract", text: "for pq.Len() > 0 {" },
        { key: "prim_extract", text: "  item := heap.Pop(pq).(Item); key_u, u := item.priority, item.value" },
        { key: "prim_extract", text: "  if inMST[u] { continue }" },
        { key: "prim_extract", text: "  inMST[u] = true" },
        { key: "prim_relax", text: "  for _, e := range adj[u] {" },
        { key: "prim_relax", text: "      v, w := e.v, e.w" },
        { key: "prim_relax", text: "      if !inMST[v] && w < key[v] {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u" },
        { key: "prim_relax", text: "          heap.Push(pq, Item{key[v], v})" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "d := make([]int, n); parent := make([]int, n); visited := make([]bool, n)" },
        { key: "bfs_init", text: "for i := range d { d[i] = math.MaxInt32; parent[i] = -1 }" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true; q := []int{s}" },
        { key: "bfs_pop", text: "for len(q) > 0 {" },
        { key: "bfs_pop", text: "  u := q[0]; q = q[1:]" },
        { key: "bfs_relax", text: "  for _, v := range adj[u] {" },
        { key: "bfs_relax", text: "      if !visited[v] {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q = append(q, v)" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "visited := make([]bool, n); parent := make([]int, n)" },
        { key: "dfs_init", text: "for i := range parent { parent[i] = -1 }" },
        { key: "dfs_init", text: "var dfs func(int)" },
        { key: "dfs_init", text: "dfs = func(u int) {" },
        { key: "dfs_visit", text: "  visited[u] = true" },
        { key: "dfs_relax", text: "  for _, v := range adj[u] {" },
        { key: "dfs_relax", text: "      if !visited[v] {" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v)" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    kotlin: {
      relaxation: [
        { key: "init", text: "val d = DoubleArray(n) { Double.POSITIVE_INFINITY }" },
        { key: "init", text: "val parent = IntArray(n) { -1 }" },
        { key: "init", text: "d[s] = 0.0" },
        { key: "relax_outer", text: "repeat(n - 1) {" },
        { key: "relax", text: "  edges.forEach { (u, v, w) ->" },
        { key: "relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "val d = DoubleArray(n) { Double.POSITIVE_INFINITY }" },
        { key: "bf_init", text: "val parent = IntArray(n) { -1 }" },
        { key: "bf_init", text: "d[s] = 0.0" },
        { key: "bf_outer", text: "repeat(n - 1) {" },
        { key: "bf_relax", text: "  edges.forEach { (u, v, w) ->" },
        { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "edges.forEach { (u, v, w) ->" },
        { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) println(\"negative cycle\")" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "val d = DoubleArray(n) { Double.POSITIVE_INFINITY }" },
        { key: "fifo_init", text: "val parent = IntArray(n) { -1 }" },
        { key: "fifo_init", text: "d[s] = 0.0" },
        { key: "fifo_init", text: "val q = ArrayDeque<Int>(); val inQ = BooleanArray(n)" },
        { key: "fifo_init", text: "q.add(s); inQ[s] = true" },
        { key: "fifo_pop", text: "while (q.isNotEmpty()) {" },
        { key: "fifo_pop", text: "  val u = q.removeFirst(); inQ[u] = false" },
        { key: "fifo_relax", text: "  adj[u].forEach { (v, w) ->" },
        { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "fifo_relax", text: "          if (!inQ[v]) { q.add(v); inQ[v] = true }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "import java.util.*" },
        { key: "dijkstra_init", text: "val d = DoubleArray(n) { Double.POSITIVE_INFINITY }" },
        { key: "dijkstra_init", text: "val parent = IntArray(n) { -1 }" },
        { key: "dijkstra_init", text: "d[s] = 0.0" },
        { key: "dijkstra_init", text: "val pq = PriorityQueue<Pair<Double, Int>>(compareBy { it.first })" },
        { key: "dijkstra_init", text: "pq.add(0.0 to s)" },
        { key: "dijkstra_extract", text: "while (pq.isNotEmpty()) {" },
        { key: "dijkstra_extract", text: "  val (dist_u, u) = pq.poll()" },
        { key: "dijkstra_extract", text: "  if (dist_u > d[u]) continue" },
        { key: "dijkstra_relax", text: "  adj[u].forEach { (v, w) ->" },
        { key: "dijkstra_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "dijkstra_relax", text: "          pq.add(d[v] to v)" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "import java.util.*" },
        { key: "prim_init", text: "val key = DoubleArray(n) { Double.POSITIVE_INFINITY }" },
        { key: "prim_init", text: "val parent = IntArray(n) { -1 }" },
        { key: "prim_init", text: "val inMST = BooleanArray(n)" },
        { key: "prim_init", text: "key[s] = 0.0" },
        { key: "prim_init", text: "val pq = PriorityQueue<Pair<Double, Int>>(compareBy { it.first })" },
        { key: "prim_init", text: "pq.add(0.0 to s)" },
        { key: "prim_extract", text: "while (pq.isNotEmpty()) {" },
        { key: "prim_extract", text: "  val (key_u, u) = pq.poll()" },
        { key: "prim_extract", text: "  if (inMST[u]) continue" },
        { key: "prim_extract", text: "  inMST[u] = true" },
        { key: "prim_relax", text: "  adj[u].forEach { (v, w) ->" },
        { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u" },
        { key: "prim_relax", text: "          pq.add(key[v] to v)" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "val d = IntArray(n) { Int.MAX_VALUE }" },
        { key: "bfs_init", text: "val parent = IntArray(n) { -1 }" },
        { key: "bfs_init", text: "val visited = BooleanArray(n)" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true; val q = ArrayDeque<Int>(); q.add(s)" },
        { key: "bfs_pop", text: "while (q.isNotEmpty()) {" },
        { key: "bfs_pop", text: "  val u = q.removeFirst()" },
        { key: "bfs_relax", text: "  adj[u].forEach { v ->" },
        { key: "bfs_relax", text: "      if (!visited[v]) {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.add(v)" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "val visited = BooleanArray(n); val parent = IntArray(n) { -1 }" },
        { key: "dfs_init", text: "fun dfs(u: Int) {" },
        { key: "dfs_visit", text: "  visited[u] = true" },
        { key: "dfs_relax", text: "  adj[u].forEach { v ->" },
        { key: "dfs_relax", text: "      if (!visited[v]) {" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v)" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    swift: {
      relaxation: [
        { key: "init", text: "var d = Array(repeating: Double.infinity, count: n)" },
        { key: "init", text: "var parent = Array(repeating: -1, count: n)" },
        { key: "init", text: "d[s] = 0" },
        { key: "relax_outer", text: "for _ in 0..<n - 1 {" },
        { key: "relax", text: "  for (u, v, w) in edges {" },
        { key: "relax", text: "      if d[u] + w < d[v] {" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "var d = Array(repeating: Double.infinity, count: n)" },
        { key: "bf_init", text: "var parent = Array(repeating: -1, count: n)" },
        { key: "bf_init", text: "d[s] = 0" },
        { key: "bf_outer", text: "for _ in 0..<n - 1 {" },
        { key: "bf_relax", text: "  for (u, v, w) in edges {" },
        { key: "bf_relax", text: "      if d[u] + w < d[v] {" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for (u, v, w) in edges {" },
        { key: "bf_neg_cycle", text: "  if d[u] + w < d[v] { print(\"negative cycle\") }" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "var d = Array(repeating: Double.infinity, count: n)" },
        { key: "fifo_init", text: "var parent = Array(repeating: -1, count: n)" },
        { key: "fifo_init", text: "d[s] = 0" },
        { key: "fifo_init", text: "var q = [s]; var inQ = Array(repeating: false, count: n); inQ[s] = true" },
        { key: "fifo_pop", text: "while !q.isEmpty {" },
        { key: "fifo_pop", text: "  let u = q.removeFirst(); inQ[u] = false" },
        { key: "fifo_relax", text: "  for (v, w) in adj[u] {" },
        { key: "fifo_relax", text: "      if d[u] + w < d[v] {" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "fifo_relax", text: "          if !inQ[v] { q.append(v); inQ[v] = true }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
        { key: "fifo_done", text: "// Algorithm completed" },
        { key: "fifo_check", text: "// Check for negative cycles" },
        { key: "fifo_check_edge", text: "for (u, v, w) in edges {" },
        { key: "fifo_neg_cycle", text: "  if d[u] + w < d[v] { print(\"negative cycle\") }" },
        { key: "fifo_check_edge", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "import Foundation" },
        { key: "dijkstra_init", text: "var d = Array(repeating: Double.infinity, count: n)" },
        { key: "dijkstra_init", text: "var parent = Array(repeating: -1, count: n)" },
        { key: "dijkstra_init", text: "d[s] = 0" },
        { key: "dijkstra_init", text: "var pq = [(0.0, s)]" },
        { key: "dijkstra_extract", text: "while !pq.isEmpty {" },
        { key: "dijkstra_extract", text: "  pq.sort { $0.0 < $1.0 }" },
        { key: "dijkstra_extract", text: "  let (dist_u, u) = pq.removeFirst()" },
        { key: "dijkstra_extract", text: "  if dist_u > d[u] { continue }" },
        { key: "dijkstra_relax", text: "  for (v, w) in adj[u] {" },
        { key: "dijkstra_relax", text: "      if d[u] + w < d[v] {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "dijkstra_relax", text: "          pq.append((d[v], v))" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "import Foundation" },
        { key: "prim_init", text: "var key = Array(repeating: Double.infinity, count: n)" },
        { key: "prim_init", text: "var parent = Array(repeating: -1, count: n)" },
        { key: "prim_init", text: "var inMST = Array(repeating: false, count: n)" },
        { key: "prim_init", text: "key[s] = 0" },
        { key: "prim_init", text: "var pq = [(0.0, s)]" },
        { key: "prim_extract", text: "while !pq.isEmpty {" },
        { key: "prim_extract", text: "  pq.sort { $0.0 < $1.0 }" },
        { key: "prim_extract", text: "  let (key_u, u) = pq.removeFirst()" },
        { key: "prim_extract", text: "  if inMST[u] { continue }" },
        { key: "prim_extract", text: "  inMST[u] = true" },
        { key: "prim_relax", text: "  for (v, w) in adj[u] {" },
        { key: "prim_relax", text: "      if !inMST[v] && w < key[v] {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u" },
        { key: "prim_relax", text: "          pq.append((key[v], v))" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "import Foundation" },
        { key: "bfs_init", text: "var d = Array(repeating: Int.max, count: n)" },
        { key: "bfs_init", text: "var parent = Array(repeating: -1, count: n)" },
        { key: "bfs_init", text: "var visited = Array(repeating: false, count: n)" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true; var q = [s]" },
        { key: "bfs_pop", text: "while !q.isEmpty {" },
        { key: "bfs_pop", text: "  let u = q.removeFirst()" },
        { key: "bfs_relax", text: "  for v in adj[u] {" },
        { key: "bfs_relax", text: "      if !visited[v] {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.append(v)" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "var visited = Array(repeating: false, count: n)" },
        { key: "dfs_init", text: "var parent = Array(repeating: -1, count: n)" },
        { key: "dfs_init", text: "func dfs(_ u: Int) {" },
        { key: "dfs_visit", text: "  visited[u] = true" },
        { key: "dfs_relax", text: "  for v in adj[u] {" },
        { key: "dfs_relax", text: "      if !visited[v] {" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v)" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    csharp: {
      relaxation: [
        { key: "init", text: "double[] d = new double[n]; int[] parent = new int[n];" },
        { key: "init", text: "Array.Fill(d, double.PositiveInfinity); Array.Fill(parent, -1); d[s] = 0;" },
        { key: "relax_outer", text: "for (int i = 0; i < n - 1; i++) {" },
        { key: "relax", text: "  foreach (var (u, v, w) in edges) {" },
        { key: "relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "double[] d = new double[n]; int[] parent = new int[n];" },
        { key: "bf_init", text: "Array.Fill(d, double.PositiveInfinity); Array.Fill(parent, -1); d[s] = 0;" },
        { key: "bf_outer", text: "for (int i = 0; i < n - 1; i++) {" },
        { key: "bf_relax", text: "  foreach (var (u, v, w) in edges) {" },
        { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "foreach (var (u, v, w) in edges) {" },
        { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) Console.WriteLine(\"negative cycle\");" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "double[] d = new double[n]; int[] parent = new int[n]; bool[] inQ = new bool[n];" },
        { key: "fifo_init", text: "Array.Fill(d, double.PositiveInfinity); Array.Fill(parent, -1); d[s] = 0;" },
        { key: "fifo_init", text: "var q = new Queue<int>(); q.Enqueue(s); inQ[s] = true;" },
        { key: "fifo_pop", text: "while (q.Count > 0) {" },
        { key: "fifo_pop", text: "  int u = q.Dequeue(); inQ[u] = false;" },
        { key: "fifo_relax", text: "  foreach (var (v, w) in adj[u]) {" },
        { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "fifo_relax", text: "          if (!inQ[v]) { q.Enqueue(v); inQ[v] = true; }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
        { key: "fifo_done", text: "// Algorithm completed" },
        { key: "fifo_check", text: "// Check for negative cycles" },
        { key: "fifo_check_edge", text: "foreach (var (u, v, w) in edges) {" },
        { key: "fifo_neg_cycle", text: "  if (d[u] + w < d[v]) Console.WriteLine(\"negative cycle\");" },
        { key: "fifo_check_edge", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "using System.Collections.Generic;" },
        { key: "dijkstra_init", text: "double[] d = new double[n]; int[] parent = new int[n];" },
        { key: "dijkstra_init", text: "Array.Fill(d, double.PositiveInfinity); Array.Fill(parent, -1);" },
        { key: "dijkstra_init", text: "d[s] = 0;" },
        { key: "dijkstra_init", text: "var pq = new PriorityQueue<int, double>();" },
        { key: "dijkstra_init", text: "pq.Enqueue(s, 0);" },
        { key: "dijkstra_extract", text: "while (pq.Count > 0) {" },
        { key: "dijkstra_extract", text: "  pq.TryDequeue(out int u, out double dist_u);" },
        { key: "dijkstra_extract", text: "  if (dist_u > d[u]) continue;" },
        { key: "dijkstra_relax", text: "  foreach (var (v, w) in adj[u]) {" },
        { key: "dijkstra_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "dijkstra_relax", text: "          pq.Enqueue(v, d[v]);" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "using System.Collections.Generic;" },
        { key: "prim_init", text: "double[] key = new double[n]; int[] parent = new int[n]; bool[] inMST = new bool[n];" },
        { key: "prim_init", text: "Array.Fill(key, double.PositiveInfinity); Array.Fill(parent, -1); key[s] = 0;" },
        { key: "prim_init", text: "var pq = new PriorityQueue<int, double>(); pq.Enqueue(s, 0);" },
        { key: "prim_extract", text: "while (pq.Count > 0) {" },
        { key: "prim_extract", text: "  pq.TryDequeue(out int u, out double key_u);" },
        { key: "prim_extract", text: "  if (inMST[u]) continue;" },
        { key: "prim_extract", text: "  inMST[u] = true;" },
        { key: "prim_relax", text: "  foreach (var (v, w) in adj[u]) {" },
        { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
        { key: "prim_relax", text: "          pq.Enqueue(v, key[v]);" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "using System.Collections.Generic;" },
        { key: "bfs_init", text: "int[] d = new int[n]; int[] parent = new int[n]; bool[] visited = new bool[n];" },
        { key: "bfs_init", text: "Array.Fill(d, int.MaxValue); Array.Fill(parent, -1); d[s] = 0; visited[s] = true;" },
        { key: "bfs_init", text: "Queue<int> q = new Queue<int>(); q.Enqueue(s);" },
        { key: "bfs_pop", text: "while (q.Count > 0) {" },
        { key: "bfs_pop", text: "  int u = q.Dequeue();" },
        { key: "bfs_relax", text: "  foreach (int v in adj[u]) {" },
        { key: "bfs_relax", text: "      if (!visited[v]) {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.Enqueue(v);" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "bool[] visited = new bool[n]; int[] parent = new int[n];" },
        { key: "dfs_init", text: "Array.Fill(parent, -1);" },
        { key: "dfs_init", text: "void Dfs(int u) {" },
        { key: "dfs_visit", text: "  visited[u] = true;" },
        { key: "dfs_relax", text: "  foreach (int v in adj[u]) {" },
        { key: "dfs_relax", text: "      if (!visited[v]) {" },
        { key: "dfs_relax", text: "          parent[v] = u; Dfs(v);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    ruby: {
      relaxation: [
        { key: "init", text: "d = Array.new(n, Float::INFINITY); parent = Array.new(n, nil)" },
        { key: "init", text: "d[s] = 0" },
        { key: "relax_outer", text: "(n - 1).times do" },
        { key: "relax", text: "  edges.each do |u, v, w|" },
        { key: "relax", text: "      if d[u] + w < d[v]" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "relax", text: "      end" },
        { key: "relax", text: "  end" },
        { key: "relax_outer", text: "end" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "d = Array.new(n, Float::INFINITY); parent = Array.new(n, nil)" },
        { key: "bf_init", text: "d[s] = 0" },
        { key: "bf_outer", text: "(n - 1).times do" },
        { key: "bf_relax", text: "  edges.each do |u, v, w|" },
        { key: "bf_relax", text: "      if d[u] + w < d[v]" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "bf_relax", text: "      end" },
        { key: "bf_relax", text: "  end" },
        { key: "bf_outer", text: "end" },
        { key: "bf_check", text: "edges.each do |u, v, w|" },
        { key: "bf_neg_cycle", text: "  puts 'negative cycle' if d[u] + w < d[v]" },
        { key: "bf_check", text: "end" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "d = Array.new(n, Float::INFINITY); parent = Array.new(n, nil)" },
        { key: "fifo_init", text: "d[s] = 0" },
        { key: "fifo_init", text: "q = [s]; in_q = Array.new(n, false); in_q[s] = true" },
        { key: "fifo_pop", text: "until q.empty?" },
        { key: "fifo_pop", text: "  u = q.shift; in_q[u] = false" },
        { key: "fifo_relax", text: "  adj[u].each do |v, w|" },
        { key: "fifo_relax", text: "      if d[u] + w < d[v]" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "fifo_relax", text: "          unless in_q[v]; q << v; in_q[v] = true end" },
        { key: "fifo_relax", text: "      end" },
        { key: "fifo_relax", text: "  end" },
        { key: "fifo_pop", text: "end" },
        { key: "fifo_done", text: "# Algorithm completed" },
        { key: "fifo_check", text: "# Check for negative cycles" },
        { key: "fifo_check_edge", text: "edges.each do |u, v, w|" },
        { key: "fifo_neg_cycle", text: "  puts 'negative cycle' if d[u] + w < d[v]" },
        { key: "fifo_check_edge", text: "end" },
      ],
      bfs: [
        { key: "bfs_init", text: "require 'set'" },
        { key: "bfs_init", text: "d = Hash.new(Float::INFINITY); parent = {}; visited = Set.new" },
        { key: "bfs_init", text: "d[s] = 0; visited.add(s); q = [s]" },
        { key: "bfs_pop", text: "until q.empty?" },
        { key: "bfs_pop", text: "  u = q.shift" },
        { key: "bfs_relax", text: "  adj[u].each do |v, _|" },
        { key: "bfs_relax", text: "      unless visited.include?(v)" },
        { key: "bfs_relax", text: "          visited.add(v); d[v] = d[u] + 1; parent[v] = u; q << v" },
        { key: "bfs_relax", text: "      end" },
        { key: "bfs_relax", text: "  end" },
        { key: "bfs_pop", text: "end" },
      ],
      prim: [
        { key: "prim_init", text: "require 'set'" },
        { key: "prim_init", text: "key = Hash.new(Float::INFINITY); parent = {}; in_mst = Set.new" },
        { key: "prim_init", text: "key[s] = 0" },
        { key: "prim_init", text: "pq = [[0, s]]" },
        { key: "prim_extract", text: "until pq.empty?" },
        { key: "prim_extract", text: "  pq.sort_by! { |x| x[0] }" },
        { key: "prim_extract", text: "  key_u, u = pq.shift" },
        { key: "prim_extract", text: "  next if in_mst.include?(u)" },
        { key: "prim_extract", text: "  in_mst.add(u)" },
        { key: "prim_relax", text: "  adj[u].each do |v, w|" },
        { key: "prim_relax", text: "      unless in_mst.include?(v)" },
        { key: "prim_relax", text: "          if w < key[v]" },
        { key: "prim_relax", text: "              key[v] = w; parent[v] = u; pq << [key[v], v]" },
        { key: "prim_relax", text: "          end" },
        { key: "prim_relax", text: "      end" },
        { key: "prim_relax", text: "  end" },
        { key: "prim_extract", text: "end" },
        { key: "prim_done", text: "# MST constructed" },
      ],
      dfs: [
        { key: "dfs_init", text: "visited = Set.new; parent = {}" },
        { key: "dfs_init", text: "def dfs(u)" },
        { key: "dfs_visit", text: "  visited.add(u)" },
        { key: "dfs_relax", text: "  adj[u].each do |v, _|" },
        { key: "dfs_relax", text: "      unless visited.include?(v)" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v)" },
        { key: "dfs_relax", text: "      end" },
        { key: "dfs_relax", text: "  end" },
        { key: "dfs_visit", text: "end" },
      ],
    },
    php: {
      relaxation: [
        { key: "init", text: "$d = array_fill(0, $n, INF); $parent = array_fill(0, $n, null);" },
        { key: "init", text: "$d[$s] = 0;" },
        { key: "relax_outer", text: "for ($i = 0; $i < $n - 1; $i++) {" },
        { key: "relax", text: "  foreach ($edges as [$u, $v, $w]) {" },
        { key: "relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
        { key: "relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "$d = array_fill(0, $n, INF); $parent = array_fill(0, $n, null);" },
        { key: "bf_init", text: "$d[$s] = 0;" },
        { key: "bf_outer", text: "for ($i = 0; $i < $n - 1; $i++) {" },
        { key: "bf_relax", text: "  foreach ($edges as [$u, $v, $w]) {" },
        { key: "bf_relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
        { key: "bf_relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "foreach ($edges as [$u, $v, $w]) {" },
        { key: "bf_neg_cycle", text: "  if ($d[$u] + $w < $d[$v]) echo 'negative cycle';" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "$d = array_fill(0, $n, INF); $parent = array_fill(0, $n, null);" },
        { key: "fifo_init", text: "$d[$s] = 0;" },
        { key: "fifo_init", text: "$q = [$s]; $inQ = array_fill(0, $n, false); $inQ[$s] = true;" },
        { key: "fifo_pop", text: "while (!empty($q)) {" },
        { key: "fifo_pop", text: "  $u = array_shift($q); $inQ[$u] = false;" },
        { key: "fifo_relax", text: "  foreach ($adj[$u] as [$v, $w]) {" },
        { key: "fifo_relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
        { key: "fifo_relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
        { key: "fifo_relax", text: "          if (!$inQ[$v]) { $q[] = $v; $inQ[$v] = true; }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
        { key: "fifo_done", text: "// Algorithm completed" },
        { key: "fifo_check", text: "// Check for negative cycles" },
        { key: "fifo_check_edge", text: "foreach ($edges as [$u, $v, $w]) {" },
        { key: "fifo_neg_cycle", text: "  if ($d[$u] + $w < $d[$v]) echo 'negative cycle';" },
        { key: "fifo_check_edge", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "$d = array_fill(0, $n, INF); $parent = array_fill(0, $n, -1);" },
        { key: "dijkstra_init", text: "$d[$s] = 0;" },
        { key: "dijkstra_init", text: "$pq = new SplPriorityQueue(); $pq->setExtractFlags(SplPriorityQueue::EXTR_BOTH);" },
        { key: "dijkstra_init", text: "$pq->insert($s, 0);" },
        { key: "dijkstra_extract", text: "while (!$pq->isEmpty()) {" },
        { key: "dijkstra_extract", text: "  $item = $pq->extract(); $u = $item['data']; $dist_u = -$item['priority'];" },
        { key: "dijkstra_extract", text: "  if ($dist_u > $d[$u]) continue;" },
        { key: "dijkstra_relax", text: "  foreach ($adj[$u] as $v => $w) {" },
        { key: "dijkstra_relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
        { key: "dijkstra_relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
        { key: "dijkstra_relax", text: "          $pq->insert($v, -$d[$v]);" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "$key = array_fill(0, $n, INF); $parent = array_fill(0, $n, -1); $inMST = array_fill(0, $n, false);" },
        { key: "prim_init", text: "$key[$s] = 0;" },
        { key: "prim_init", text: "$pq = [[0, $s]];" },
        { key: "prim_extract", text: "while (!empty($pq)) {" },
        { key: "prim_extract", text: "  usort($pq, function($a, $b) { return $a[0] - $b[0]; });" },
        { key: "prim_extract", text: "  list($key_u, $u) = array_shift($pq);" },
        { key: "prim_extract", text: "  if ($inMST[$u]) continue;" },
        { key: "prim_extract", text: "  $inMST[$u] = true;" },
        { key: "prim_relax", text: "  foreach ($adj[$u] as [$v, $w]) {" },
        { key: "prim_relax", text: "      if (!$inMST[$v] && $w < $key[$v]) {" },
        { key: "prim_relax", text: "          $key[$v] = $w; $parent[$v] = $u;" },
        { key: "prim_relax", text: "          array_push($pq, [$key[$v], $v]);" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "$d = array_fill(0, $n, INF); $parent = array_fill(0, $n, -1); $visited = array_fill(0, $n, false);" },
        { key: "bfs_init", text: "$d[$s] = 0; $visited[$s] = true; $q = [$s];" },
        { key: "bfs_pop", text: "while (!empty($q)) {" },
        { key: "bfs_pop", text: "  $u = array_shift($q);" },
        { key: "bfs_relax", text: "  foreach ($adj[$u] as $v) {" },
        { key: "bfs_relax", text: "      if (!$visited[$v]) {" },
        { key: "bfs_relax", text: "          $visited[$v] = true; $d[$v] = $d[$u] + 1; $parent[$v] = $u; array_push($q, $v);" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "$visited = array_fill(0, $n, false); $parent = array_fill(0, $n, -1);" },
        { key: "dfs_init", text: "function dfs($u) {" },
        { key: "dfs_visit", text: "  $visited[$u] = true;" },
        { key: "dfs_relax", text: "  foreach ($adj[$u] as $v) {" },
        { key: "dfs_relax", text: "      if (!$visited[$v]) {" },
        { key: "dfs_relax", text: "          $parent[$v] = $u; dfs($v);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    scala: {
      relaxation: [
        { key: "init", text: "val d = Array.fill(n)(Double.PositiveInfinity); val parent = Array.fill(n)(-1)" },
        { key: "init", text: "d(s) = 0" },
        { key: "relax_outer", text: "for (_ <- 0 until n - 1) {" },
        { key: "relax", text: "  edges.foreach { case (u, v, w) =>" },
        { key: "relax", text: "      if (d(u) + w < d(v)) {" },
        { key: "relax", text: "          d(v) = d(u) + w; parent(v) = u" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "val d = Array.fill(n)(Double.PositiveInfinity); val parent = Array.fill(n)(-1)" },
        { key: "bf_init", text: "d(s) = 0" },
        { key: "bf_outer", text: "for (_ <- 0 until n - 1) {" },
        { key: "bf_relax", text: "  edges.foreach { case (u, v, w) =>" },
        { key: "bf_relax", text: "      if (d(u) + w < d(v)) {" },
        { key: "bf_relax", text: "          d(v) = d(u) + w; parent(v) = u" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "edges.foreach { case (u, v, w) =>" },
        { key: "bf_neg_cycle", text: "  if (d(u) + w < d(v)) println(\"negative cycle\")" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "val d = Array.fill(n)(Double.PositiveInfinity); val parent = Array.fill(n)(-1)" },
        { key: "fifo_init", text: "d(s) = 0" },
        { key: "fifo_init", text: "import scala.collection.mutable.Queue" },
        { key: "fifo_init", text: "val q = Queue(s); val inQ = Array.fill(n)(false); inQ(s) = true" },
        { key: "fifo_pop", text: "while (q.nonEmpty) {" },
        { key: "fifo_pop", text: "  val u = q.dequeue(); inQ(u) = false" },
        { key: "fifo_relax", text: "  adj(u).foreach { case (v, w) =>" },
        { key: "fifo_relax", text: "      if (d(u) + w < d(v)) {" },
        { key: "fifo_relax", text: "          d(v) = d(u) + w; parent(v) = u" },
        { key: "fifo_relax", text: "          if (!inQ(v)) { q.enqueue(v); inQ(v) = true }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
        { key: "fifo_done", text: "// Algorithm completed" },
        { key: "fifo_check", text: "// Check for negative cycles" },
        { key: "fifo_check_edge", text: "edges.foreach { case (u, v, w) =>" },
        { key: "fifo_neg_cycle", text: "  if (d(u) + w < d(v)) println(\"negative cycle\")" },
        { key: "fifo_check_edge", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "import scala.collection.mutable" },
        { key: "dijkstra_init", text: "val d = Array.fill(n)(Double.PositiveInfinity)" },
        { key: "dijkstra_init", text: "val parent = Array.fill(n)(-1)" },
        { key: "dijkstra_init", text: "d(s) = 0.0" },
        { key: "dijkstra_init", text: "val pq = mutable.PriorityQueue((0.0, s))(Ordering.by(-_._1))" },
        { key: "dijkstra_extract", text: "while (pq.nonEmpty) {" },
        { key: "dijkstra_extract", text: "  val (dist_u, u) = pq.dequeue" },
        { key: "dijkstra_extract", text: "  if (dist_u > d(u)) return" },
        { key: "dijkstra_relax", text: "  adj(u).foreach { case (v, w) =>" },
        { key: "dijkstra_relax", text: "      if (d(u) + w < d(v)) {" },
        { key: "dijkstra_relax", text: "          d(v) = d(u) + w; parent(v) = u" },
        { key: "dijkstra_relax", text: "          pq.enqueue((d(v), v))" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "import scala.collection.mutable" },
        { key: "prim_init", text: "val key = Array.fill(n)(Double.PositiveInfinity)" },
        { key: "prim_init", text: "val parent = Array.fill(n)(-1)" },
        { key: "prim_init", text: "val inMST = Array.fill(n)(false)" },
        { key: "prim_init", text: "key(s) = 0.0" },
        { key: "prim_init", text: "val pq = mutable.PriorityQueue((0.0, s))(Ordering.by(-_._1))" },
        { key: "prim_extract", text: "while (pq.nonEmpty) {" },
        { key: "prim_extract", text: "  val (key_u, u) = pq.dequeue" },
        { key: "prim_extract", text: "  if (inMST(u)) return" },
        { key: "prim_extract", text: "  inMST(u) = true" },
        { key: "prim_relax", text: "  adj(u).foreach { case (v, w) =>" },
        { key: "prim_relax", text: "      if (!inMST(v) && w < key(v)) {" },
        { key: "prim_relax", text: "          key(v) = w; parent(v) = u" },
        { key: "prim_relax", text: "          pq.enqueue((key(v), v))" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "import scala.collection.mutable" },
        { key: "bfs_init", text: "val d = Array.fill(n)(Int.MaxValue)" },
        { key: "bfs_init", text: "val parent = Array.fill(n)(-1)" },
        { key: "bfs_init", text: "val visited = Array.fill(n)(false)" },
        { key: "bfs_init", text: "d(s) = 0; visited(s) = true; val q = mutable.Queue(s)" },
        { key: "bfs_pop", text: "while (q.nonEmpty) {" },
        { key: "bfs_pop", text: "  val u = q.dequeue" },
        { key: "bfs_relax", text: "  adj(u).foreach { v =>" },
        { key: "bfs_relax", text: "      if (!visited(v)) {" },
        { key: "bfs_relax", text: "          visited(v) = true; d(v) = d(u) + 1; parent(v) = u; q.enqueue(v)" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "val visited = Array.fill(n)(false); val parent = Array.fill(n)(-1)" },
        { key: "dfs_init", text: "def dfs(u: Int): Unit = {" },
        { key: "dfs_visit", text: "  visited(u) = true" },
        { key: "dfs_relax", text: "  adj(u).foreach { v =>" },
        { key: "dfs_relax", text: "      if (!visited(v)) {" },
        { key: "dfs_relax", text: "          parent(v) = u; dfs(v)" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    haskell: {
      relaxation: [
        { key: "init", text: "d = replicate n (1/0) :: [Double]" },
        { key: "init", text: "parent = replicate n Nothing :: [Maybe Int]" },
        { key: "init", text: "d' = take s d ++ [0] ++ drop (s+1) d" },
        { key: "relax_outer", text: "relaxAll edges dist par = foldl relax (dist, par) edges" },
        { key: "relax", text: "relax (d, p) (u, v, w) | d!!u + w < d!!v = (update d v (d!!u + w), update p v (Just u))" },
        { key: "relax", text: "                | otherwise = (d, p)" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "d = replicate n (1/0) :: [Double]" },
        { key: "bf_init", text: "parent = replicate n Nothing :: [Maybe Int]" },
        { key: "bf_init", text: "d' = take s d ++ [0] ++ drop (s+1) d" },
        { key: "bf_outer", text: "bf dist par = foldl (\\acc _ -> relaxAll edges acc) (dist, par) [1..n-1]" },
        { key: "bf_relax", text: "relaxAll edges (d, p) = foldl relax (d, p) edges" },
        { key: "bf_relax", text: "relax (d, p) (u, v, w) | d!!u + w < d!!v = (update d v (d!!u + w), update p v (Just u))" },
        { key: "bf_relax", text: "                | otherwise = (d, p)" },
        { key: "bf_check", text: "hasNegCycle edges d = any (\\(u, v, w) -> d!!u + w < d!!v) edges" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "d = replicate n (1/0) :: [Double]" },
        { key: "fifo_init", text: "parent = replicate n Nothing :: [Maybe Int]" },
        { key: "fifo_init", text: "d' = take s d ++ [0] ++ drop (s+1) d" },
        { key: "fifo_init", text: "q = [s]; inQ = replicate n False" },
        { key: "fifo_pop", text: "bfFIFO q inQ d p | null q = (d, p)" },
        { key: "fifo_pop", text: "              | otherwise = let (u:qs) = q in process u qs" },
        { key: "fifo_relax", text: "process u qs = foldl relaxEdge (qs, d, p) (adj u)" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "import Data.Heap (MinHeap, empty, insert, view)" },
        { key: "dijkstra_init", text: "import qualified Data.Heap as H" },
        { key: "dijkstra_init", text: "let d = replicate n (1/0) in let parent = replicate n (-1) in" },
        { key: "dijkstra_init", text: "let d' = update d s 0 in" },
        { key: "dijkstra_init", text: "let pq = H.singleton (0, s) in" },
        { key: "dijkstra_extract", text: "dijkstra d parent pq = case H.view pq of" },
        { key: "dijkstra_extract", text: "  Nothing -> (d, parent)" },
        { key: "dijkstra_extract", text: "  Just ((dist_u, u), pq') ->" },
        { key: "dijkstra_extract", text: "    if dist_u > d !! u then dijkstra d parent pq'" },
        { key: "dijkstra_relax", text: "    else let relax (v, w) (d'', parent'', pq'') =" },
        { key: "dijkstra_relax", text: "            if d'' !! u + w < d'' !! v then" },
        { key: "dijkstra_relax", text: "              (update d'' v (d'' !! u + w), update parent'' v u, H.insert (d'' !! u + w, v) pq'')" },
        { key: "dijkstra_relax", text: "            else (d'', parent'', pq'')" },
        { key: "dijkstra_relax", text: "          in foldr relax (d, parent, pq') (adj !! u)" },
      ],
      prim: [
        { key: "prim_init", text: "import Data.Heap (MinHeap, empty, insert, view)" },
        { key: "prim_init", text: "import qualified Data.Heap as H" },
        { key: "prim_init", text: "let key = replicate n (1/0) in let parent = replicate n (-1) in" },
        { key: "prim_init", text: "let key' = update key s 0 in" },
        { key: "prim_init", text: "let pq = H.singleton (0, s) in" },
        { key: "prim_extract", text: "prim key parent pq = case H.view pq of" },
        { key: "prim_extract", text: "  Nothing -> (key, parent)" },
        { key: "prim_extract", text: "  Just ((key_u, u), pq') ->" },
        { key: "prim_extract", text: "    if inMST u then prim key parent pq'" },
        { key: "prim_relax", text: "    else let relax (v, w) (key'', parent'', pq'') =" },
        { key: "prim_relax", text: "            if not (inMST v) && w < key'' !! v then" },
        { key: "prim_relax", text: "              (update key'' v w, update parent'' v u, H.insert (w, v) pq'')" },
        { key: "prim_relax", text: "            else (key'', parent'', pq'')" },
        { key: "prim_relax", text: "          in foldr relax (key, parent, pq') (adj !! u)" },
        { key: "prim_done", text: "-- MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "import Data.Sequence (Seq, (|>), (<|), empty, null)" },
        { key: "bfs_init", text: "d = replicate n maxBound :: [Int]" },
        { key: "bfs_init", text: "parent = replicate n Nothing :: [Maybe Int]" },
        { key: "bfs_init", text: "visited = replicate n False" },
        { key: "bfs_init", text: "d' = take s d ++ [0] ++ drop (s+1) d" },
        { key: "bfs_init", text: "visited' = take s visited ++ [True] ++ drop (s+1) visited" },
        { key: "bfs_init", text: "q = s <| empty" },
        { key: "bfs_pop", text: "bfs d parent visited q | null q = (d, parent)" },
        { key: "bfs_pop", text: "              | otherwise = let (u :< qs) = viewl q in process u qs" },
        { key: "bfs_relax", text: "process u qs = foldl relax (qs, d, parent, visited) (adj u)" },
        { key: "bfs_relax", text: "relax (q, d, p, v) n | not (v !! n) = (n <| q, update d n (d !! u + 1), update p n (Just u), update v n True)" },
        { key: "bfs_relax", text: "                | otherwise = (q, d, p, v)" },
      ],
      dfs: [
        { key: "dfs_init", text: "visited = replicate n False :: [Bool]" },
        { key: "dfs_init", text: "parent = replicate n Nothing :: [Maybe Int]" },
        { key: "dfs_init", text: "dfs u visited parent = let visited' = update visited u True in" },
        { key: "dfs_visit", text: "  foldl (\\acc v -> if not (visited !! v) then dfs v (update acc v True) (update parent v (Just u)) else acc) visited' (adj u)" },
      ],
    },
    ocaml: {
      relaxation: [
        { key: "init", text: "let d = Array.make n infinity in" },
        { key: "init", text: "let parent = Array.make n None in" },
        { key: "init", text: "d.(s) <- 0.0;" },
        { key: "relax_outer", text: "for _ = 0 to n - 2 do" },
        { key: "relax", text: "  List.iter (fun (u, v, w) ->" },
        { key: "relax", text: "      if d.(u) +. w < d.(v) then (" },
        { key: "relax", text: "          d.(v) <- d.(u) +. w; parent.(v) <- Some u" },
        { key: "relax", text: "      )" },
        { key: "relax", text: "  ) edges" },
        { key: "relax_outer", text: "done" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "let d = Array.make n infinity in" },
        { key: "bf_init", text: "let parent = Array.make n None in" },
        { key: "bf_init", text: "d.(s) <- 0.0;" },
        { key: "bf_outer", text: "for _ = 0 to n - 2 do" },
        { key: "bf_relax", text: "  List.iter (fun (u, v, w) ->" },
        { key: "bf_relax", text: "      if d.(u) +. w < d.(v) then (" },
        { key: "bf_relax", text: "          d.(v) <- d.(u) +. w; parent.(v) <- Some u" },
        { key: "bf_relax", text: "      )" },
        { key: "bf_relax", text: "  ) edges" },
        { key: "bf_outer", text: "done" },
        { key: "bf_check", text: "List.iter (fun (u, v, w) ->" },
        { key: "bf_neg_cycle", text: "  if d.(u) +. w < d.(v) then print_string \"negative cycle\"" },
        { key: "bf_check", text: ") edges" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "let d = Array.make n infinity in" },
        { key: "fifo_init", text: "let parent = Array.make n None in" },
        { key: "fifo_init", text: "d.(s) <- 0.0;" },
        { key: "fifo_init", text: "let q = Queue.create () in" },
        { key: "fifo_init", text: "let in_q = Array.make n false in" },
        { key: "fifo_init", text: "Queue.push s q; in_q.(s) <- true;" },
        { key: "fifo_pop", text: "while not (Queue.is_empty q) do" },
        { key: "fifo_pop", text: "  let u = Queue.pop q in in_q.(u) <- false;" },
        { key: "fifo_relax", text: "  List.iter (fun (v, w) ->" },
        { key: "fifo_relax", text: "      if d.(u) +. w < d.(v) then (" },
        { key: "fifo_relax", text: "          d.(v) <- d.(u) +. w; parent.(v) <- Some u;" },
        { key: "fifo_relax", text: "          if not in_q.(v) then (Queue.push v q; in_q.(v) <- true)" },
        { key: "fifo_relax", text: "      )" },
        { key: "fifo_relax", text: "  ) adj.(u)" },
        { key: "fifo_pop", text: "done" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "module Heap = BatHeap" },
        { key: "dijkstra_init", text: "let d = Array.make n infinity in" },
        { key: "dijkstra_init", text: "let parent = Array.make n (-1) in" },
        { key: "dijkstra_init", text: "d.(s) <- 0.0;" },
        { key: "dijkstra_init", text: "let pq = Heap.empty |> Heap.insert (0.0, s) in" },
        { key: "dijkstra_extract", text: "let rec dijkstra d parent pq = match Heap.find_min pq with" },
        { key: "dijkstra_extract", text: "  | None -> (d, parent)" },
        { key: "dijkstra_extract", text: "  | Some (dist_u, u) ->" },
        { key: "dijkstra_extract", text: "    let pq' = Heap.delete_min pq in" },
        { key: "dijkstra_extract", text: "    if dist_u > d.(u) then dijkstra d parent pq'" },
        { key: "dijkstra_relax", text: "    else let relax (v, w) (d'', parent'', pq'') =" },
        { key: "dijkstra_relax", text: "            if d''.(u) +. w < d''.(v) then" },
        { key: "dijkstra_relax", text: "              (d''.(v) <- d''.(u) +. w; parent''.(v) <- u; Heap.insert (d''.(v), v) pq'')" },
        { key: "dijkstra_relax", text: "            else (d'', parent'', pq'')" },
        { key: "dijkstra_relax", text: "        in List.fold_right relax adj.(u) (d, parent, pq')" },
      ],
      prim: [
        { key: "prim_init", text: "module Heap = BatHeap" },
        { key: "prim_init", text: "let key = Array.make n infinity in" },
        { key: "prim_init", text: "let parent = Array.make n (-1) in" },
        { key: "prim_init", text: "let in_mst = Array.make n false in" },
        { key: "prim_init", text: "key.(s) <- 0.0;" },
        { key: "prim_init", text: "let pq = Heap.empty |> Heap.insert (0.0, s) in" },
        { key: "prim_extract", text: "let rec prim key parent in_mst pq = match Heap.find_min pq with" },
        { key: "prim_extract", text: "  | None -> (key, parent)" },
        { key: "prim_extract", text: "  | Some (key_u, u) ->" },
        { key: "prim_extract", text: "    let pq' = Heap.delete_min pq in" },
        { key: "prim_extract", text: "    if in_mst.(u) then prim key parent in_mst pq'" },
        { key: "prim_extract", text: "    else (in_mst.(u) <- true;" },
        { key: "prim_relax", text: "     let relax (v, w) (key'', parent'', pq'') =" },
        { key: "prim_relax", text: "            if not in_mst.(v) && w < key''.(v) then" },
        { key: "prim_relax", text: "              (key''.(v) <- w; parent''.(v) <- u; Heap.insert (w, v) pq'')" },
        { key: "prim_relax", text: "            else (key'', parent'', pq'')" },
        { key: "prim_relax", text: "     in List.fold_right relax adj.(u) (key, parent, pq'))" },
        { key: "prim_done", text: "(* MST constructed *)" },
      ],
      bfs: [
        { key: "bfs_init", text: "module Queue = BatQueue" },
        { key: "bfs_init", text: "let d = Array.make n max_int in" },
        { key: "bfs_init", text: "let parent = Array.make n None in" },
        { key: "bfs_init", text: "let visited = Array.make n false in" },
        { key: "bfs_init", text: "d.(s) <- 0; visited.(s) <- true;" },
        { key: "bfs_init", text: "let q = Queue.empty |> Queue.push s in" },
        { key: "bfs_pop", text: "let rec bfs d parent visited q = match Queue.is_empty q with" },
        { key: "bfs_pop", text: "  | true -> (d, parent)" },
        { key: "bfs_pop", text: "  | false -> let (u, q') = Queue.pop q in process u q' d parent visited" },
        { key: "bfs_relax", text: "and process u q d parent visited = List.fold_left (fun (q', d', p', v') v ->" },
        { key: "bfs_relax", text: "    if not v'.(v) then (Queue.push v q', d'.(v) <- d'.(u) + 1; p'.(v) <- Some u; v'.(v) <- true; (q', d', p', v'))" },
        { key: "bfs_relax", text: "    else (q', d', p', v')) (q, d, parent, visited) (adj u)" },
      ],
      dfs: [
        { key: "dfs_init", text: "let visited = Array.make n false in" },
        { key: "dfs_init", text: "let parent = Array.make n None in" },
        { key: "dfs_init", text: "let rec dfs u visited parent =" },
        { key: "dfs_visit", text: "  visited.(u) <- true;" },
        { key: "dfs_relax", text: "  List.iter (fun v ->" },
        { key: "dfs_relax", text: "      if not visited.(v) then (parent.(v) <- Some u; dfs v visited parent)" },
        { key: "dfs_relax", text: "  ) (adj u)" },
      ],
    },
    fsharp: {
      relaxation: [
        { key: "init", text: "let d = Array.create n System.Double.PositiveInfinity" },
        { key: "init", text: "let parent = Array.create n None" },
        { key: "init", text: "d.[s] <- 0.0" },
        { key: "relax_outer", text: "for _ in 0 .. n - 2 do" },
        { key: "relax", text: "  edges |> List.iter (fun (u, v, w) ->" },
        { key: "relax", text: "      if d.[u] + w < d.[v] then (" },
        { key: "relax", text: "          d.[v] <- d.[u] + w; parent.[v] <- Some u" },
        { key: "relax", text: "      )" },
        { key: "relax", text: "  )" },
        { key: "relax_outer", text: "done" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "let d = Array.create n System.Double.PositiveInfinity" },
        { key: "bf_init", text: "let parent = Array.create n None" },
        { key: "bf_init", text: "d.[s] <- 0.0" },
        { key: "bf_outer", text: "for _ in 0 .. n - 2 do" },
        { key: "bf_relax", text: "  edges |> List.iter (fun (u, v, w) ->" },
        { key: "bf_relax", text: "      if d.[u] + w < d.[v] then (" },
        { key: "bf_relax", text: "          d.[v] <- d.[u] + w; parent.[v] <- Some u" },
        { key: "bf_relax", text: "      )" },
        { key: "bf_relax", text: "  )" },
        { key: "bf_outer", text: "done" },
        { key: "bf_check", text: "edges |> List.iter (fun (u, v, w) ->" },
        { key: "bf_neg_cycle", text: "  if d.[u] + w < d.[v] then printfn \"negative cycle\"" },
        { key: "bf_check", text: ")" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "let d = Array.create n System.Double.PositiveInfinity" },
        { key: "fifo_init", text: "let parent = Array.create n None" },
        { key: "fifo_init", text: "d.[s] <- 0.0" },
        { key: "fifo_init", text: "let q = System.Collections.Generic.Queue<int>()" },
        { key: "fifo_init", text: "let inQ = Array.create n false" },
        { key: "fifo_init", text: "q.Enqueue(s); inQ.[s] <- true" },
        { key: "fifo_pop", text: "while q.Count > 0 do" },
        { key: "fifo_pop", text: "  let u = q.Dequeue() in inQ.[u] <- false" },
        { key: "fifo_relax", text: "  adj.[u] |> List.iter (fun (v, w) ->" },
        { key: "fifo_relax", text: "      if d.[u] + w < d.[v] then (" },
        { key: "fifo_relax", text: "          d.[v] <- d.[u] + w; parent.[v] <- Some u;" },
        { key: "fifo_relax", text: "          if not inQ.[v] then (q.Enqueue(v); inQ.[v] <- true)" },
        { key: "fifo_relax", text: "      )" },
        { key: "fifo_relax", text: "  )" },
        { key: "fifo_pop", text: "done" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "open System.Collections.Generic" },
        { key: "dijkstra_init", text: "let d = Array.create n System.Double.MaxValue" },
        { key: "dijkstra_init", text: "let parent = Array.create n -1" },
        { key: "dijkstra_init", text: "d.[s] <- 0.0" },
        { key: "dijkstra_init", text: "let pq = SortedSet<(float * int)>(compare)" },
        { key: "dijkstra_init", text: "pq.Add((0.0, s)) |> ignore" },
        { key: "dijkstra_extract", text: "while pq.Count > 0 do" },
        { key: "dijkstra_extract", text: "  let (dist_u, u) = pq.Min; pq.Remove((dist_u, u)) |> ignore" },
        { key: "dijkstra_extract", text: "  if dist_u > d.[u] then ()" },
        { key: "dijkstra_relax", text: "  else adj.[u] |> List.iter (fun (v, w) ->" },
        { key: "dijkstra_relax", text: "      if d.[u] + w < d.[v] then" },
        { key: "dijkstra_relax", text: "        d.[v] <- d.[u] + w; parent.[v] <- u" },
        { key: "dijkstra_relax", text: "        pq.Add((d.[v], v)) |> ignore)" },
      ],
      prim: [
        { key: "prim_init", text: "open System.Collections.Generic" },
        { key: "prim_init", text: "let key = Array.create n System.Double.PositiveInfinity" },
        { key: "prim_init", text: "let parent = Array.create n -1" },
        { key: "prim_init", text: "let inMST = Array.create n false" },
        { key: "prim_init", text: "key.[s] <- 0.0" },
        { key: "prim_init", text: "let pq = SortedSet<(float * int)>(compare); pq.Add((0.0, s)) |> ignore" },
        { key: "prim_extract", text: "while pq.Count > 0 do" },
        { key: "prim_extract", text: "  let (key_u, u) = pq.Min; pq.Remove((key_u, u)) |> ignore" },
        { key: "prim_extract", text: "  if inMST.[u] then ()" },
        { key: "prim_extract", text: "  else inMST.[u] <- true" },
        { key: "prim_relax", text: "  adj.[u] |> List.iter (fun (v, w) ->" },
        { key: "prim_relax", text: "      if not inMST.[v] && w < key.[v] then" },
        { key: "prim_relax", text: "        key.[v] <- w; parent.[v] <- u" },
        { key: "prim_relax", text: "        pq.Add((key.[v], v)) |> ignore)" },
      ],
      bfs: [
        { key: "bfs_init", text: "open System.Collections.Generic" },
        { key: "bfs_init", text: "let d = Array.create n System.Int32.MaxValue" },
        { key: "bfs_init", text: "let parent = Array.create n -1" },
        { key: "bfs_init", text: "let visited = Array.create n false" },
        { key: "bfs_init", text: "d.[s] <- 0; visited.[s] <- true" },
        { key: "bfs_init", text: "let q = Queue<int>(); q.Enqueue(s)" },
        { key: "bfs_pop", text: "while q.Count > 0 do" },
        { key: "bfs_pop", text: "  let u = q.Dequeue()" },
        { key: "bfs_relax", text: "  adj.[u] |> List.iter (fun v ->" },
        { key: "bfs_relax", text: "      if not visited.[v] then" },
        { key: "bfs_relax", text: "        visited.[v] <- true; d.[v] <- d.[u] + 1; parent.[v] <- u; q.Enqueue(v))" },
      ],
      dfs: [
        { key: "dfs_init", text: "let visited = Array.create n false" },
        { key: "dfs_init", text: "let parent = Array.create n -1" },
        { key: "dfs_init", text: "let rec dfs u =" },
        { key: "dfs_visit", text: "  visited.[u] <- true" },
        { key: "dfs_relax", text: "  adj.[u] |> List.iter (fun v ->" },
        { key: "dfs_relax", text: "      if not visited.[v] then" },
        { key: "dfs_relax", text: "        parent.[v] <- u; dfs v)" },
      ],
    },
    dart: {
      relaxation: [
        { key: "init", text: "List<double> d = List.filled(n, double.infinity);" },
        { key: "init", text: "List<int?> parent = List.filled(n, null);" },
        { key: "init", text: "d[s] = 0;" },
        { key: "relax_outer", text: "for (int i = 0; i < n - 1; i++) {" },
        { key: "relax", text: "  for (var (u, v, w) in edges) {" },
        { key: "relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "List<double> d = List.filled(n, double.infinity);" },
        { key: "bf_init", text: "List<int?> parent = List.filled(n, null);" },
        { key: "bf_init", text: "d[s] = 0;" },
        { key: "bf_outer", text: "for (int i = 0; i < n - 1; i++) {" },
        { key: "bf_relax", text: "  for (var (u, v, w) in edges) {" },
        { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for (var (u, v, w) in edges) {" },
        { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) print('negative cycle');" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "List<double> d = List.filled(n, double.infinity);" },
        { key: "fifo_init", text: "List<int?> parent = List.filled(n, null);" },
        { key: "fifo_init", text: "d[s] = 0;" },
        { key: "fifo_init", text: "var q = <int>[s]; var inQ = List.filled(n, false); inQ[s] = true;" },
        { key: "fifo_pop", text: "while (q.isNotEmpty) {" },
        { key: "fifo_pop", text: "  int u = q.removeAt(0); inQ[u] = false;" },
        { key: "fifo_relax", text: "  for (var (v, w) in adj[u]) {" },
        { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "fifo_relax", text: "          if (!inQ[v]) { q.add(v); inQ[v] = true; }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "import 'dart:collection';" },
        { key: "dijkstra_init", text: "List<double> d = List.filled(n, double.infinity);" },
        { key: "dijkstra_init", text: "List<int> parent = List.filled(n, -1);" },
        { key: "dijkstra_init", text: "d[s] = 0;" },
        { key: "dijkstra_init", text: "var pq = PriorityQueue<MapEntry<int, double>>((a, b) => a.value.compareTo(b.value));" },
        { key: "dijkstra_init", text: "pq.addEntry(MapEntry(s, 0));" },
        { key: "dijkstra_extract", text: "while (pq.isNotEmpty) {" },
        { key: "dijkstra_extract", text: "  var entry = pq.removeFirst(); int u = entry.key; double dist_u = entry.value;" },
        { key: "dijkstra_extract", text: "  if (dist_u > d[u]) continue;" },
        { key: "dijkstra_relax", text: "  for (var e in adj[u]) {" },
        { key: "dijkstra_relax", text: "      int v = e[0]; double w = e[1];" },
        { key: "dijkstra_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
        { key: "dijkstra_relax", text: "          pq.addEntry(MapEntry(v, d[v]));" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "import 'dart:collection';" },
        { key: "prim_init", text: "List<double> key = List.filled(n, double.infinity);" },
        { key: "prim_init", text: "List<int> parent = List.filled(n, -1);" },
        { key: "prim_init", text: "List<bool> inMST = List.filled(n, false);" },
        { key: "prim_init", text: "key[s] = 0;" },
        { key: "prim_init", text: "var pq = PriorityQueue<MapEntry<int, double>>((a, b) => a.value.compareTo(b.value));" },
        { key: "prim_init", text: "pq.addEntry(MapEntry(s, 0));" },
        { key: "prim_extract", text: "while (pq.isNotEmpty) {" },
        { key: "prim_extract", text: "  var entry = pq.removeFirst(); int u = entry.key; double key_u = entry.value;" },
        { key: "prim_extract", text: "  if (inMST[u]) continue;" },
        { key: "prim_extract", text: "  inMST[u] = true;" },
        { key: "prim_relax", text: "  for (var e in adj[u]) {" },
        { key: "prim_relax", text: "      int v = e[0]; double w = e[1];" },
        { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u;" },
        { key: "prim_relax", text: "          pq.addEntry(MapEntry(v, key[v]));" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "// MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "import 'dart:collection';" },
        { key: "bfs_init", text: "List<int> d = List.filled(n, 999999);" },
        { key: "bfs_init", text: "List<int> parent = List.filled(n, -1);" },
        { key: "bfs_init", text: "List<bool> visited = List.filled(n, false);" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true; var q = Queue<int>(); q.add(s);" },
        { key: "bfs_pop", text: "while (q.isNotEmpty) {" },
        { key: "bfs_pop", text: "  int u = q.removeFirst();" },
        { key: "bfs_relax", text: "  for (int v in adj[u]) {" },
        { key: "bfs_relax", text: "      if (!visited[v]) {" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.add(v);" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "List<bool> visited = List.filled(n, false);" },
        { key: "dfs_init", text: "List<int?> parent = List.filled(n, null);" },
        { key: "dfs_init", text: "void dfs(int u) {" },
        { key: "dfs_visit", text: "  visited[u] = true;" },
        { key: "dfs_relax", text: "  for (int v in adj[u]) {" },
        { key: "dfs_relax", text: "      if (!visited[v]) {" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    lua: {
      relaxation: [
        { key: "init", text: "local d = {}; local parent = {}" },
        { key: "init", text: "for i = 1, n do d[i] = math.huge; parent[i] = nil end" },
        { key: "init", text: "d[s] = 0" },
        { key: "relax_outer", text: "for _ = 1, n - 1 do" },
        { key: "relax", text: "  for _, edge in ipairs(edges) do" },
        { key: "relax", text: "      local u, v, w = edge[1], edge[2], edge[3]" },
        { key: "relax", text: "      if d[u] + w < d[v] then" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "relax", text: "      end" },
        { key: "relax", text: "  end" },
        { key: "relax_outer", text: "end" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "local d = {}; local parent = {}" },
        { key: "bf_init", text: "for i = 1, n do d[i] = math.huge; parent[i] = nil end" },
        { key: "bf_init", text: "d[s] = 0" },
        { key: "bf_outer", text: "for _ = 1, n - 1 do" },
        { key: "bf_relax", text: "  for _, edge in ipairs(edges) do" },
        { key: "bf_relax", text: "      local u, v, w = edge[1], edge[2], edge[3]" },
        { key: "bf_relax", text: "      if d[u] + w < d[v] then" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "bf_relax", text: "      end" },
        { key: "bf_relax", text: "  end" },
        { key: "bf_outer", text: "end" },
        { key: "bf_check", text: "for _, edge in ipairs(edges) do" },
        { key: "bf_neg_cycle", text: "  local u, v, w = edge[1], edge[2], edge[3]" },
        { key: "bf_neg_cycle", text: "  if d[u] + w < d[v] then print('negative cycle') end" },
        { key: "bf_check", text: "end" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "local d = {}; local parent = {}; local inQ = {}" },
        { key: "fifo_init", text: "for i = 1, n do d[i] = math.huge; parent[i] = nil; inQ[i] = false end" },
        { key: "fifo_init", text: "d[s] = 0; local q = {s}; inQ[s] = true" },
        { key: "fifo_pop", text: "while #q > 0 do" },
        { key: "fifo_pop", text: "  local u = table.remove(q, 1); inQ[u] = false" },
        { key: "fifo_relax", text: "  for _, edge in ipairs(adj[u]) do" },
        { key: "fifo_relax", text: "      local v, w = edge[1], edge[2]" },
        { key: "fifo_relax", text: "      if d[u] + w < d[v] then" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "fifo_relax", text: "          if not inQ[v] then table.insert(q, v); inQ[v] = true end" },
        { key: "fifo_relax", text: "      end" },
        { key: "fifo_relax", text: "  end" },
        { key: "fifo_pop", text: "end" },
      ],
      bfs: [
        { key: "bfs_init", text: "local d = {}; local parent = {}; local visited = {}" },
        { key: "bfs_init", text: "for i = 1, n do d[i] = math.huge; parent[i] = nil; visited[i] = false end" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true; local q = {s}" },
        { key: "bfs_pop", text: "while #q > 0 do" },
        { key: "bfs_pop", text: "  local u = table.remove(q, 1)" },
        { key: "bfs_relax", text: "  for _, v in ipairs(adj[u]) do" },
        { key: "bfs_relax", text: "      if not visited[v] then" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; table.insert(q, v)" },
        { key: "bfs_relax", text: "      end" },
        { key: "bfs_relax", text: "  end" },
        { key: "bfs_pop", text: "end" },
      ],
      prim: [
        { key: "prim_init", text: "local key = {}; local parent = {}; local in_mst = {}" },
        { key: "prim_init", text: "for i = 1, n do key[i] = math.huge; parent[i] = nil; in_mst[i] = false end" },
        { key: "prim_init", text: "key[s] = 0; local pq = {{0, s}}" },
        { key: "prim_extract", text: "while #pq > 0 do" },
        { key: "prim_extract", text: "  table.sort(pq, function(a, b) return a[1] < b[1] end)" },
        { key: "prim_extract", text: "  local key_u, u = table.remove(pq, 1)[1], table.remove(pq, 1)[2]" },
        { key: "prim_extract", text: "  if in_mst[u] then goto continue end" },
        { key: "prim_extract", text: "  in_mst[u] = true" },
        { key: "prim_relax", text: "  for _, edge in ipairs(adj[u]) do" },
        { key: "prim_relax", text: "      local v, w = edge[1], edge[2]" },
        { key: "prim_relax", text: "      if not in_mst[v] and w < key[v] then" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u; table.insert(pq, {key[v], v})" },
        { key: "prim_relax", text: "      end" },
        { key: "prim_relax", text: "  end" },
        { key: "prim_extract", text: "  ::continue::" },
        { key: "prim_extract", text: "end" },
        { key: "prim_done", text: "-- MST constructed" },
      ],
      dfs: [
        { key: "dfs_init", text: "local visited = {}; local parent = {}" },
        { key: "dfs_init", text: "for i = 1, n do visited[i] = false; parent[i] = nil end" },
        { key: "dfs_init", text: "local function dfs(u)" },
        { key: "dfs_visit", text: "  visited[u] = true" },
        { key: "dfs_relax", text: "  for _, v in ipairs(adj[u]) do" },
        { key: "dfs_relax", text: "      if not visited[v] then" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v)" },
        { key: "dfs_relax", text: "      end" },
        { key: "dfs_relax", text: "  end" },
        { key: "dfs_visit", text: "end" },
      ],
    },
    perl: {
      relaxation: [
        { key: "init", text: "my @d = (inf) x $n; my @parent = (undef) x $n;" },
        { key: "init", text: "$d[$s] = 0;" },
        { key: "relax_outer", text: "for my $i (0 .. $n - 2) {" },
        { key: "relax", text: "  for my $edge (@edges) {" },
        { key: "relax", text: "      my ($u, $v, $w) = @$edge;" },
        { key: "relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
        { key: "relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "my @d = (inf) x $n; my @parent = (undef) x $n;" },
        { key: "bf_init", text: "$d[$s] = 0;" },
        { key: "bf_outer", text: "for my $i (0 .. $n - 2) {" },
        { key: "bf_relax", text: "  for my $edge (@edges) {" },
        { key: "bf_relax", text: "      my ($u, $v, $w) = @$edge;" },
        { key: "bf_relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
        { key: "bf_relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for my $edge (@edges) {" },
        { key: "bf_neg_cycle", text: "  my ($u, $v, $w) = @$edge;" },
        { key: "bf_neg_cycle", text: "  if ($d[$u] + $w < $d[$v]) { print \"negative cycle\\n\" }" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "my @d = (inf) x $n; my @parent = (undef) x $n; my @inQ = (0) x $n;" },
        { key: "fifo_init", text: "$d[$s] = 0; my @q = ($s); $inQ[$s] = 1;" },
        { key: "fifo_pop", text: "while (@q) {" },
        { key: "fifo_pop", text: "  my $u = shift @q; $inQ[$u] = 0;" },
        { key: "fifo_relax", text: "  for my $edge (@{$adj[$u]}) {" },
        { key: "fifo_relax", text: "      my ($v, $w) = @$edge;" },
        { key: "fifo_relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
        { key: "fifo_relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
        { key: "fifo_relax", text: "          if (!$inQ[$v]) { push @q, $v; $inQ[$v] = 1 }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "use strict; use warnings;" },
        { key: "dijkstra_init", text: "my @d = (inf) x $n; my @parent = (-1) x $n;" },
        { key: "dijkstra_init", text: "$d[$s] = 0;" },
        { key: "dijkstra_init", text: "my @pq = ([0, $s]);" },
        { key: "dijkstra_extract", text: "while (@pq) {" },
        { key: "dijkstra_extract", text: "  @pq = sort { $a->[0] <=> $b->[0] } @pq;" },
        { key: "dijkstra_extract", text: "  my ($dist_u, $u) = @{shift @pq};" },
        { key: "dijkstra_extract", text: "  next if $dist_u > $d[$u];" },
        { key: "dijkstra_relax", text: "  for my $edge (@{$adj[$u]}) {" },
        { key: "dijkstra_relax", text: "      my ($v, $w) = @$edge;" },
        { key: "dijkstra_relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
        { key: "dijkstra_relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
        { key: "dijkstra_relax", text: "          push @pq, [$d[$v], $v];" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "use strict; use warnings;" },
        { key: "prim_init", text: "my @key = (inf) x $n; my @parent = (-1) x $n; my @in_mst = (0) x $n;" },
        { key: "prim_init", text: "$key[$s] = 0; my @pq = ([0, $s]);" },
        { key: "prim_extract", text: "while (@pq) {" },
        { key: "prim_extract", text: "  @pq = sort { $a->[0] <=> $b->[0] } @pq;" },
        { key: "prim_extract", text: "  my ($key_u, $u) = @{shift @pq};" },
        { key: "prim_extract", text: "  next if $in_mst[$u];" },
        { key: "prim_extract", text: "  $in_mst[$u] = 1;" },
        { key: "prim_relax", text: "  for my $edge (@{$adj[$u]}) {" },
        { key: "prim_relax", text: "      my ($v, $w) = @$edge;" },
        { key: "prim_relax", text: "      if (!$in_mst[$v] && $w < $key[$v]) {" },
        { key: "prim_relax", text: "          $key[$v] = $w; $parent[$v] = $u; push @pq, [$key[$v], $v];" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "# MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "use strict; use warnings;" },
        { key: "bfs_init", text: "my @d = (999999) x $n; my @parent = (-1) x $n; my @visited = (0) x $n;" },
        { key: "bfs_init", text: "$d[$s] = 0; $visited[$s] = 1; my @q = ($s);" },
        { key: "bfs_pop", text: "while (@q) {" },
        { key: "bfs_pop", text: "  my $u = shift @q;" },
        { key: "bfs_relax", text: "  for my $v (@{$adj[$u]}) {" },
        { key: "bfs_relax", text: "      if (!$visited[$v]) {" },
        { key: "bfs_relax", text: "          $visited[$v] = 1; $d[$v] = $d[$u] + 1; $parent[$v] = $u; push @q, $v;" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "my @visited = (0) x $n; my @parent = (-1) x $n;" },
        { key: "dfs_init", text: "sub dfs {" },
        { key: "dfs_init", text: "  my ($u) = @_;" },
        { key: "dfs_visit", text: "  $visited[$u] = 1;" },
        { key: "dfs_relax", text: "  for my $v (@{$adj[$u]}) {" },
        { key: "dfs_relax", text: "      if (!$visited[$v]) {" },
        { key: "dfs_relax", text: "          $parent[$v] = $u; dfs($v);" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    r: {
      relaxation: [
        { key: "init", text: "d <- rep(Inf, n); parent <- rep(NA, n)" },
        { key: "init", text: "d[s] <- 0" },
        { key: "relax_outer", text: "for (i in 1:(n-1)) {" },
        { key: "relax", text: "  for (edge in edges) {" },
        { key: "relax", text: "      u <- edge[1]; v <- edge[2]; w <- edge[3]" },
        { key: "relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "relax", text: "          d[v] <- d[u] + w; parent[v] <- u" },
        { key: "relax", text: "      }" },
        { key: "relax", text: "  }" },
        { key: "relax_outer", text: "}" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "d <- rep(Inf, n); parent <- rep(NA, n)" },
        { key: "bf_init", text: "d[s] <- 0" },
        { key: "bf_outer", text: "for (i in 1:(n-1)) {" },
        { key: "bf_relax", text: "  for (edge in edges) {" },
        { key: "bf_relax", text: "      u <- edge[1]; v <- edge[2]; w <- edge[3]" },
        { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "bf_relax", text: "          d[v] <- d[u] + w; parent[v] <- u" },
        { key: "bf_relax", text: "      }" },
        { key: "bf_relax", text: "  }" },
        { key: "bf_outer", text: "}" },
        { key: "bf_check", text: "for (edge in edges) {" },
        { key: "bf_neg_cycle", text: "  u <- edge[1]; v <- edge[2]; w <- edge[3]" },
        { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) cat(\"negative cycle\\n\")" },
        { key: "bf_check", text: "}" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "d <- rep(Inf, n); parent <- rep(NA, n); inQ <- rep(FALSE, n)" },
        { key: "fifo_init", text: "d[s] <- 0; q <- c(s); inQ[s] <- TRUE" },
        { key: "fifo_pop", text: "while (length(q) > 0) {" },
        { key: "fifo_pop", text: "  u <- q[1]; q <- q[-1]; inQ[u] <- FALSE" },
        { key: "fifo_relax", text: "  for (edge in adj[[u]]) {" },
        { key: "fifo_relax", text: "      v <- edge[1]; w <- edge[2]" },
        { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "fifo_relax", text: "          d[v] <- d[u] + w; parent[v] <- u" },
        { key: "fifo_relax", text: "          if (!inQ[v]) { q <- c(q, v); inQ[v] <- TRUE }" },
        { key: "fifo_relax", text: "      }" },
        { key: "fifo_relax", text: "  }" },
        { key: "fifo_pop", text: "}" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "library(igraph)" },
        { key: "dijkstra_init", text: "d <- rep(Inf, n); parent <- rep(NA, n)" },
        { key: "dijkstra_init", text: "d[s] <- 0" },
        { key: "dijkstra_init", text: "pq <- data.frame(dist = 0, node = s)" },
        { key: "dijkstra_extract", text: "while (nrow(pq) > 0) {" },
        { key: "dijkstra_extract", text: "  pq <- pq[order(pq$dist), ]" },
        { key: "dijkstra_extract", text: "  dist_u <- pq$dist[1]; u <- pq$node[1]; pq <- pq[-1, ]" },
        { key: "dijkstra_extract", text: "  if (dist_u > d[u]) next" },
        { key: "dijkstra_relax", text: "  for (edge in adj[[u]]) {" },
        { key: "dijkstra_relax", text: "      v <- edge$v; w <- edge$w" },
        { key: "dijkstra_relax", text: "      if (d[u] + w < d[v]) {" },
        { key: "dijkstra_relax", text: "          d[v] <- d[u] + w; parent[v] <- u" },
        { key: "dijkstra_relax", text: "          pq <- rbind(pq, data.frame(dist = d[v], node = v))" },
        { key: "dijkstra_relax", text: "      }" },
        { key: "dijkstra_relax", text: "  }" },
        { key: "dijkstra_extract", text: "}" },
      ],
      prim: [
        { key: "prim_init", text: "key <- rep(Inf, n); parent <- rep(NA, n); inMST <- rep(FALSE, n)" },
        { key: "prim_init", text: "key[s] <- 0" },
        { key: "prim_init", text: "pq <- data.frame(key = 0, node = s)" },
        { key: "prim_extract", text: "while (nrow(pq) > 0) {" },
        { key: "prim_extract", text: "  pq <- pq[order(pq$key), ]" },
        { key: "prim_extract", text: "  key_u <- pq$key[1]; u <- pq$node[1]; pq <- pq[-1, ]" },
        { key: "prim_extract", text: "  if (inMST[u]) next" },
        { key: "prim_extract", text: "  inMST[u] <- TRUE" },
        { key: "prim_relax", text: "  for (edge in adj[[u]]) {" },
        { key: "prim_relax", text: "      v <- edge$v; w <- edge$w" },
        { key: "prim_relax", text: "      if (!inMST[v] && w < key[v]) {" },
        { key: "prim_relax", text: "          key[v] <- w; parent[v] <- u" },
        { key: "prim_relax", text: "          pq <- rbind(pq, data.frame(key = key[v], node = v))" },
        { key: "prim_relax", text: "      }" },
        { key: "prim_relax", text: "  }" },
        { key: "prim_extract", text: "}" },
        { key: "prim_done", text: "# MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "library(igraph)" },
        { key: "bfs_init", text: "d <- rep(Inf, n); parent <- rep(NA, n); visited <- rep(FALSE, n)" },
        { key: "bfs_init", text: "d[s] <- 0; visited[s] <- TRUE; q <- c(s)" },
        { key: "bfs_pop", text: "while (length(q) > 0) {" },
        { key: "bfs_pop", text: "  u <- q[1]; q <- q[-1]" },
        { key: "bfs_relax", text: "  for (v in adj[[u]]) {" },
        { key: "bfs_relax", text: "      if (!visited[v]) {" },
        { key: "bfs_relax", text: "          visited[v] <- TRUE; d[v] <- d[u] + 1; parent[v] <- u; q <- c(q, v)" },
        { key: "bfs_relax", text: "      }" },
        { key: "bfs_relax", text: "  }" },
        { key: "bfs_pop", text: "}" },
      ],
      dfs: [
        { key: "dfs_init", text: "visited <- rep(FALSE, n); parent <- rep(NA, n)" },
        { key: "dfs_init", text: "dfs <- function(u) {" },
        { key: "dfs_visit", text: "  visited[u] <<- TRUE" },
        { key: "dfs_relax", text: "  for (v in adj[[u]]) {" },
        { key: "dfs_relax", text: "      if (!visited[v]) {" },
        { key: "dfs_relax", text: "          parent[v] <<- u; dfs(v)" },
        { key: "dfs_relax", text: "      }" },
        { key: "dfs_relax", text: "  }" },
        { key: "dfs_visit", text: "}" },
      ],
    },
    matlab: {
      relaxation: [
        { key: "init", text: "d = inf(1, n); parent = zeros(1, n);" },
        { key: "init", text: "d(s) = 0;" },
        { key: "relax_outer", text: "for i = 1:n-1" },
        { key: "relax", text: "  for e = 1:size(edges, 1)" },
        { key: "relax", text: "      u = edges(e, 1); v = edges(e, 2); w = edges(e, 3);" },
        { key: "relax", text: "      if d(u) + w < d(v)" },
        { key: "relax", text: "          d(v) = d(u) + w; parent(v) = u;" },
        { key: "relax", text: "      end" },
        { key: "relax", text: "  end" },
        { key: "relax_outer", text: "end" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "d = inf(1, n); parent = zeros(1, n);" },
        { key: "bf_init", text: "d(s) = 0;" },
        { key: "bf_outer", text: "for i = 1:n-1" },
        { key: "bf_relax", text: "  for e = 1:size(edges, 1)" },
        { key: "bf_relax", text: "      u = edges(e, 1); v = edges(e, 2); w = edges(e, 3);" },
        { key: "bf_relax", text: "      if d(u) + w < d(v)" },
        { key: "bf_relax", text: "          d(v) = d(u) + w; parent(v) = u;" },
        { key: "bf_relax", text: "      end" },
        { key: "bf_relax", text: "  end" },
        { key: "bf_outer", text: "end" },
        { key: "bf_check", text: "for e = 1:size(edges, 1)" },
        { key: "bf_neg_cycle", text: "  u = edges(e, 1); v = edges(e, 2); w = edges(e, 3);" },
        { key: "bf_neg_cycle", text: "  if d(u) + w < d(v), fprintf('negative cycle\\n'); end" },
        { key: "bf_check", text: "end" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "d = inf(1, n); parent = zeros(1, n); inQ = false(1, n);" },
        { key: "fifo_init", text: "d(s) = 0; q = [s]; inQ(s) = true;" },
        { key: "fifo_pop", text: "while ~isempty(q)" },
        { key: "fifo_pop", text: "  u = q(1); q = q(2:end); inQ(u) = false;" },
        { key: "fifo_relax", text: "  for e = 1:size(adj{u}, 1)" },
        { key: "fifo_relax", text: "      v = adj{u}(e, 1); w = adj{u}(e, 2);" },
        { key: "fifo_relax", text: "      if d(u) + w < d(v)" },
        { key: "fifo_relax", text: "          d(v) = d(u) + w; parent(v) = u;" },
        { key: "fifo_relax", text: "          if ~inQ(v), q = [q, v]; inQ(v) = true; end" },
        { key: "fifo_relax", text: "      end" },
        { key: "fifo_relax", text: "  end" },
        { key: "fifo_pop", text: "end" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "d = inf(1, n); parent = zeros(1, n);" },
        { key: "dijkstra_init", text: "d(s) = 0;" },
        { key: "dijkstra_init", text: "pq = [0, s];" },
        { key: "dijkstra_extract", text: "while ~isempty(pq)" },
        { key: "dijkstra_extract", text: "  [~, idx] = min(pq(:, 1)); dist_u = pq(idx, 1); u = pq(idx, 2);" },
        { key: "dijkstra_extract", text: "  pq(idx, :) = [];" },
        { key: "dijkstra_extract", text: "  if dist_u > d(u), continue, end" },
        { key: "dijkstra_relax", text: "  for edge = adj{u}" },
        { key: "dijkstra_relax", text: "      v = edge(1); w = edge(2);" },
        { key: "dijkstra_relax", text: "      if d(u) + w < d(v)" },
        { key: "dijkstra_relax", text: "          d(v) = d(u) + w; parent(v) = u;" },
        { key: "dijkstra_relax", text: "          pq = [pq; d(v), v];" },
        { key: "dijkstra_relax", text: "      end" },
        { key: "dijkstra_relax", text: "  end" },
        { key: "dijkstra_extract", text: "end" },
      ],
      prim: [
        { key: "prim_init", text: "key = inf(1, n); parent = zeros(1, n); inMST = false(1, n);" },
        { key: "prim_init", text: "key(s) = 0; pq = [0, s];" },
        { key: "prim_extract", text: "while ~isempty(pq)" },
        { key: "prim_extract", text: "  [~, idx] = min(pq(:, 1)); key_u = pq(idx, 1); u = pq(idx, 2);" },
        { key: "prim_extract", text: "  pq(idx, :) = [];" },
        { key: "prim_extract", text: "  if inMST(u), continue, end" },
        { key: "prim_extract", text: "  inMST(u) = true;" },
        { key: "prim_relax", text: "  for edge = adj{u}" },
        { key: "prim_relax", text: "      v = edge(1); w = edge(2);" },
        { key: "prim_relax", text: "      if ~inMST(v) && w < key(v)" },
        { key: "prim_relax", text: "          key(v) = w; parent(v) = u;" },
        { key: "prim_relax", text: "          pq = [pq; key(v), v];" },
        { key: "prim_relax", text: "      end" },
        { key: "prim_relax", text: "  end" },
        { key: "prim_extract", text: "end" },
        { key: "prim_done", text: "% MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "d = inf(1, n); parent = zeros(1, n); visited = false(1, n);" },
        { key: "bfs_init", text: "d(s) = 0; visited(s) = true; q = [s];" },
        { key: "bfs_pop", text: "while ~isempty(q)" },
        { key: "bfs_pop", text: "  u = q(1); q = q(2:end);" },
        { key: "bfs_relax", text: "  for v = adj{u}" },
        { key: "bfs_relax", text: "      if ~visited(v)" },
        { key: "bfs_relax", text: "          visited(v) = true; d(v) = d(u) + 1; parent(v) = u; q = [q, v];" },
        { key: "bfs_relax", text: "      end" },
        { key: "bfs_relax", text: "  end" },
        { key: "bfs_pop", text: "end" },
      ],
      dfs: [
        { key: "dfs_init", text: "visited = false(1, n); parent = zeros(1, n);" },
        { key: "dfs_init", text: "function dfs(u)" },
        { key: "dfs_visit", text: "  visited(u) = true;" },
        { key: "dfs_relax", text: "  for v = adj{u}" },
        { key: "dfs_relax", text: "      if ~visited(v)" },
        { key: "dfs_relax", text: "          parent(v) = u; dfs(v);" },
        { key: "dfs_relax", text: "      end" },
        { key: "dfs_relax", text: "  end" },
        { key: "dfs_visit", text: "end" },
      ],
    },
    julia: {
      relaxation: [
        { key: "init", text: "d = fill(Inf, n); parent = fill(nothing, n)" },
        { key: "init", text: "d[s] = 0" },
        { key: "relax_outer", text: "for _ in 1:n-1" },
        { key: "relax", text: "  for (u, v, w) in edges" },
        { key: "relax", text: "      if d[u] + w < d[v]" },
        { key: "relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "relax", text: "      end" },
        { key: "relax", text: "  end" },
        { key: "relax_outer", text: "end" },
      ],
      "bellman-ford": [
        { key: "bf_init", text: "d = fill(Inf, n); parent = fill(nothing, n)" },
        { key: "bf_init", text: "d[s] = 0" },
        { key: "bf_outer", text: "for _ in 1:n-1" },
        { key: "bf_relax", text: "  for (u, v, w) in edges" },
        { key: "bf_relax", text: "      if d[u] + w < d[v]" },
        { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "bf_relax", text: "      end" },
        { key: "bf_relax", text: "  end" },
        { key: "bf_outer", text: "end" },
        { key: "bf_check", text: "for (u, v, w) in edges" },
        { key: "bf_neg_cycle", text: "  if d[u] + w < d[v] println(\"negative cycle\") end" },
        { key: "bf_check", text: "end" },
      ],
      "bellman-ford-fifo": [
        { key: "fifo_init", text: "d = fill(Inf, n); parent = fill(nothing, n); inQ = fill(false, n)" },
        { key: "fifo_init", text: "d[s] = 0; q = [s]; inQ[s] = true" },
        { key: "fifo_pop", text: "while !isempty(q)" },
        { key: "fifo_pop", text: "  u = popfirst!(q); inQ[u] = false" },
        { key: "fifo_relax", text: "  for (v, w) in adj[u]" },
        { key: "fifo_relax", text: "      if d[u] + w < d[v]" },
        { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "fifo_relax", text: "          if !inQ[v] push!(q, v); inQ[v] = true end" },
        { key: "fifo_relax", text: "      end" },
        { key: "fifo_relax", text: "  end" },
        { key: "fifo_pop", text: "end" },
      ],
      dijkstra: [
        { key: "dijkstra_init", text: "using DataStructures" },
        { key: "dijkstra_init", text: "d = fill(Inf, n); parent = fill(nothing, n); visited = falses(n)" },
        { key: "dijkstra_init", text: "d[s] = 0" },
        { key: "dijkstra_init", text: "pq = PriorityQueue(Base.Order.Forward, [(d[s], s)])" },
        { key: "dijkstra_extract", text: "while !isempty(pq)" },
        { key: "dijkstra_extract", text: "  (dist_u, u) = dequeue!(pq)" },
        { key: "dijkstra_extract", text: "  visited[u] && continue" },
        { key: "dijkstra_extract", text: "  visited[u] = true" },
        { key: "dijkstra_relax", text: "  for (v, w) in adj[u]" },
        { key: "dijkstra_relax", text: "      visited[v] && continue" },
        { key: "dijkstra_relax", text: "      if d[u] + w < d[v]" },
        { key: "dijkstra_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
        { key: "dijkstra_relax", text: "          enqueue!(pq, d[v], v)" },
        { key: "dijkstra_relax", text: "      end" },
        { key: "dijkstra_relax", text: "  end" },
        { key: "dijkstra_extract", text: "end" },
      ],
      prim: [
        { key: "prim_init", text: "using DataStructures" },
        { key: "prim_init", text: "key = fill(Inf, n); parent = fill(nothing, n); inMST = falses(n)" },
        { key: "prim_init", text: "key[s] = 0" },
        { key: "prim_init", text: "pq = PriorityQueue(Base.Order.Forward, [(key[s], s)])" },
        { key: "prim_extract", text: "while !isempty(pq)" },
        { key: "prim_extract", text: "  (key_u, u) = dequeue!(pq)" },
        { key: "prim_extract", text: "  inMST[u] && continue" },
        { key: "prim_extract", text: "  inMST[u] = true" },
        { key: "prim_relax", text: "  for (v, w) in adj[u]" },
        { key: "prim_relax", text: "      inMST[v] && continue" },
        { key: "prim_relax", text: "      if w < key[v]" },
        { key: "prim_relax", text: "          key[v] = w; parent[v] = u" },
        { key: "prim_relax", text: "          enqueue!(pq, key[v], v)" },
        { key: "prim_relax", text: "      end" },
        { key: "prim_relax", text: "  end" },
        { key: "prim_extract", text: "end" },
        { key: "prim_done", text: "# MST constructed" },
      ],
      bfs: [
        { key: "bfs_init", text: "using DataStructures" },
        { key: "bfs_init", text: "d = fill(Inf, n); parent = fill(nothing, n); visited = falses(n)" },
        { key: "bfs_init", text: "d[s] = 0; visited[s] = true; q = Queue{Int}(); enqueue!(q, s)" },
        { key: "bfs_pop", text: "while !isempty(q)" },
        { key: "bfs_pop", text: "  u = dequeue!(q)" },
        { key: "bfs_relax", text: "  for v in adj[u]" },
        { key: "bfs_relax", text: "      if !visited[v]" },
        { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; enqueue!(q, v)" },
        { key: "bfs_relax", text: "      end" },
        { key: "bfs_relax", text: "  end" },
        { key: "bfs_pop", text: "end" },
      ],
      dfs: [
        { key: "dfs_init", text: "visited = falses(n); parent = fill(nothing, n)" },
        { key: "dfs_init", text: "function dfs(u)" },
        { key: "dfs_visit", text: "  visited[u] = true" },
        { key: "dfs_relax", text: "  for v in adj[u]" },
        { key: "dfs_relax", text: "      if !visited[v]" },
        { key: "dfs_relax", text: "          parent[v] = u; dfs(v)" },
        { key: "dfs_relax", text: "      end" },
        { key: "dfs_relax", text: "  end" },
        { key: "dfs_visit", text: "end" },
      ],
    },
  };

  // escapeHtml is now imported from utils/helpers.js

  function highlightSyntax(text, lang) {
    // Escape HTML first
    let html = escapeHtml(text);
    
    // Use placeholders to protect already-highlighted content
    const PLACEHOLDER_PREFIX = '\uE001';
    const placeholders = [];
    let placeholderIdx = 0;
    
    function createPlaceholder(content) {
      const id = placeholderIdx++;
      const placeholder = `${PLACEHOLDER_PREFIX}${id}${PLACEHOLDER_PREFIX}`;
      placeholders.push({ placeholder, content });
      return placeholder;
    }
    
    // Process in reverse order of specificity to avoid conflicts
    
    // 1. Comments (match to end of line)
    if (lang === "cpp" || lang === "c" || lang === "java" || lang === "javascript" || lang === "typescript" || lang === "rust" || lang === "go" || lang === "kotlin" || lang === "swift" || lang === "csharp" || lang === "dart") {
      html = html.replace(/(\/\/.*$)/gm, (match) => {
        const ph = createPlaceholder(`<span class="tok-comment">${match}</span>`);
        return ph;
      });
    } else if (lang === "python" || lang === "ruby" || lang === "perl" || lang === "r" || lang === "julia" || lang === "lua" || lang === "haskell" || lang === "php") {
      html = html.replace(/(#.*$)/gm, (match) => {
        const ph = createPlaceholder(`<span class="tok-comment">${match}</span>`);
        return ph;
      });
    } else if (lang === "ocaml" || lang === "fsharp") {
      html = html.replace(/(\(\*[\s\S]*?\*\))/g, (match) => {
        const ph = createPlaceholder(`<span class="tok-comment">${match}</span>`);
        return ph;
      });
    } else if (lang === "scala") {
      html = html.replace(/(\/\/.*$)/gm, (match) => {
        const ph = createPlaceholder(`<span class="tok-comment">${match}</span>`);
        return ph;
      });
      html = html.replace(/(\/\*[\s\S]*?\*\/)/g, (match) => {
        const ph = createPlaceholder(`<span class="tok-comment">${match}</span>`);
        return ph;
      });
    } else if (lang === "matlab") {
      html = html.replace(/(%.*$)/gm, (match) => {
        const ph = createPlaceholder(`<span class="tok-comment">${match}</span>`);
        return ph;
      });
    }
    
    // 2. Strings (before other replacements)
    html = html.replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, (match) => {
      const ph = createPlaceholder(`<span class="tok-string">${match}</span>`);
      return ph;
    });
    
    // 3. Numbers (word boundaries)
    html = html.replace(/\b(\d+\.?\d*)\b/g, (match) => {
      const ph = createPlaceholder(`<span class="tok-number">${match}</span>`);
      return ph;
    });
    
    // 4. Function calls (identifier followed by opening paren, but not if it's a keyword)
    html = html.replace(/\b([A-Za-z_][A-Za-z0-9_]*)\s*(?=\()/g, (match, ident) => {
      // Check if it's a keyword - if so, skip (will be handled by keyword matcher)
      const pythonKeywords = ['for', 'if', 'elif', 'else', 'while', 'return', 'break', 'continue', 'def', 'class', 'import', 'from', 'as', 'in', 'not', 'and', 'or', 'None', 'True', 'False', 'float', 'range', 'len', 'print', 'collections', 'deque', 'append', 'popleft'];
      const cppKeywords = ['for', 'if', 'else', 'while', 'return', 'break', 'continue', 'auto', 'const', 'static', 'void', 'int', 'double', 'float', 'bool', 'char', 'long', 'short', 'class', 'struct', 'public', 'private', 'final', 'vector', 'queue', 'true', 'false', 'INF', 'NIL'];
      
      const isKeyword = lang === "python" ? pythonKeywords.includes(ident) :
                       (lang === "cpp" || lang === "c" || lang === "java") ? cppKeywords.includes(ident) : false;
      
      if (!isKeyword) {
        const ph = createPlaceholder(`<span class="tok-function">${match}</span>`);
        return ph;
      }
      return match;
    });
    
    // 5. Keywords (language-specific)
    const commonKeywords = ['for', 'if', 'else', 'while', 'return', 'break', 'continue', 'true', 'false', 'null', 'nil', 'None'];
    if (lang === "cpp" || lang === "c" || lang === "java" || lang === "csharp" || lang === "dart") {
      html = html.replace(/\b(for|if|else|while|return|break|continue|auto|const|static|void|int|double|float|bool|char|long|short|class|struct|public|private|final|vector|queue|true|false|INF|NIL|null)\b/g, (match) => {
        const ph = createPlaceholder(`<span class="tok-keyword">${match}</span>`);
        return ph;
      });
    } else if (lang === "python" || lang === "ruby" || lang === "julia") {
      html = html.replace(/\b(for|if|elif|else|while|return|break|continue|def|class|import|from|as|in|not|and|or|None|True|False|float|range|len|print|collections|deque|append|popleft|end|nil)\b/g, (match) => {
        const ph = createPlaceholder(`<span class="tok-keyword">${match}</span>`);
        return ph;
      });
    } else if (lang === "javascript" || lang === "typescript") {
      html = html.replace(/\b(for|if|else|while|return|break|continue|const|let|var|function|class|true|false|null|undefined|Infinity|console|log)\b/g, (match) => {
        const ph = createPlaceholder(`<span class="tok-keyword">${match}</span>`);
        return ph;
      });
    } else if (lang === "rust") {
      html = html.replace(/\b(for|if|else|while|return|break|continue|let|mut|fn|struct|enum|impl|pub|use|match|Some|None|true|false|println|f64|INFINITY)\b/g, (match) => {
        const ph = createPlaceholder(`<span class="tok-keyword">${match}</span>`);
        return ph;
      });
    } else if (lang === "go") {
      html = html.replace(/\b(for|if|else|range|return|break|continue|var|const|func|type|struct|package|import|fmt|Println|math|Inf)\b/g, (match) => {
        const ph = createPlaceholder(`<span class="tok-keyword">${match}</span>`);
        return ph;
      });
    } else if (lang === "kotlin" || lang === "swift") {
      html = html.replace(/\b(for|if|else|while|return|break|continue|var|val|let|func|class|struct|true|false|nil|Double|POSITIVE_INFINITY|infinity|print|println)\b/g, (match) => {
        const ph = createPlaceholder(`<span class="tok-keyword">${match}</span>`);
        return ph;
      });
    } else if (lang === "scala") {
      html = html.replace(/\b(for|if|else|while|return|break|continue|val|var|def|class|object|import|Array|fill|Double|PositiveInfinity|println|foreach|case)\b/g, (match) => {
        const ph = createPlaceholder(`<span class="tok-keyword">${match}</span>`);
        return ph;
      });
    } else if (lang === "pseudo") {
      html = html.replace(/\b(for|if|while|repeat|each|from|to|with|initialize|report|NIL)\b/g, (match) => {
        const ph = createPlaceholder(`<span class="tok-keyword">${match}</span>`);
        return ph;
      });
    }
    
    // 6. Operators - process carefully to avoid matching inside placeholders
    // Since HTML is escaped, we can safely match operators
    // But we need to avoid matching operators that are inside our placeholder markers
    const operatorPattern = /[+\-*/=<>!|]+/g;
    const operatorReplacements = [];
    let opMatch;
    while ((opMatch = operatorPattern.exec(html)) !== null) {
      const start = opMatch.index;
      const end = start + opMatch[0].length;
      const before = html.substring(Math.max(0, start - 30), start);
      const after = html.substring(end, Math.min(html.length, end + 30));
      
      // Skip if inside a placeholder
      if (before.includes(PLACEHOLDER_PREFIX) || after.includes(PLACEHOLDER_PREFIX)) {
        continue;
      }
      
      // Skip if part of HTML entity (though this shouldn't happen after escapeHtml)
      if (before.endsWith('&') && after.startsWith(';')) {
        continue;
      }
      
      operatorReplacements.push({
        start,
        end,
        text: opMatch[0],
        placeholder: createPlaceholder(`<span class="tok-operator">${opMatch[0]}</span>`)
      });
    }
    
    // Replace operators in reverse order to maintain indices
    for (let i = operatorReplacements.length - 1; i >= 0; i--) {
      const { start, end, placeholder } = operatorReplacements[i];
      html = html.substring(0, start) + placeholder + html.substring(end);
    }
    
    // Replace all placeholders with their content
    placeholders.forEach(({ placeholder, content }) => {
      html = html.replace(placeholder, content);
    });
    
    return html;
  }

  function renderPseudoAndCode() {
    const algoKey = algorithmSelect.value;
    const pseudoLines = PSEUDO_TEMPLATES[algoKey];
    const lang = languageSelect.value;
    let langTemplates = CODE_TEMPLATES[lang];
    if (!langTemplates || !langTemplates[algoKey]) {
      // Fallback: show JavaScript code template if specific language is missing
      langTemplates = CODE_TEMPLATES["javascript"];
    }
    const codeLines = langTemplates && langTemplates[algoKey];

    if (!pseudoLines || !codeLines) {
      pseudoPanel.innerHTML = "";
      codePanel.innerHTML = "";
      return;
    }

    // Render pseudo-code with syntax highlighting
    pseudoPanel.innerHTML = "";
    for (let i = 0; i < pseudoLines.length; i++) {
      const line = document.createElement("span");
      line.innerHTML = highlightSyntax(pseudoLines[i].text, "pseudo");
      line.dataset.key = pseudoLines[i].key;
      line.className = "code-line";
      pseudoPanel.appendChild(line);
      if (i < pseudoLines.length - 1) {
        pseudoPanel.appendChild(document.createTextNode("\n"));
      }
    }

    // Render concrete code with syntax highlighting
    codePanel.innerHTML = "";
    for (let i = 0; i < codeLines.length; i++) {
      const line = document.createElement("span");
      line.innerHTML = highlightSyntax(codeLines[i].text, lang);
      line.dataset.key = codeLines[i].key;
      line.className = "code-line";
      codePanel.appendChild(line);
      if (i < codeLines.length - 1) {
        codePanel.appendChild(document.createTextNode("\n"));
      }
    }
  }

  function highlightCurrentCode(step) {
    const key = step?.codeKey;
    for (const block of [pseudoPanel, codePanel]) {
      const lines = block.querySelectorAll(".code-line");
      lines.forEach((line) => {
        const matches = key && line.dataset.key === key;
        line.classList.toggle("highlight", matches);
        line.classList.toggle("dimmed", !matches);
      });
    }
  }

  // Tabs for pseudo/code
  document.querySelectorAll(".tab").forEach((tab) => {
    tab.addEventListener("click", () => {
      document.querySelectorAll(".tab").forEach((t) => t.classList.remove("active"));
      tab.classList.add("active");
      const panelType = tab.dataset.panel;
      if (panelType === "pseudo") {
        pseudoPanel.classList.remove("hidden");
        codePanel.classList.add("hidden");
      } else {
        pseudoPanel.classList.add("hidden");
        codePanel.classList.remove("hidden");
      }
    });
  });

  algorithmSelect.addEventListener("change", () => {
    renderPseudoAndCode();
    clearSteps();
    // Update panel title based on algorithm
    const algoKey = algorithmSelect.value;
    const parentSubgraphTitle = document.getElementById("parent-subgraph-title");
    if (parentSubgraphTitle) {
      // MST algorithms: prim, kruskal
      if (algoKey === "prim" || algoKey === "kruskal") {
        parentSubgraphTitle.textContent = "MST (Minimum Spanning Tree)";
      } else {
        parentSubgraphTitle.textContent = "Parent Subgraph";
      }
    }
  });
  languageSelect.addEventListener("change", () => {
    renderPseudoAndCode();
    // Changing language resets the entire visualization so the user starts fresh
    resetGraph();
  });
  startNodeSelect.addEventListener("change", () => {
    clearSteps();
    updateStepControls();
  });

  // --- Distances & parent subgraph rendering -----------------------------
  function updateDistancesDisplay(distMap, updatedNode = null, source = null) {
    distanceList.innerHTML = "";
    const nodes = nodeData.get().sort((a, b) => a.id - b.id);
    for (const n of nodes) {
      const pill = document.createElement("span");
      pill.className = "distance-pill";
      const d = distMap.get ? distMap.get(n.id) : undefined;
      if (n.id === source) pill.classList.add("source");
      if (n.id === updatedNode) pill.classList.add("updated");
      if (d === undefined || d === Infinity) pill.classList.add("infinite");
      pill.textContent = `${idToLabel(n.id)}: ${
        d === undefined ? "∞" : d === Infinity ? "∞" : d.toFixed(1).replace(/\.0$/, "")
      }`;
      distanceList.appendChild(pill);
    }
  }

  function renderParentSubgraph(parentMap, distMap, highlightNode) {
    const pn = parentNetwork.body.data.nodes;
    const pe = parentNetwork.body.data.edges;
    pn.clear();
    pe.clear();

    // Get source node
    const sourceNodeId = parseInt(startNodeSelect.value, 10);
    if (Number.isNaN(sourceNodeId)) {
      return; // No source selected
    }

    // Build set of reachable nodes (nodes with finite distance from source)
    const reachableNodes = new Set();
    reachableNodes.add(sourceNodeId);
    
    // Traverse parent map to find all reachable nodes
    function addReachable(nodeId) {
      for (const [v, p] of parentMap.entries()) {
        if (p === nodeId && !reachableNodes.has(v)) {
          const d = distMap.get(v);
          if (d !== undefined && d !== Infinity) {
            reachableNodes.add(v);
            addReachable(v);
          }
        }
      }
    }
    addReachable(sourceNodeId);

    // Calculate levels for each node based on distance from source
    const nodeLevels = new Map();
    nodeLevels.set(sourceNodeId, 0);
    
    // BFS to assign levels based on parent relationships
    const queue = [sourceNodeId];
    while (queue.length > 0) {
      const current = queue.shift();
      const currentLevel = nodeLevels.get(current);
      
      for (const [v, p] of parentMap.entries()) {
        if (p === current && !nodeLevels.has(v)) {
          const d = distMap.get(v);
          if (d !== undefined && d !== Infinity) {
            nodeLevels.set(v, currentLevel + 1);
            queue.push(v);
          }
        }
      }
    }

    // Ensure all reachable nodes have levels assigned
    // If a node is reachable but doesn't have a level, assign it based on distance
    for (const nodeId of reachableNodes) {
      if (!nodeLevels.has(nodeId)) {
        const d = distMap.get(nodeId);
        if (d !== undefined && d !== Infinity) {
          // Use distance to estimate level (rough approximation)
          nodeLevels.set(nodeId, Math.floor(d / 10) || 1);
        } else {
          nodeLevels.set(nodeId, 1);
        }
      }
    }

    // Only add reachable nodes to the network with their levels
    const nodes = nodeData.get();
    const nodesToAdd = [];
    for (const n of nodes) {
      if (!reachableNodes.has(n.id)) continue;
      
      const d = distMap.get(n.id);
      const level = nodeLevels.get(n.id);
      
      // Ensure level is always defined
      if (level === undefined) {
        nodeLevels.set(n.id, 0);
      }
      
      nodesToAdd.push({
        id: n.id,
        label: idToLabel(n.id),
        title:
          d === undefined || d === Infinity
            ? `${idToLabel(n.id)}: distance = ∞`
            : `${idToLabel(n.id)}: distance = ${d.toFixed(2)}`,
        color:
          n.id === highlightNode
            ? {
                background: "rgba(74,222,128,0.45)",
                border: nodeBaseColor(n.id),
              }
            : n.id === sourceNodeId
            ? {
                background: "rgba(56,189,248,0.3)",
                border: nodeBaseColor(n.id),
              }
            : {
                background: "rgba(15,23,42,0.95)",
                border: nodeBaseColor(n.id),
              },
        level: nodeLevels.get(n.id), // All nodes guaranteed to have a level
      });
    }
    
    // Add all nodes at once with levels
    if (nodesToAdd.length > 0) {
      pn.add(nodesToAdd);
    }

    // Only add edges that are part of the tree (parent relationships)
    for (const [v, p] of parentMap.entries()) {
      if (p !== null && p !== undefined && reachableNodes.has(v) && reachableNodes.has(p)) {
        const dv = distMap.get(v);
        const dp = distMap.get(p);
        let wLabel = "";
        if (dp !== undefined && dv !== undefined && dp !== Infinity && dv !== Infinity) {
          const w = dv - dp;
          wLabel = w.toFixed(2).replace(/\.00$/, "");
        }
        pe.add({
          id: `${p}-${v}`,
          from: p,
          to: v,
          arrows: "to",
          label: wLabel,
          font: {
            size: 16,
            color: "#ffffff",
            strokeWidth: 0,
            align: "horizontal",
            vadjust: -10,
          },
        });
      }
    }
    
    // Levels are already calculated and set when adding nodes above
    
    // Auto-fit the network to show all nodes
    setTimeout(() => {
      parentNetwork.fit({
        animation: {
          duration: 300,
          easingFunction: "easeInOutQuad",
        },
        padding: 50,
      });
    }, 100);
  }

  function applyStepVisual(step) {
    if (!step) return;
    stepIndexLabel.textContent = String(currentStepIndex + 1);
    stepTotalLabel.textContent = String(steps.length);
    stepDescription.textContent = step.description || step.label || "";

    const baseNodes = nodeData.get().map((n) => ({
      id: n.id,
      label: idToLabel(n.id),
      color: {
        background: "rgba(15,23,42,0.9)",
        border: nodeBaseColor(n.id),
        highlight: {
          background: nodeBaseColor(n.id),
          border: nodeBaseColor(n.id),
        },
      },
    }));
    nodeData.update(baseNodes);

    const baseEdges = edgeData.get().map((e) => ({
      id: e.id,
      color: { color: "rgba(148,163,184,0.7)" },
      width: 1.5,
    }));
    edgeData.update(baseEdges);

    if (step.highlightNode !== null && step.highlightNode !== undefined) {
      nodeData.update({
        id: step.highlightNode,
        color: {
          background: "rgba(74,222,128,0.5)",
          border: "#4ade80",
        },
      });
    }
    if (step.highlightEdge) {
      edgeData.update({
        id: step.highlightEdge,
        color: { color: "#4ade80" },
        width: 3,
      });
    }

    const source = parseInt(startNodeSelect.value, 10);
    updateDistancesDisplay(step.dist, step.relaxedNode, source);
    renderParentSubgraph(step.parent ?? new Map(), step.dist ?? new Map(), step.highlightNode);
    updateComplexityPanel(step);
    updateAlgorithmTable(step.parent ?? new Map(), step.dist ?? new Map());
    updateVariablePanel(step);
    updatePathReconstruction();
    updateAlgorithmStatistics(step);
    updatePerformanceMetrics(step);
    updateGraphStatistics();
    
    // Also update when there are no nodes (step might be null)
    const nodes = nodeData.get();
    if (!nodes.length) {
      updateAlgorithmStatistics(null);
      updatePerformanceMetrics(null);
    }
    highlightCurrentCode(step);

    if (step.negCycle) {
      flashStatus("Negative cycle detected reachable from source.", true);
    } else {
      flashStatus(step.label || "Step updated.");
    }
  }

  function updateAlgorithmTable(parentMap, distMap) {
    const tableHeaderRow = $("table-header-row");
    const tableNodesRow = $("table-nodes-row");
    const tableParentsRow = $("table-parents-row");
    const tableDistancesRow = $("table-distances-row");
    
    const nodes = nodeData.get().sort((a, b) => a.id - b.id);
    
    // Clear existing cells (except label cells)
    tableHeaderRow.innerHTML = "";
    tableNodesRow.innerHTML = '<td class="table-label">Node</td>';
    tableParentsRow.innerHTML = '<td class="table-label">Parent</td>';
    tableDistancesRow.innerHTML = '<td class="table-label">Distance</td>';
    
    // Add header row with node labels (using custom labels if present)
    nodes.forEach((n) => {
      const headerCell = document.createElement("th");
      const displayLabel = n.label || idToLabel(n.id);
      headerCell.textContent = displayLabel;
      headerCell.className = "table-header-cell";
      tableHeaderRow.appendChild(headerCell);
    });
    
    // Add node row
    nodes.forEach((n) => {
      const nodeCell = document.createElement("td");
      const displayLabel = n.label || idToLabel(n.id);
      nodeCell.textContent = displayLabel;
      nodeCell.className = "table-data-cell";
      tableNodesRow.appendChild(nodeCell);
    });
    
    // Add parent row
    nodes.forEach((n) => {
      const parentCell = document.createElement("td");
      const parentId = parentMap.get(n.id);
      if (parentId === null || parentId === undefined) {
        parentCell.textContent = "—";
      } else {
        const parentNode = nodeData.get(parentId);
        const parentLabel = parentNode?.label || idToLabel(parentId);
        parentCell.textContent = parentLabel;
      }
      parentCell.className = "table-data-cell";
      tableParentsRow.appendChild(parentCell);
    });
    
    // Add distance row
    nodes.forEach((n) => {
      const distCell = document.createElement("td");
      const d = distMap.get(n.id);
      distCell.textContent = d === undefined || d === Infinity ? "∞" : d.toFixed(2).replace(/\.00$/, "");
      distCell.className = "table-data-cell";
      if (d === Infinity || d === undefined) {
        distCell.classList.add("infinite");
      }
      tableDistancesRow.appendChild(distCell);
    });
  }

  function flashStatus(text, isError = false) {
    statusLabel.innerHTML = isError
      ? `<strong style="color:var(--danger)">${text}</strong>`
      : text;
  }

  function updateVariablePanel(step) {
    if (!variableListEl) return;
    variableListEl.innerHTML = "";

    if (!step) {
      return;
    }

    const algoKey = algorithmSelect.value;
    const nodes = nodeData.get().sort((a, b) => a.id - b.id);

    // Extract u, v, w from step (might be from/to/w or u/v/w)
    const u = step.u !== undefined ? step.u : step.from;
    const v = step.v !== undefined ? step.v : step.to;
    const w = step.w !== undefined ? step.w : (step.w !== undefined ? step.w : null);

    // Show iteration if available
    if (typeof step.iteration === "number") {
      const nameEl = document.createElement("div");
      nameEl.className = "variable-name";
      nameEl.textContent = "iteration";
      const valueEl = document.createElement("div");
      valueEl.className = "variable-value";
      valueEl.textContent = String(step.iteration);
      variableListEl.appendChild(nameEl);
      variableListEl.appendChild(valueEl);
    }

    // Show u, v, w if available (current edge being processed)
    if (u !== undefined && u !== null) {
      const nameEl = document.createElement("div");
      nameEl.className = "variable-name";
      nameEl.textContent = "u";
      const valueEl = document.createElement("div");
      valueEl.className = "variable-value";
      valueEl.textContent = idToLabel(u);
      variableListEl.appendChild(nameEl);
      variableListEl.appendChild(valueEl);
    }

    if (v !== undefined && v !== null) {
      const nameEl = document.createElement("div");
      nameEl.className = "variable-name";
      nameEl.textContent = "v";
      const valueEl = document.createElement("div");
      valueEl.className = "variable-value";
      valueEl.textContent = idToLabel(v);
      variableListEl.appendChild(nameEl);
      variableListEl.appendChild(valueEl);
    }

    if (w !== undefined && w !== null) {
      const nameEl = document.createElement("div");
      nameEl.className = "variable-name";
      nameEl.textContent = "w";
      const valueEl = document.createElement("div");
      valueEl.className = "variable-value";
      valueEl.textContent = String(w);
      variableListEl.appendChild(nameEl);
      variableListEl.appendChild(valueEl);
    }

    // Show d dictionary (all distances)
    if (step.dist && nodes.length > 0) {
      const nameEl = document.createElement("div");
      nameEl.className = "variable-name";
      nameEl.textContent = "d";
      const valueEl = document.createElement("div");
      valueEl.className = "variable-value";
      const dEntries = [];
      for (const n of nodes) {
        const d = step.dist.get(n.id);
        const label = n.label || idToLabel(n.id);
        const val = d === undefined || d === Infinity ? "∞" : d.toFixed(2).replace(/\.00$/, "");
        dEntries.push(`${label}: ${val}`);
      }
      valueEl.textContent = `{${dEntries.join(", ")}}`;
      variableListEl.appendChild(nameEl);
      variableListEl.appendChild(valueEl);
    }

    // Show parent dictionary (all parents)
    if (step.parent && nodes.length > 0) {
      const nameEl = document.createElement("div");
      nameEl.className = "variable-name";
      nameEl.textContent = "parent";
      const valueEl = document.createElement("div");
      valueEl.className = "variable-value";
      const parentEntries = [];
      for (const n of nodes) {
        const p = step.parent.get(n.id);
        const label = n.label || idToLabel(n.id);
        const parentLabel = p === null || p === undefined ? "None" : (nodeData.get(p)?.label || idToLabel(p));
        parentEntries.push(`${label}: ${parentLabel}`);
      }
      valueEl.textContent = `{${parentEntries.join(", ")}}`;
      variableListEl.appendChild(nameEl);
      variableListEl.appendChild(valueEl);
    }

    // Show queue for FIFO variant
    if (algoKey === "bellman-ford-fifo" && step.queueSnapshot) {
      const nameEl = document.createElement("div");
      nameEl.className = "variable-name";
      nameEl.textContent = "queue";
      const valueEl = document.createElement("div");
      valueEl.className = "variable-value";
      const queueLabels = step.queueSnapshot.map((id) => {
        const node = nodeData.get(id);
        return node?.label || idToLabel(id);
      });
      valueEl.textContent = queueLabels.length > 0 ? `[${queueLabels.join(", ")}]` : "[]";
      variableListEl.appendChild(nameEl);
      variableListEl.appendChild(valueEl);
    }
  }

  function updateComplexityPanel(step) {
    if (!timeBigOEl || !spaceBigOEl || !timeProgressEl || !spaceProgressEl) return;

    const algoKey = algorithmSelect.value;
    const n = nodeData.get().length;
    const m = edgeData.get().length;

    let timeO = "";
    let spaceO = "";
    let timeActual = "";
    let spaceActual = "";

    if (algoKey === "relaxation") {
      timeO = "O(V · E)";
      spaceO = "O(V + E)";
      if (n > 0 && m > 0) {
        const timeVal = n * m;
        const spaceVal = n + m;
        timeActual = ` = O(${n} · ${m}) = ${timeVal}`;
        spaceActual = ` = O(${n} + ${m}) = ${spaceVal}`;
      }
    } else if (algoKey === "bellman-ford") {
      timeO = "O(V · E)";
      spaceO = "O(V)";
      if (n > 0 && m > 0) {
        const timeVal = n * m;
        timeActual = ` = O(${n} · ${m}) = ${timeVal}`;
        spaceActual = ` = O(${n}) = ${n}`;
      }
    } else if (algoKey === "bellman-ford-fifo") {
      timeO = "O(V · E) worst-case";
      spaceO = "O(V + E)";
      if (n > 0 && m > 0) {
        const timeVal = n * m;
        const spaceVal = n + m;
        timeActual = ` = O(${n} · ${m}) = ${timeVal} (worst-case)`;
        spaceActual = ` = O(${n} + ${m}) = ${spaceVal}`;
      }
    } else if (algoKey === "dijkstra") {
      timeO = "O(V log V + E)";
      spaceO = "O(V)";
      if (n > 0 && m > 0) {
        const timeVal = n * Math.log2(Math.max(n, 2)) + m;
        timeActual = ` = O(${n} log ${n} + ${m}) ≈ ${Math.round(timeVal)}`;
        spaceActual = ` = O(${n}) = ${n}`;
      }
    } else if (algoKey === "prim") {
      timeO = "O(V log V + E)";
      spaceO = "O(V)";
      if (n > 0 && m > 0) {
        const timeVal = n * Math.log2(Math.max(n, 2)) + m;
        timeActual = ` = O(${n} log ${n} + ${m}) ≈ ${Math.round(timeVal)}`;
        spaceActual = ` = O(${n}) = ${n}`;
      }
    } else if (algoKey === "bfs" || algoKey === "dfs") {
      timeO = "O(V + E)";
      spaceO = "O(V + E)";
      if (n > 0 && m > 0) {
        const timeVal = n + m;
        const spaceVal = n + m;
        timeActual = ` = O(${n} + ${m}) = ${timeVal}`;
        spaceActual = ` = O(${n} + ${m}) = ${spaceVal}`;
      }
    }

    // Update time complexity
    const existingTimeActual = timeBigOEl.querySelector(".complexity-actual");
    if (existingTimeActual) existingTimeActual.remove();
    timeBigOEl.textContent = timeO || "—";
    if (timeActual) {
      const actualEl = document.createElement("span");
      actualEl.className = "complexity-actual";
      actualEl.textContent = timeActual;
      timeBigOEl.appendChild(actualEl);
    }

    // Update space complexity
    const existingSpaceActual = spaceBigOEl.querySelector(".complexity-actual");
    if (existingSpaceActual) existingSpaceActual.remove();
    spaceBigOEl.textContent = spaceO || "—";
    if (spaceActual) {
      const actualEl = document.createElement("span");
      actualEl.className = "complexity-actual";
      actualEl.textContent = spaceActual;
      spaceBigOEl.appendChild(actualEl);
    }

    if (!steps.length || !step) {
      timeProgressEl.textContent = "";
      spaceProgressEl.textContent = n || m ? `n = ${n}, m = ${m}` : "";
      return;
    }

    const opsDone = currentStepIndex + 1;
    const totalOps = steps.length;
    let timeProgress = `${opsDone}/${totalOps} steps executed`;

    if (algoKey === "bellman-ford-fifo" && step.queueSnapshot) {
      timeProgress += ` · queue size: ${step.queueSnapshot.length}`;
    }

    let spaceProgress = `n = ${n}, m = ${m}`;
    if (algoKey === "bellman-ford-fifo" && step.queueSnapshot) {
      spaceProgress += ` · queue ≤ ${n}`;
    }

    timeProgressEl.textContent = timeProgress;
    spaceProgressEl.textContent = spaceProgress;
  }

  function updateStepControls() {
    const hasSteps = steps.length > 0;
    const nodes = nodeData.get();
    const source = parseInt(startNodeSelect.value, 10);
    const canCreateSteps = nodes.length > 0 && !Number.isNaN(source);
    
    btnPrev.disabled = !hasSteps || currentStepIndex <= 0;
    // Enable Next button if we have steps and not at the end, OR if we can create steps
    btnNext.disabled = hasSteps ? (currentStepIndex >= steps.length - 1) : !canCreateSteps;
  }

  // --- Stepper controls --------------------------------------------------
  function ensureSteps() {
    const nodes = nodeData.get();
    if (!nodes.length) {
      flashStatus("Create at least one node for the algorithm to run.", true);
      return false;
    }
    const source = parseInt(startNodeSelect.value, 10);
    if (Number.isNaN(source)) {
      flashStatus("Select a source node.", true);
      return false;
    }
    if (!steps.length) {
      const algo = algorithmSelect.value;
      if (algo === "relaxation") {
        steps = createRelaxationSteps(source, "relaxation", computeGraphFromState);
      } else if (algo === "bellman-ford") {
        steps = createBellmanFordSteps(source, false, computeGraphFromState);
      } else if (algo === "bellman-ford-fifo") {
        steps = createBellmanFordSteps(source, true, computeGraphFromState);
      } else if (algo === "dijkstra") {
        steps = createDijkstraSteps(source, computeGraphFromState);
      } else if (algo === "prim") {
        steps = createPrimSteps(source, computeGraphFromState);
      } else if (algo === "bfs") {
        steps = createBFSSteps(source, computeGraphFromState);
      } else if (algo === "dfs") {
        steps = createDFSSteps(source, computeGraphFromState);
      } else {
        steps = createBellmanFordSteps(source, true, computeGraphFromState);
      }
      stepTotalLabel.textContent = String(steps.length);
      currentStepIndex = 0;
    }
    updateStepControls();
    return true;
  }

  btnNext.addEventListener("click", () => {
    stopAutoPlay();
    if (!ensureSteps()) return;
    if (currentStepIndex < steps.length - 1) {
      currentStepIndex++;
    }
    applyStepVisual(steps[currentStepIndex]);
    updateStepControls();
  });

  btnPrev.addEventListener("click", () => {
    stopAutoPlay();
    if (!ensureSteps()) return;
    if (currentStepIndex > 0) {
      currentStepIndex--;
    }
    applyStepVisual(steps[currentStepIndex]);
    updateStepControls();
  });

  btnRestart.addEventListener("click", () => {
    if (!ensureSteps()) return;
    currentStepIndex = 0;
    applyStepVisual(steps[currentStepIndex]);
    updateStepControls();
  });

  btnRunAuto.addEventListener("click", () => {
    if (autoPlayTimer) {
      stopAutoPlay();
      flashStatus("Auto play paused.");
      return;
    }
    if (!ensureSteps()) return;
    if (currentStepIndex >= steps.length - 1) currentStepIndex = 0;
    const baseSpeed = 800;
    const factor = parseFloat(speedRange.value) || 1;
    const interval = baseSpeed / factor;
    applyStepVisual(steps[currentStepIndex]);
    autoPlayTimer = setInterval(() => {
      if (currentStepIndex >= steps.length - 1) {
        stopAutoPlay();
        flashStatus("Finished all steps.");
        updateStepControls();
        return;
      }
      currentStepIndex++;
      applyStepVisual(steps[currentStepIndex]);
      updateStepControls();
    }, interval);
    flashStatus("Auto play running. Click again to pause.");
  });

  // --- Algorithm Information ----------------------------------------------
  // ALGORITHM_INFO is now imported from algorithm-info/info.js
  const ALGORITHM_INFO_OLD = {
    relaxation: {
      description: "Single-Source Shortest Path using relaxation technique. Iteratively relaxes all edges (V-1) times to find shortest paths from a source node.",
      useCases: "• Works for graphs with negative edges\n• Simple to understand\n• Good for small graphs\n• Can detect some negative cycles",
      differences: "Uses a fixed number of iterations (V-1) regardless of convergence."
    },
    "bellman-ford": {
      description: "Bellman-Ford algorithm finds shortest paths from a source to all nodes, even with negative edge weights. Detects negative cycles.",
      useCases: "• Graphs with negative edge weights\n• Detecting negative cycles\n• When Dijkstra's cannot be used\n• Network routing protocols",
      differences: "Always performs V-1 passes, then checks for negative cycles in a final pass."
    },
    "bellman-ford-fifo": {
      description: "Bellman-Ford optimized with FIFO queue. Only processes nodes whose distances were updated, potentially faster than standard Bellman-Ford.",
      useCases: "• Graphs with negative edges\n• When most nodes don't need updates\n• Faster than standard Bellman-Ford in practice\n• Network routing",
      differences: "Uses a queue to only process updated nodes, reducing unnecessary work. Still detects negative cycles."
    },
    dijkstra: {
      description: "Dijkstra's algorithm finds shortest paths from a source to all nodes using a greedy approach with a priority queue. Requires non-negative edge weights.",
      useCases: "• Graphs with non-negative edge weights\n• Faster than Bellman-Ford for dense graphs\n• GPS navigation systems\n• Network routing (OSPF, IS-IS)\n• Social network analysis",
      differences: "Uses a priority queue to always process the closest unvisited node first. Greedy approach ensures optimality for non-negative weights. Time complexity O(V log V + E) with binary heap."
    },
    prim: {
      description: "Prim's algorithm constructs a Minimum Spanning Tree (MST) by greedily adding the minimum-weight edge that connects a node in the MST to a node outside it. Works on connected, undirected graphs.",
      useCases: "• Finding minimum spanning trees\n• Network design (minimum cost connections)\n• Cluster analysis\n• Approximation algorithms\n• Circuit design",
      differences: "Similar to Dijkstra's but builds an MST instead of shortest paths. Always picks the minimum-weight edge connecting MST to non-MST nodes. Time complexity O(V log V + E) with binary heap."
    },
    bfs: {
      description: "Breadth-First Search (BFS) explores the graph level by level from a source node, discovering all nodes at distance 1, then distance 2, and so on.",
      useCases: "• Shortest paths in unweighted graphs\n• Level-order traversal of trees\n• Finding connected components\n• Social network \"degrees of separation\" queries",
      differences: "Uses a FIFO queue and always expands the current frontier before moving to the next. For unweighted graphs, BFS gives true shortest path trees in O(V + E)."
    },
    dfs: {
      description: "Depth-First Search (DFS) explores as far as possible along each branch before backtracking, building a depth-first spanning tree.",
      useCases: "• Detecting cycles\n• Topological sorting (on DAGs)\n• Finding connected components\n• Exploring and generating mazes/trees",
      differences: "Uses an implicit or explicit stack instead of a queue. DFS follows one path deeply before exploring siblings, producing a DFS tree that can differ significantly from BFS or shortest-path trees."
    },
  };

  function updateAlgorithmInfo() {
    if (!algorithmInfoPanel) return;
    const algo = algorithmSelect.value;
    const info = ALGORITHM_INFO[algo] || {};
    const descEl = algorithmInfoPanel.querySelector("#algorithm-description");
    const useCasesEl = algorithmInfoPanel.querySelector("#algorithm-use-cases");
    const diffEl = algorithmInfoPanel.querySelector("#algorithm-differences");
    
    if (descEl) descEl.innerHTML = `<p><strong>Description:</strong> ${info.description || "No description available."}</p>`;
    if (useCasesEl) useCasesEl.innerHTML = `<p><strong>Use Cases:</strong><br>${(info.useCases || "N/A").replace(/\n/g, "<br>")}</p>`;
    if (diffEl) diffEl.innerHTML = `<p><strong>Key Differences:</strong> ${info.differences || "N/A"}</p>`;
  }

  // --- Graph Statistics ----------------------------------------------------
  function updateGraphStatistics() {
    if (!graphStatsPanel) return;
    const nodes = nodeData.get();
    const edges = edgeData.get();
    const n = nodes.length;
    const m = edges.length;
    
    const statsContent = graphStatsPanel.querySelector("#graph-stats-content");
    if (!statsContent) return;
    
    // Calculate statistics
    const directed = chkDirected.checked;
    const density = n > 1 ? (m / (n * (n - 1) * (directed ? 1 : 2))).toFixed(3) : "0";
    const avgDegree = n > 0 ? (m / n).toFixed(2) : "0";
    
    // Check for negative edges
    const hasNegativeEdges = edges.some(e => {
      const w = e.weight ?? parseFloat(e.label);
      return w < 0;
    });
    
    // Check connectivity (simple check - if all nodes have at least one edge)
    const isolatedNodes = nodes.filter(n => {
      return !edges.some(e => e.from === n.id || e.to === n.id);
    });
    const isConnected = isolatedNodes.length === 0 && n > 0;
    
    statsContent.innerHTML = `
      <div class="stat-item">
        <span class="stat-label">Nodes (V)</span>
        <span class="stat-value">${n}</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Edges (E)</span>
        <span class="stat-value">${m}</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Graph Density</span>
        <span class="stat-value">${density}</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Avg Degree</span>
        <span class="stat-value">${avgDegree}</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Type</span>
        <span class="stat-value">${directed ? "Directed" : "Undirected"}</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Has Negative Edges</span>
        <span class="stat-value" style="color: ${hasNegativeEdges ? "#f97316" : "#4ade80"}">${hasNegativeEdges ? "Yes" : "No"}</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Connected</span>
        <span class="stat-value" style="color: ${isConnected ? "#4ade80" : "#f97316"}">${isConnected ? "Yes" : "No"}</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Isolated Nodes</span>
        <span class="stat-value">${isolatedNodes.length}</span>
      </div>
    `;
  }

  // --- Path Reconstruction -------------------------------------------------
  function reconstructPath(targetId, parentMap, distMap) {
    if (targetId === null || targetId === undefined) return null;
    const source = parseInt(startNodeSelect.value, 10);
    if (Number.isNaN(source)) return null;
    
    const path = [];
    let current = targetId;
    const visited = new Set();
    
    while (current !== null && current !== undefined && !visited.has(current)) {
      visited.add(current);
      path.unshift(current);
      if (current === source) break;
      current = parentMap.get(current);
      if (visited.size > 100) break; // Prevent infinite loops
    }
    
    if (path[0] !== source) return null; // No path exists
    return path;
  }

  function updatePathReconstruction() {
    if (!pathReconstructionPanel || !pathTargetSelect) return;
    
    const nodes = nodeData.get().sort((a, b) => a.id - b.id);
    pathTargetSelect.innerHTML = '<option value="">Select target...</option>';
    
    nodes.forEach(n => {
      const opt = document.createElement("option");
      opt.value = String(n.id);
      opt.textContent = n.label || idToLabel(n.id);
      pathTargetSelect.appendChild(opt);
    });
    
    if (steps.length > 0 && currentStepIndex >= 0) {
      const step = steps[currentStepIndex];
      if (step && step.parent && step.dist) {
        pathTargetSelect.addEventListener("change", () => {
          const targetId = parseInt(pathTargetSelect.value, 10);
          if (Number.isNaN(targetId)) {
            pathDisplay.textContent = "";
            pathVisual.innerHTML = "";
            return;
          }
          
          const path = reconstructPath(targetId, step.parent, step.dist);
          if (path) {
            const pathLabels = path.map(id => {
              const node = nodeData.get(id);
              return node?.label || idToLabel(id);
            });
            const dist = step.dist.get(targetId);
            const distStr = dist === Infinity || dist === undefined ? "∞" : dist.toFixed(2);
            
            pathDisplay.textContent = `Path: ${pathLabels.join(" → ")} | Distance: ${distStr}`;
            
            // Visual path
            pathVisual.innerHTML = path.map((id, idx) => {
              const node = nodeData.get(id);
              const label = node?.label || idToLabel(id);
              return `<span class="path-node">${label}</span>${idx < path.length - 1 ? '<span class="path-arrow">→</span>' : ''}`;
            }).join('');
            
            // Highlight path on graph
            highlightPathOnGraph(path);
          } else {
            pathDisplay.textContent = "No path exists from source to target.";
            pathVisual.innerHTML = "";
          }
        });
      }
    }
  }

  function highlightPathOnGraph(path) {
    if (!path || path.length < 2) return;
    
    // Reset all edges
    const allEdges = edgeData.get();
    allEdges.forEach(e => {
      edgeData.update({
        id: e.id,
        color: { color: "rgba(148,163,184,0.7)" },
        width: 1.5,
      });
    });
    
    // Highlight path edges
    for (let i = 0; i < path.length - 1; i++) {
      const from = path[i];
      const to = path[i + 1];
      const edge = allEdges.find(e => e.from === from && e.to === to);
      if (edge) {
        edgeData.update({
          id: edge.id,
          color: { color: "#4ade80" },
          width: 3,
        });
      }
    }
  }

  // --- Algorithm Statistics ------------------------------------------------
  function updateAlgorithmStatistics(step) {
    if (!algorithmStatsPanel) return;
    const statsContent = algorithmStatsPanel.querySelector("#algorithm-stats-content");
    if (!statsContent) return;
    
    const nodes = nodeData.get();
    if (!nodes.length) {
      statsContent.innerHTML = "<div class='stat-item'><span class='stat-label' style='color: var(--text-soft);'>No nodes in the graph. Add nodes to see algorithm statistics.</span></div>";
      return;
    }
    
    if (!step || !steps.length) {
      statsContent.innerHTML = "<div class='stat-item'><span class='stat-label' style='color: var(--text-soft);'>No algorithm running. Select a source node and run an algorithm.</span></div>";
      return;
    }
    
    const relaxations = steps.slice(0, currentStepIndex + 1).filter(s => s.relaxedNode !== null && s.relaxedNode !== undefined).length;
    const nodesVisited = new Set();
    steps.slice(0, currentStepIndex + 1).forEach(s => {
      if (s.highlightNode !== null && s.highlightNode !== undefined) nodesVisited.add(s.highlightNode);
      if (s.u !== undefined) nodesVisited.add(s.u);
      if (s.v !== undefined) nodesVisited.add(s.v);
    });
    
    const edgesProcessed = steps.slice(0, currentStepIndex + 1).filter(s => s.highlightEdge).length;
    const queueSize = step.queueSnapshot ? step.queueSnapshot.length : 0;
    
    statsContent.innerHTML = `
      <div class="stat-item">
        <span class="stat-label">Steps Executed</span>
        <span class="stat-value">${currentStepIndex + 1} / ${steps.length}</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Relaxations</span>
        <span class="stat-value">${relaxations}</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Nodes Visited</span>
        <span class="stat-value">${nodesVisited.size}</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Edges Processed</span>
        <span class="stat-value">${edgesProcessed}</span>
      </div>
      ${algorithmSelect.value === "bellman-ford-fifo" ? `
      <div class="stat-item">
        <span class="stat-label">Queue Size</span>
        <span class="stat-value">${queueSize}</span>
      </div>
      ` : ''}
    `;
  }

  // --- Performance Metrics ------------------------------------------------
  function updatePerformanceMetrics(step) {
    if (!performancePanel) return;
    const perfContent = performancePanel.querySelector("#performance-content");
    if (!perfContent) return;
    
    const nodes = nodeData.get();
    if (!nodes.length) {
      perfContent.innerHTML = "<div class='stat-item'><span class='stat-label' style='color: var(--text-soft);'>No nodes in the graph. Add nodes to see performance metrics.</span></div>";
      return;
    }
    
    if (!step || !steps.length) {
      perfContent.innerHTML = "<div class='stat-item'><span class='stat-label' style='color: var(--text-soft);'>No algorithm running. Select a source node and run an algorithm.</span></div>";
      return;
    }
    
    const totalSteps = steps.length;
    const progress = ((currentStepIndex + 1) / totalSteps) * 100;
    const startTime = performance.now();
    
    perfContent.innerHTML = `
      <div class="stat-item">
        <span class="stat-label">Progress</span>
        <span class="stat-value">${progress.toFixed(1)}%</span>
      </div>
      <div class="performance-bar">
        <div class="performance-fill" style="width: ${progress}%"></div>
      </div>
      <div class="stat-item">
        <span class="stat-label">Operations/sec</span>
        <span class="stat-value">${(currentStepIndex + 1).toFixed(0)}</span>
      </div>
    `;
  }

  // --- Export/Import -------------------------------------------------------
  function exportGraph() {
    const nodes = nodeData.get();
    const edges = edgeData.get();
    const graphData = {
      nodes: nodes.map(n => ({
        id: n.id,
        label: n.label || idToLabel(n.id),
        x: n.x,
        y: n.y
      })),
      edges: edges.map(e => ({
        from: e.from,
        to: e.to,
        weight: e.weight ?? parseFloat(e.label),
        label: e.label,
        arrows: e.arrows
      })),
      directed: chkDirected.checked,
      metadata: {
        exportedAt: new Date().toISOString(),
        nodeCount: nodes.length,
        edgeCount: edges.length
      }
    };
    
    const dataStr = JSON.stringify(graphData, null, 2);
    const dataBlob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `graph_${Date.now()}.json`;
    link.click();
    URL.revokeObjectURL(url);
    flashStatus("Graph exported successfully.");
  }

  function importGraph() {
    importFileInput.click();
  }

  importFileInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const graphData = JSON.parse(event.target.result);
        resetGraph();
        
        // Import nodes
        graphData.nodes.forEach(n => {
          nodeData.add({
            id: n.id,
            label: n.label || idToLabel(n.id),
            color: {
              background: "rgba(15,23,42,0.9)",
              border: nodeBaseColor(n.id),
            },
            x: n.x,
            y: n.y
          });
        });
        
        // Import edges
        graphData.edges.forEach(e => {
          edgeData.add({
            id: `${e.from}-${e.to}-${Date.now()}`,
            from: e.from,
            to: e.to,
            label: String(e.weight ?? e.label),
            weight: e.weight ?? parseFloat(e.label),
            arrows: graphData.directed ? (e.arrows || "to") : ""
          });
        });
        
        if (graphData.directed !== undefined) {
          chkDirected.checked = graphData.directed;
        }
        
        refreshStartNodeOptions();
        updateGraphStatistics();
        graphNetwork.fit({ animation: false });
        flashStatus("Graph imported successfully.");
      } catch (err) {
        flashStatus("Error importing graph: " + err.message, true);
      }
    };
    reader.readAsText(file);
    e.target.value = ""; // Reset input
  });

  // --- Enhanced Controls ---------------------------------------------------
  btnPause.addEventListener("click", () => {
    if (isPaused) {
      // Resume
      isPaused = false;
      btnPause.textContent = "⏸ Pause";
      btnRunAuto.textContent = "Auto Play";
      if (autoPlayTimer) {
        const baseSpeed = 800;
        const factor = parseFloat(speedRange.value) || 1;
        const interval = baseSpeed / factor;
        autoPlayTimer = setInterval(() => {
          if (currentStepIndex >= steps.length - 1) {
            stopAutoPlay();
            flashStatus("Finished all steps.");
            updateStepControls();
            return;
          }
          currentStepIndex++;
          applyStepVisual(steps[currentStepIndex]);
          updateStepControls();
        }, interval);
      }
    } else {
      // Pause
      isPaused = true;
      stopAutoPlay();
      btnPause.textContent = "▶ Resume";
    }
  });

  btnJump.addEventListener("click", () => {
    const targetStep = parseInt(stepJumpInput.value, 10) - 1;
    if (!Number.isNaN(targetStep) && targetStep >= 0 && targetStep < steps.length) {
      stopAutoPlay();
      currentStepIndex = targetStep;
      applyStepVisual(steps[currentStepIndex]);
      updateStepControls();
      stepJumpInput.value = "";
      flashStatus(`Jumped to step ${targetStep + 1}`);
    }
  });

  chkLabels.addEventListener("change", () => {
    labelsVisible = chkLabels.checked;
    const nodes = nodeData.get();
    nodes.forEach(n => {
      nodeData.update({
        id: n.id,
        label: labelsVisible ? (n.label || idToLabel(n.id)) : ""
      });
    });
  });

  // --- Edge Weight Editor --------------------------------------------------
  let editingEdge = null;
  let edgeWeightEditor = null;

  graphNetwork.on("oncontext", (params) => {
    params.event.preventDefault();
    const pointer = graphNetwork.getPositions([params.nodes[0]]);
    if (params.nodes.length > 0) {
      // Node context menu could go here
    } else if (params.edges.length > 0) {
      const edgeId = params.edges[0];
      const edge = edgeData.get(edgeId);
      if (edge) {
        editingEdge = edge;
        showEdgeWeightEditor(params.event, edge);
      }
    }
  });

  function showEdgeWeightEditor(event, edge) {
    if (edgeWeightEditor) {
      document.body.removeChild(edgeWeightEditor);
    }
    
    edgeWeightEditor = document.createElement("div");
    edgeWeightEditor.className = "edge-weight-editor";
    edgeWeightEditor.style.left = event.clientX + "px";
    edgeWeightEditor.style.top = event.clientY + "px";
    
    const input = document.createElement("input");
    input.type = "number";
    input.step = "0.1";
    input.value = edge.weight ?? parseFloat(edge.label);
    
    const saveBtn = document.createElement("button");
    saveBtn.textContent = "Save";
    saveBtn.onclick = () => {
      const newWeight = parseFloat(input.value);
      if (!Number.isNaN(newWeight)) {
        edgeData.update({
          id: edge.id,
          label: String(newWeight),
          weight: newWeight
        });
        updateGraphStatistics();
        clearSteps();
        flashStatus("Edge weight updated.");
      }
      document.body.removeChild(edgeWeightEditor);
      edgeWeightEditor = null;
      editingEdge = null;
    };
    
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = "Cancel";
    cancelBtn.onclick = () => {
      document.body.removeChild(edgeWeightEditor);
      edgeWeightEditor = null;
      editingEdge = null;
    };
    
    edgeWeightEditor.appendChild(input);
    edgeWeightEditor.appendChild(saveBtn);
    edgeWeightEditor.appendChild(cancelBtn);
    document.body.appendChild(edgeWeightEditor);
    
    input.focus();
    input.select();
  }

  // --- Comparison Mode ----------------------------------------------------
  function showComparisonMode() {
    comparisonMode = true;
    comparisonModal.style.display = "flex";
    
    const comparisonContent = comparisonModal.querySelector("#comparison-content");
    if (!comparisonContent) return;
    
    const nodes = nodeData.get();
    const source = parseInt(startNodeSelect.value, 10);
    if (!nodes.length || Number.isNaN(source)) {
      flashStatus("Create a graph and select a source node first.", true);
      comparisonModal.style.display = "none";
      return;
    }
    
    const algorithms = ["relaxation", "bellman-ford", "bellman-ford-fifo", "dijkstra", "bfs", "dfs"];
    comparisonContent.innerHTML = "";
    
    algorithms.forEach(algo => {
      try {
        let algoSteps = [];
          if (algo === "relaxation") {
            algoSteps = createRelaxationSteps(source, "relaxation", computeGraphFromState);
          } else if (algo === "bellman-ford") {
            algoSteps = createBellmanFordSteps(source, false, computeGraphFromState);
          } else if (algo === "bellman-ford-fifo") {
            algoSteps = createBellmanFordSteps(source, true, computeGraphFromState);
          } else if (algo === "dijkstra") {
            algoSteps = createDijkstraSteps(source, computeGraphFromState);
          } else if (algo === "prim") {
            algoSteps = createPrimSteps(source, computeGraphFromState);
          } else if (algo === "bfs") {
            algoSteps = createBFSSteps(source, computeGraphFromState);
          } else if (algo === "dfs") {
            algoSteps = createDFSSteps(source, computeGraphFromState);
          }
        
        const finalStep = algoSteps[algoSteps.length - 1];
        const relaxations = algoSteps.filter(s => s.relaxedNode !== null).length;
        
        const item = document.createElement("div");
        item.className = "comparison-item";
        item.innerHTML = `
          <h3>${algo.replace(/-/g, " ").replace(/\b\w/g, l => l.toUpperCase())}</h3>
          <div class="stat-row">
            <span>Total Steps:</span>
            <span>${algoSteps.length}</span>
          </div>
          <div class="stat-row">
            <span>Relaxations:</span>
            <span>${relaxations}</span>
          </div>
          <div class="stat-row">
            <span>Time Complexity:</span>
            <span>${
              algo === "dijkstra" || algo === "prim"
                ? "O(V log V + E)"
                : algo === "bfs" || algo === "dfs"
                ? "O(V + E)"
                : "O(V · E)"
            }</span>
          </div>
        `;
        comparisonContent.appendChild(item);
      } catch (err) {
        // Algorithm not available
      }
    });
  }

  $("btn-close-comparison").addEventListener("click", () => {
    comparisonModal.style.display = "none";
    comparisonMode = false;
  });

  // --- Tutorial/Help -------------------------------------------------------
  const TUTORIAL_STEPS = [
    {
      title: "Welcome!",
      content: "This visualizer helps you understand shortest path algorithms. Start by building a graph or selecting a preset."
    },
    {
      title: "Building a Graph",
      content: "Click '+ Node' to add nodes. Enter a custom label (optional). Add edges by specifying 'from', 'to', and 'weight' values."
    },
    {
      title: "Running Algorithms",
      content: "Select an algorithm from the dropdown, choose a source node, then click 'Next' to step through or 'Auto Play' to animate."
    },
    {
      title: "Understanding the Visualization",
      content: "Watch how distances update in the table, see the parent tree form, and observe the code execution. Green highlights show active operations."
    },
    {
      title: "Path Reconstruction",
      content: "Use the Path Reconstruction panel to see the actual shortest path from source to any target node. The path will be highlighted on the graph."
    },
    {
      title: "Export & Import",
      content: "Save your graphs as JSON files and load them later. Great for sharing examples or saving your work."
    }
  ];

  function showTutorial() {
    tutorialModal.style.display = "flex";
    const tutorialContent = tutorialModal.querySelector("#tutorial-content");
    if (!tutorialContent) return;
    
    tutorialContent.innerHTML = TUTORIAL_STEPS.map((step, idx) => `
      <div class="tutorial-step">
        <h3>Step ${idx + 1}: ${step.title}</h3>
        <p>${step.content}</p>
      </div>
    `).join("");
  }

  $("btn-close-tutorial").addEventListener("click", () => {
    tutorialModal.style.display = "none";
  });

  // --- Info Panel Toggles --------------------------------------------------
  document.querySelectorAll(".info-panel-toggle").forEach(toggle => {
    toggle.addEventListener("click", () => {
      const panel = toggle.closest(".info-panel");
      if (panel) {
        panel.classList.toggle("collapsed");
        toggle.textContent = panel.classList.contains("collapsed") ? "+" : "−";
      }
    });
  });

  // --- Event Listeners for New Features ------------------------------------
  if (btnAlgorithmInfo) {
    btnAlgorithmInfo.addEventListener("click", () => {
      algorithmInfoPanel.classList.toggle("collapsed");
      const toggle = algorithmInfoPanel.querySelector(".info-panel-toggle");
      if (toggle) toggle.textContent = algorithmInfoPanel.classList.contains("collapsed") ? "+" : "−";
      updateAlgorithmInfo();
    });
  }

  if (btnHelp) btnHelp.addEventListener("click", showTutorial);
  if (btnExport) btnExport.addEventListener("click", exportGraph);
  if (btnImport) btnImport.addEventListener("click", importGraph);
  if (btnCompare) btnCompare.addEventListener("click", showComparisonMode);

  // Update algorithm info when algorithm changes
  algorithmSelect.addEventListener("change", () => {
    updateAlgorithmInfo();
    renderPseudoAndCode();
    clearSteps();
  });

  // Update statistics when graph changes
  nodeData.on("add", () => {
    updateGraphStatistics();
    const nodes = nodeData.get();
    if (!nodes.length) {
      updateAlgorithmStatistics(null);
      updatePerformanceMetrics(null);
    }
  });
  nodeData.on("remove", () => {
    updateGraphStatistics();
    const nodes = nodeData.get();
    if (!nodes.length) {
      updateAlgorithmStatistics(null);
      updatePerformanceMetrics(null);
    }
  });
  nodeData.on("update", updateGraphStatistics);
  edgeData.on("add", updateGraphStatistics);
  edgeData.on("remove", updateGraphStatistics);
  edgeData.on("update", updateGraphStatistics);

  // --- Initial state -----------------------------------------------------
  // Initialize toggle button states for all panels
  document.querySelectorAll(".info-panel").forEach(panel => {
    const toggle = panel.querySelector(".info-panel-toggle");
    if (toggle) {
      toggle.textContent = panel.classList.contains("collapsed") ? "+" : "−";
    }
  });
  
  // Initialize labels checkbox state
  if (chkLabels) {
    labelsVisible = chkLabels.checked;
  }
  
  // Update algorithm info (even if collapsed)
  updateAlgorithmInfo();
  
  // Initialize source node dropdown
  refreshStartNodeOptions();
  
  // Check if there are no nodes and update panels accordingly
  const initialNodes = nodeData.get();
  if (!initialNodes.length) {
    updateAlgorithmStatistics(null);
    updatePerformanceMetrics(null);
  }
  
  renderPseudoAndCode();
  // Set initial panel title based on selected algorithm
  const initialAlgoKey = algorithmSelect.value;
  const parentSubgraphTitle = document.getElementById("parent-subgraph-title");
  if (parentSubgraphTitle) {
    if (initialAlgoKey === "prim" || initialAlgoKey === "kruskal") {
      parentSubgraphTitle.textContent = "MST (Minimum Spanning Tree)";
    } else {
      parentSubgraphTitle.textContent = "Parent Subgraph";
    }
  }
  if (speedValueLabel && speedRange) {
    speedValueLabel.textContent = `${parseFloat(speedRange.value).toFixed(1)}x`;
    speedRange.addEventListener("input", () => {
      speedValueLabel.textContent = `${parseFloat(speedRange.value).toFixed(1)}x`;
    });
    // Allow controlling speed slider with mouse wheel
    speedRange.addEventListener("wheel", (event) => {
      event.preventDefault();
      const step = parseFloat(speedRange.step) || 0.1;
      const min = parseFloat(speedRange.min) || 0.1;
      const max = parseFloat(speedRange.max) || 2.0;
      const delta = event.deltaY < 0 ? step : -step;
      let next = parseFloat(speedRange.value) + delta;
      if (Number.isNaN(next)) next = 1;
      next = Math.min(max, Math.max(min, next));
      // Snap to one decimal
      next = Math.round(next * 10) / 10;
      speedRange.value = String(next);
      speedValueLabel.textContent = `${next.toFixed(1)}x`;
    }, { passive: false });
  }
  updateStepControls();
  updateComplexityPanel(null);
  flashStatus("Ready. Build a graph or choose a preset to begin.");

  // --- Panel Resize Functionality -----------------------------------------
  const appMain = document.querySelector('.app-main');
  const leftPanel = document.querySelector('.panel-parent');
  const middlePanel = document.querySelector('.panel-graph');
  const rightPanel = document.querySelector('.panel-code');
  const resizeHandleLeft = $('resize-handle-left');
  const resizeHandleRight = $('resize-handle-right');

  // Load saved widths from localStorage
  function loadPanelWidths() {
    const savedLeft = localStorage.getItem('panel-left-width');
    const savedMiddle = localStorage.getItem('panel-middle-width');
    const savedRight = localStorage.getItem('panel-right-width');
    
    if (savedLeft) {
      document.documentElement.style.setProperty('--panel-left-width', savedLeft);
    }
    if (savedMiddle) {
      document.documentElement.style.setProperty('--panel-middle-width', savedMiddle);
    }
    if (savedRight) {
      document.documentElement.style.setProperty('--panel-right-width', savedRight);
    }
  }

  // Save widths to localStorage
  function savePanelWidths() {
    const leftWidth = getComputedStyle(document.documentElement).getPropertyValue('--panel-left-width');
    const middleWidth = getComputedStyle(document.documentElement).getPropertyValue('--panel-middle-width');
    const rightWidth = getComputedStyle(document.documentElement).getPropertyValue('--panel-right-width');
    
    if (leftWidth) localStorage.setItem('panel-left-width', leftWidth.trim());
    if (middleWidth) localStorage.setItem('panel-middle-width', middleWidth.trim());
    if (rightWidth) localStorage.setItem('panel-right-width', rightWidth.trim());
  }

  // Initialize with saved widths
  loadPanelWidths();

  // Resize handler for panel dividers
  function setupResizeHandle(handle, panel1, panel2, isLeftHandle) {
    let isResizing = false;
    let startX = 0;
    let startPanel1Width = 0;
    let startPanel2Width = 0;
    let startPanel3Width = 0;

    handle.addEventListener('mousedown', (e) => {
      isResizing = true;
      handle.classList.add('resizing');
      startX = e.clientX;
      
      const appMainRect = appMain.getBoundingClientRect();
      const panel1Rect = panel1.getBoundingClientRect();
      const panel2Rect = panel2.getBoundingClientRect();
      const panel3Rect = isLeftHandle ? rightPanel.getBoundingClientRect() : leftPanel.getBoundingClientRect();
      
      startPanel1Width = (panel1Rect.width / appMainRect.width) * 100;
      startPanel2Width = (panel2Rect.width / appMainRect.width) * 100;
      startPanel3Width = (panel3Rect.width / appMainRect.width) * 100;

      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;

      const appMainRect = appMain.getBoundingClientRect();
      const deltaX = e.clientX - startX;
      const deltaPercent = (deltaX / appMainRect.width) * 100;

      let newPanel1Width = startPanel1Width + deltaPercent;
      let newPanel2Width = startPanel2Width - deltaPercent;

      // Apply min/max constraints
      if (isLeftHandle) {
        // Left panel: min 260px, max 50%
        const minLeftPx = 260;
        const minLeftPercent = (minLeftPx / appMainRect.width) * 100;
        const maxLeftPercent = 50;
        newPanel1Width = Math.max(minLeftPercent, Math.min(maxLeftPercent, newPanel1Width));
        
        // Middle panel: min 360px
        const minMiddlePx = 360;
        const minMiddlePercent = (minMiddlePx / appMainRect.width) * 100;
        newPanel2Width = Math.max(minMiddlePercent, newPanel2Width);
        
        // Ensure right panel doesn't get too small (min 280px)
        const minRightPx = 280;
        const minRightPercent = (minRightPx / appMainRect.width) * 100;
        const remainingForRight = 100 - newPanel1Width - newPanel2Width;
        
        if (remainingForRight < minRightPercent) {
          newPanel2Width = 100 - newPanel1Width - minRightPercent;
        }
        
        document.documentElement.style.setProperty('--panel-left-width', `${newPanel1Width}%`);
        document.documentElement.style.setProperty('--panel-middle-width', `${newPanel2Width}%`);
      } else {
        // Right panel: min 280px, max 50%
        const minRightPx = 280;
        const minRightPercent = (minRightPx / appMainRect.width) * 100;
        const maxRightPercent = 50;
        newPanel2Width = Math.max(minRightPercent, Math.min(maxRightPercent, newPanel2Width));
        
        // Middle panel: min 360px
        const minMiddlePx = 360;
        const minMiddlePercent = (minMiddlePx / appMainRect.width) * 100;
        newPanel1Width = Math.max(minMiddlePercent, newPanel1Width);
        
        // Ensure left panel doesn't get too small (min 260px)
        const minLeftPx = 260;
        const minLeftPercent = (minLeftPx / appMainRect.width) * 100;
        const remainingForLeft = 100 - newPanel1Width - newPanel2Width;
        
        if (remainingForLeft < minLeftPercent) {
          newPanel1Width = 100 - newPanel2Width - minLeftPercent;
        }
        
        document.documentElement.style.setProperty('--panel-middle-width', `${newPanel1Width}%`);
        document.documentElement.style.setProperty('--panel-right-width', `${newPanel2Width}%`);
      }

      e.preventDefault();
    });

    document.addEventListener('mouseup', () => {
      if (isResizing) {
        isResizing = false;
        handle.classList.remove('resizing');
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        savePanelWidths();
      }
    });
  }

  // Setup both resize handles
  if (resizeHandleLeft && leftPanel && middlePanel) {
    setupResizeHandle(resizeHandleLeft, leftPanel, middlePanel, true);
  }
  
  if (resizeHandleRight && middlePanel && rightPanel) {
    setupResizeHandle(resizeHandleRight, middlePanel, rightPanel, false);
  }

  // --- Vertical Resize for Parent Canvas -----------------------------------
  const resizeHandleParent = $('resize-handle-parent');
  const parentCanvasWrapper = document.querySelector('#parent-canvas-wrapper');
  const parentCanvasEl = $('parent-canvas');

  // Load saved height from localStorage
  function loadParentCanvasHeight() {
    const savedHeight = localStorage.getItem('parent-canvas-height');
    if (savedHeight) {
      document.documentElement.style.setProperty('--parent-canvas-height', savedHeight);
    }
  }

  // Save height to localStorage
  function saveParentCanvasHeight() {
    const height = getComputedStyle(document.documentElement).getPropertyValue('--parent-canvas-height');
    if (height) localStorage.setItem('parent-canvas-height', height.trim());
  }

  // Initialize with saved height
  loadParentCanvasHeight();

  // Vertical resize handler for parent canvas
  if (resizeHandleParent && parentCanvasEl) {
    let isResizing = false;
    let startY = 0;
    let startHeight = 0;

    resizeHandleParent.addEventListener('mousedown', (e) => {
      isResizing = true;
      resizeHandleParent.classList.add('resizing');
      startY = e.clientY;
      
      const rect = parentCanvasEl.getBoundingClientRect();
      startHeight = rect.height;

      document.body.style.cursor = 'row-resize';
      document.body.style.userSelect = 'none';
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;

      const deltaY = e.clientY - startY;
      const newHeight = startHeight + deltaY;
      
      // Apply min/max constraints (150px to 80vh)
      const minHeight = 150;
      const maxHeight = window.innerHeight * 0.8;
      const constrainedHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));

      document.documentElement.style.setProperty('--parent-canvas-height', `${constrainedHeight}px`);

      // Redraw the network to fit new size
      setTimeout(() => {
        parentNetwork.redraw();
      }, 0);

      e.preventDefault();
    });

    document.addEventListener('mouseup', () => {
      if (isResizing) {
        isResizing = false;
        resizeHandleParent.classList.remove('resizing');
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        saveParentCanvasHeight();
      }
    });
  }
});

