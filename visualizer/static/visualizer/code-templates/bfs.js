// BFS Algorithm Code Templates
// Templates for all supported languages

export const BFS_TEMPLATES = {
  cpp: [
    { key: "bfs_init", text: "#include <queue>" },
    { key: "bfs_init", text: "vector<int> d(n, INF); vector<int> parent(n, -1); vector<bool> visited(n, false);" },
    { key: "bfs_init", text: "d[s] = 0; visited[s] = true;" },
    { key: "bfs_init", text: "queue<int> q; q.push(s);" },
    { key: "bfs_pop", text: "while (!q.empty()) {" },
    { key: "bfs_pop", text: "  int u = q.front(); q.pop();" },
    { key: "bfs_relax", text: "  for (int v : adj[u]) {" },
    { key: "bfs_relax", text: "      if (!visited[v]) {" },
    { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.push(v);" },
    { key: "bfs_relax", text: "      }" },
    { key: "bfs_relax", text: "  }" },
    { key: "bfs_pop", text: "}" },
  ],
  c: [
    { key: "bfs_init", text: "// Note: C doesn't have built-in queue" },
    { key: "bfs_init", text: "// Use array-based queue or implement queue structure" },
    { key: "bfs_init", text: "int d[n], parent[n]; bool visited[n];" },
    { key: "bfs_init", text: "for (int i = 0; i < n; i++) { d[i] = INF; parent[i] = -1; visited[i] = false; }" },
    { key: "bfs_init", text: "d[s] = 0; visited[s] = true; int q[n], front = 0, rear = 0; q[rear++] = s;" },
    { key: "bfs_pop", text: "while (front < rear) {" },
    { key: "bfs_pop", text: "  int u = q[front++];" },
    { key: "bfs_relax", text: "  for (each neighbor v of u) {" },
    { key: "bfs_relax", text: "      if (!visited[v]) {" },
    { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q[rear++] = v;" },
    { key: "bfs_relax", text: "      }" },
    { key: "bfs_relax", text: "  }" },
    { key: "bfs_pop", text: "}" },
  ],
  java: [
    { key: "bfs_init", text: "double[] d = new double[n]; int[] parent = new int[n]; boolean[] visited = new boolean[n];" },
    { key: "bfs_init", text: "Arrays.fill(d, Double.POSITIVE_INFINITY); Arrays.fill(parent, -1); d[s] = 0; visited[s] = true;" },
    { key: "bfs_init", text: "Queue<Integer> q = new ArrayDeque<>(); q.add(s);" },
    { key: "bfs_pop", text: "while (!q.isEmpty()) {" },
    { key: "bfs_pop", text: "  int u = q.remove();" },
    { key: "bfs_relax", text: "  for (Edge e : adj[u]) { int v = e.v;" },
    { key: "bfs_relax", text: "      if (!visited[v]) {" },
    { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.add(v);" },
    { key: "bfs_relax", text: "      }" },
    { key: "bfs_relax", text: "  }" },
    { key: "bfs_pop", text: "}" },
  ],
  python: [
    { key: "bfs_init", text: "from collections import deque" },
    { key: "bfs_init", text: "d = {v: float('inf') for v in V}; parent = {v: None for v in V}" },
    { key: "bfs_init", text: "visited = {v: False for v in V}; d[s] = 0; visited[s] = True" },
    { key: "bfs_init", text: "Q = deque([s])" },
    { key: "bfs_pop", text: "while Q:" },
    { key: "bfs_pop", text: "  u = Q.popleft()" },
    { key: "bfs_relax", text: "  for (v, _) in adj[u]:" },
    { key: "bfs_relax", text: "      if not visited[v]:" },
    { key: "bfs_relax", text: "          visited[v] = True; d[v] = d[u] + 1; parent[v] = u; Q.append(v)" },
  ],
  rust: [
    { key: "bfs_init", text: "use std::collections::VecDeque;" },
    { key: "bfs_init", text: "let mut d = vec![i32::MAX; n]; let mut parent = vec![None; n]; let mut visited = vec![false; n];" },
    { key: "bfs_init", text: "d[s] = 0; visited[s] = true;" },
    { key: "bfs_init", text: "let mut q = VecDeque::new(); q.push_back(s);" },
    { key: "bfs_pop", text: "while let Some(u) = q.pop_front() {" },
    { key: "bfs_relax", text: "  for &v in &adj[u] {" },
    { key: "bfs_relax", text: "      if !visited[v] {" },
    { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = Some(u); q.push_back(v);" },
    { key: "bfs_relax", text: "      }" },
    { key: "bfs_relax", text: "  }" },
    { key: "bfs_pop", text: "}" },
  ],
  typescript: [
    { key: "bfs_init", text: "const d = Array(n).fill(Infinity); const parent = Array(n).fill(null);" },
    { key: "bfs_init", text: "const visited = Array(n).fill(false);" },
    { key: "bfs_init", text: "d[s] = 0; visited[s] = true; const q = [s];" },
    { key: "bfs_pop", text: "while (q.length > 0) {" },
    { key: "bfs_pop", text: "  const u = q.shift();" },
    { key: "bfs_relax", text: "  for (const [v] of adj[u]) {" },
    { key: "bfs_relax", text: "      if (!visited[v]) {" },
    { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.push(v);" },
    { key: "bfs_relax", text: "      }" },
    { key: "bfs_relax", text: "  }" },
    { key: "bfs_pop", text: "}" },
  ],
  go: [
    { key: "bfs_init", text: "d := make([]int, n); parent := make([]int, n); visited := make([]bool, n)" },
    { key: "bfs_init", text: "for i := range d { d[i] = math.MaxInt32; parent[i] = -1 }" },
    { key: "bfs_init", text: "d[s] = 0; visited[s] = true; q := []int{s}" },
    { key: "bfs_pop", text: "for len(q) > 0 {" },
    { key: "bfs_pop", text: "  u := q[0]; q = q[1:]" },
    { key: "bfs_relax", text: "  for _, v := range adj[u] {" },
    { key: "bfs_relax", text: "      if !visited[v] {" },
    { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q = append(q, v)" },
    { key: "bfs_relax", text: "      }" },
    { key: "bfs_relax", text: "  }" },
    { key: "bfs_pop", text: "}" },
  ],
  kotlin: [
    { key: "bfs_init", text: "val d = IntArray(n) { Int.MAX_VALUE }" },
    { key: "bfs_init", text: "val parent = IntArray(n) { -1 }" },
    { key: "bfs_init", text: "val visited = BooleanArray(n)" },
    { key: "bfs_init", text: "d[s] = 0; visited[s] = true; val q = ArrayDeque<Int>(); q.add(s)" },
    { key: "bfs_pop", text: "while (q.isNotEmpty()) {" },
    { key: "bfs_pop", text: "  val u = q.removeFirst()" },
    { key: "bfs_relax", text: "  adj[u].forEach { v ->" },
    { key: "bfs_relax", text: "      if (!visited[v]) {" },
    { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.add(v)" },
    { key: "bfs_relax", text: "      }" },
    { key: "bfs_relax", text: "  }" },
    { key: "bfs_pop", text: "}" },
  ],
  swift: [
    { key: "bfs_init", text: "import Foundation" },
    { key: "bfs_init", text: "var d = Array(repeating: Int.max, count: n)" },
    { key: "bfs_init", text: "var parent = Array(repeating: -1, count: n)" },
    { key: "bfs_init", text: "var visited = Array(repeating: false, count: n)" },
    { key: "bfs_init", text: "d[s] = 0; visited[s] = true; var q = [s]" },
    { key: "bfs_pop", text: "while !q.isEmpty {" },
    { key: "bfs_pop", text: "  let u = q.removeFirst()" },
    { key: "bfs_relax", text: "  for v in adj[u] {" },
    { key: "bfs_relax", text: "      if !visited[v] {" },
    { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.append(v)" },
    { key: "bfs_relax", text: "      }" },
    { key: "bfs_relax", text: "  }" },
    { key: "bfs_pop", text: "}" },
  ],
  csharp: [
    { key: "bfs_init", text: "using System.Collections.Generic;" },
    { key: "bfs_init", text: "int[] d = new int[n]; int[] parent = new int[n]; bool[] visited = new bool[n];" },
    { key: "bfs_init", text: "Array.Fill(d, int.MaxValue); Array.Fill(parent, -1); d[s] = 0; visited[s] = true;" },
    { key: "bfs_init", text: "Queue<int> q = new Queue<int>(); q.Enqueue(s);" },
    { key: "bfs_pop", text: "while (q.Count > 0) {" },
    { key: "bfs_pop", text: "  int u = q.Dequeue();" },
    { key: "bfs_relax", text: "  foreach (int v in adj[u]) {" },
    { key: "bfs_relax", text: "      if (!visited[v]) {" },
    { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.Enqueue(v);" },
    { key: "bfs_relax", text: "      }" },
    { key: "bfs_relax", text: "  }" },
    { key: "bfs_pop", text: "}" },
  ],
  ruby: [
    { key: "bfs_init", text: "require 'set'" },
    { key: "bfs_init", text: "d = Hash.new(Float::INFINITY); parent = {}; visited = Set.new" },
    { key: "bfs_init", text: "d[s] = 0; visited.add(s); q = [s]" },
    { key: "bfs_pop", text: "until q.empty?" },
    { key: "bfs_pop", text: "  u = q.shift" },
    { key: "bfs_relax", text: "  adj[u].each do |v, _|" },
    { key: "bfs_relax", text: "      unless visited.include?(v)" },
    { key: "bfs_relax", text: "          visited.add(v); d[v] = d[u] + 1; parent[v] = u; q << v" },
    { key: "bfs_relax", text: "      end" },
    { key: "bfs_relax", text: "  end" },
    { key: "bfs_pop", text: "end" },
  ],
  php: [
    { key: "bfs_init", text: "$d = array_fill(0, $n, INF); $parent = array_fill(0, $n, -1); $visited = array_fill(0, $n, false);" },
    { key: "bfs_init", text: "$d[$s] = 0; $visited[$s] = true; $q = [$s];" },
    { key: "bfs_pop", text: "while (!empty($q)) {" },
    { key: "bfs_pop", text: "  $u = array_shift($q);" },
    { key: "bfs_relax", text: "  foreach ($adj[$u] as $v) {" },
    { key: "bfs_relax", text: "      if (!$visited[$v]) {" },
    { key: "bfs_relax", text: "          $visited[$v] = true; $d[$v] = $d[$u] + 1; $parent[$v] = $u; array_push($q, $v);" },
    { key: "bfs_relax", text: "      }" },
    { key: "bfs_relax", text: "  }" },
    { key: "bfs_pop", text: "}" },
  ],
  scala: [
    { key: "bfs_init", text: "import scala.collection.mutable" },
    { key: "bfs_init", text: "val d = Array.fill(n)(Int.MaxValue)" },
    { key: "bfs_init", text: "val parent = Array.fill(n)(-1)" },
    { key: "bfs_init", text: "val visited = Array.fill(n)(false)" },
    { key: "bfs_init", text: "d(s) = 0; visited(s) = true; val q = mutable.Queue(s)" },
    { key: "bfs_pop", text: "while (q.nonEmpty) {" },
    { key: "bfs_pop", text: "  val u = q.dequeue" },
    { key: "bfs_relax", text: "  adj(u).foreach { v =>" },
    { key: "bfs_relax", text: "      if (!visited(v)) {" },
    { key: "bfs_relax", text: "          visited(v) = true; d(v) = d(u) + 1; parent(v) = u; q.enqueue(v)" },
    { key: "bfs_relax", text: "      }" },
    { key: "bfs_relax", text: "  }" },
    { key: "bfs_pop", text: "}" },
  ],
  haskell: [
    { key: "bfs_init", text: "import Data.Sequence (Seq, (|>), (<|), empty, null)" },
    { key: "bfs_init", text: "d = replicate n maxBound :: [Int]" },
    { key: "bfs_init", text: "parent = replicate n Nothing :: [Maybe Int]" },
    { key: "bfs_init", text: "visited = replicate n False" },
    { key: "bfs_init", text: "d' = take s d ++ [0] ++ drop (s+1) d" },
    { key: "bfs_init", text: "visited' = take s visited ++ [True] ++ drop (s+1) visited" },
    { key: "bfs_init", text: "q = s <| empty" },
    { key: "bfs_pop", text: "bfs d parent visited q | null q = (d, parent)" },
    { key: "bfs_pop", text: "              | otherwise = let (u :< qs) = viewl q in process u qs" },
    { key: "bfs_relax", text: "process u qs = foldl relax (qs, d, parent, visited) (adj u)" },
    { key: "bfs_relax", text: "relax (q, d, p, v) n | not (v !! n) = (n <| q, update d n (d !! u + 1), update p n (Just u), update v n True)" },
    { key: "bfs_relax", text: "                | otherwise = (q, d, p, v)" },
  ],
  ocaml: [
    { key: "bfs_init", text: "module Queue = BatQueue" },
    { key: "bfs_init", text: "let d = Array.make n max_int in" },
    { key: "bfs_init", text: "let parent = Array.make n None in" },
    { key: "bfs_init", text: "let visited = Array.make n false in" },
    { key: "bfs_init", text: "d.(s) <- 0; visited.(s) <- true;" },
    { key: "bfs_init", text: "let q = Queue.empty |> Queue.push s in" },
    { key: "bfs_pop", text: "let rec bfs d parent visited q = match Queue.is_empty q with" },
    { key: "bfs_pop", text: "  | true -> (d, parent)" },
    { key: "bfs_pop", text: "  | false -> let (u, q') = Queue.pop q in process u q' d parent visited" },
    { key: "bfs_relax", text: "and process u q d parent visited = List.fold_left (fun (q', d', p', v') v ->" },
    { key: "bfs_relax", text: "    if not v'.(v) then (Queue.push v q', d'.(v) <- d'.(u) + 1; p'.(v) <- Some u; v'.(v) <- true; (q', d', p', v'))" },
    { key: "bfs_relax", text: "    else (q', d', p', v')) (q, d, parent, visited) (adj u)" },
  ],
  fsharp: [
    { key: "bfs_init", text: "open System.Collections.Generic" },
    { key: "bfs_init", text: "let d = Array.create n System.Int32.MaxValue" },
    { key: "bfs_init", text: "let parent = Array.create n -1" },
    { key: "bfs_init", text: "let visited = Array.create n false" },
    { key: "bfs_init", text: "d.[s] <- 0; visited.[s] <- true" },
    { key: "bfs_init", text: "let q = Queue<int>(); q.Enqueue(s)" },
    { key: "bfs_pop", text: "while q.Count > 0 do" },
    { key: "bfs_pop", text: "  let u = q.Dequeue()" },
    { key: "bfs_relax", text: "  adj.[u] |> List.iter (fun v ->" },
    { key: "bfs_relax", text: "      if not visited.[v] then" },
    { key: "bfs_relax", text: "        visited.[v] <- true; d.[v] <- d.[u] + 1; parent.[v] <- u; q.Enqueue(v))" },
  ],
  dart: [
    { key: "bfs_init", text: "import 'dart:collection';" },
    { key: "bfs_init", text: "List<int> d = List.filled(n, 999999);" },
    { key: "bfs_init", text: "List<int> parent = List.filled(n, -1);" },
    { key: "bfs_init", text: "List<bool> visited = List.filled(n, false);" },
    { key: "bfs_init", text: "d[s] = 0; visited[s] = true; var q = Queue<int>(); q.add(s);" },
    { key: "bfs_pop", text: "while (q.isNotEmpty) {" },
    { key: "bfs_pop", text: "  int u = q.removeFirst();" },
    { key: "bfs_relax", text: "  for (int v in adj[u]) {" },
    { key: "bfs_relax", text: "      if (!visited[v]) {" },
    { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; q.add(v);" },
    { key: "bfs_relax", text: "      }" },
    { key: "bfs_relax", text: "  }" },
    { key: "bfs_pop", text: "}" },
  ],
  lua: [
    { key: "bfs_init", text: "local d = {}; local parent = {}; local visited = {}" },
    { key: "bfs_init", text: "for i = 1, n do d[i] = math.huge; parent[i] = nil; visited[i] = false end" },
    { key: "bfs_init", text: "d[s] = 0; visited[s] = true; local q = {s}" },
    { key: "bfs_pop", text: "while #q > 0 do" },
    { key: "bfs_pop", text: "  local u = table.remove(q, 1)" },
    { key: "bfs_relax", text: "  for _, v in ipairs(adj[u]) do" },
    { key: "bfs_relax", text: "      if not visited[v] then" },
    { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; table.insert(q, v)" },
    { key: "bfs_relax", text: "      end" },
    { key: "bfs_relax", text: "  end" },
    { key: "bfs_pop", text: "end" },
  ],
  perl: [
    { key: "bfs_init", text: "use strict; use warnings;" },
    { key: "bfs_init", text: "my @d = (999999) x $n; my @parent = (-1) x $n; my @visited = (0) x $n;" },
    { key: "bfs_init", text: "$d[$s] = 0; $visited[$s] = 1; my @q = ($s);" },
    { key: "bfs_pop", text: "while (@q) {" },
    { key: "bfs_pop", text: "  my $u = shift @q;" },
    { key: "bfs_relax", text: "  for my $v (@{$adj[$u]}) {" },
    { key: "bfs_relax", text: "      if (!$visited[$v]) {" },
    { key: "bfs_relax", text: "          $visited[$v] = 1; $d[$v] = $d[$u] + 1; $parent[$v] = $u; push @q, $v;" },
    { key: "bfs_relax", text: "      }" },
    { key: "bfs_relax", text: "  }" },
    { key: "bfs_pop", text: "}" },
  ],
  r: [
    { key: "bfs_init", text: "library(igraph)" },
    { key: "bfs_init", text: "d <- rep(Inf, n); parent <- rep(NA, n); visited <- rep(FALSE, n)" },
    { key: "bfs_init", text: "d[s] <- 0; visited[s] <- TRUE; q <- c(s)" },
    { key: "bfs_pop", text: "while (length(q) > 0) {" },
    { key: "bfs_pop", text: "  u <- q[1]; q <- q[-1]" },
    { key: "bfs_relax", text: "  for (v in adj[[u]]) {" },
    { key: "bfs_relax", text: "      if (!visited[v]) {" },
    { key: "bfs_relax", text: "          visited[v] <- TRUE; d[v] <- d[u] + 1; parent[v] <- u; q <- c(q, v)" },
    { key: "bfs_relax", text: "      }" },
    { key: "bfs_relax", text: "  }" },
    { key: "bfs_pop", text: "}" },
  ],
  matlab: [
    { key: "bfs_init", text: "d = inf(1, n); parent = zeros(1, n); visited = false(1, n);" },
    { key: "bfs_init", text: "d(s) = 0; visited(s) = true; q = [s];" },
    { key: "bfs_pop", text: "while ~isempty(q)" },
    { key: "bfs_pop", text: "  u = q(1); q = q(2:end);" },
    { key: "bfs_relax", text: "  for v = adj{u}" },
    { key: "bfs_relax", text: "      if ~visited(v)" },
    { key: "bfs_relax", text: "          visited(v) = true; d(v) = d(u) + 1; parent(v) = u; q = [q, v];" },
    { key: "bfs_relax", text: "      end" },
    { key: "bfs_relax", text: "  end" },
    { key: "bfs_pop", text: "end" },
  ],
  julia: [
    { key: "bfs_init", text: "using DataStructures" },
    { key: "bfs_init", text: "d = fill(Inf, n); parent = fill(nothing, n); visited = falses(n)" },
    { key: "bfs_init", text: "d[s] = 0; visited[s] = true; q = Queue{Int}(); enqueue!(q, s)" },
    { key: "bfs_pop", text: "while !isempty(q)" },
    { key: "bfs_pop", text: "  u = dequeue!(q)" },
    { key: "bfs_relax", text: "  for v in adj[u]" },
    { key: "bfs_relax", text: "      if !visited[v]" },
    { key: "bfs_relax", text: "          visited[v] = true; d[v] = d[u] + 1; parent[v] = u; enqueue!(q, v)" },
    { key: "bfs_relax", text: "      end" },
    { key: "bfs_relax", text: "  end" },
    { key: "bfs_pop", text: "end" },
  ],
};
