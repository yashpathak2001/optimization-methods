// BELLMAN_FORD_FIFO Algorithm Code Templates
// Templates for all supported languages

export const BELLMAN_FORD_FIFO_TEMPLATES = {
  cpp: [
    { key: "fifo_init", text: "vector<double> d(n, INF); vector<int> parent(n, -1); d[s] = 0;" },
    { key: "fifo_init", text: "queue<int> q; vector<bool> inQ(n, false); q.push(s); inQ[s] = true;" },
    { key: "fifo_pop", text: "while (!q.empty()) {" },
    { key: "fifo_pop", text: "  int u = q.front(); q.pop(); inQ[u] = false;" },
    { key: "fifo_relax", text: "  for (auto &e : adj[u]) {" },
    { key: "fifo_relax", text: "    int v = e.to; double w = e.w;" },
    { key: "fifo_relax", text: "    if (d[u] + w < d[v]) {" },
    { key: "fifo_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
    { key: "fifo_relax", text: "      if (!inQ[v]) { q.push(v); inQ[v] = true; }" },
    { key: "fifo_relax", text: "    }" },
    { key: "fifo_relax", text: "  }" },
    { key: "fifo_pop", text: "}" },
  ],
  c: [
    { key: "fifo_init", text: "for (int i = 0; i < n; ++i) { d[i] = INF; inQ[i] = false; parent[i] = -1; }" },
    { key: "fifo_init", text: "d[s] = 0; push(q, s); inQ[s] = true;" },
    { key: "fifo_pop", text: "while (!empty(q)) {" },
    { key: "fifo_pop", text: "  int u = front(q); pop(q); inQ[u] = false;" },
    { key: "fifo_relax", text: "  for (each edge (u,v,w)) {" },
    { key: "fifo_relax", text: "    if (d[u] + w < d[v]) {" },
    { key: "fifo_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
    { key: "fifo_relax", text: "      if (!inQ[v]) { push(q, v); inQ[v] = true; }" },
    { key: "fifo_relax", text: "    }" },
    { key: "fifo_relax", text: "  }" },
    { key: "fifo_pop", text: "}" },
  ],
  java: [
    { key: "fifo_init", text: "double[] d = new double[n]; boolean[] inQ = new boolean[n]; int[] parent = new int[n];" },
    { key: "fifo_init", text: "Arrays.fill(d, INF); Arrays.fill(parent, -1); d[s] = 0;" },
    { key: "fifo_init", text: "Queue<Integer> q = new ArrayDeque<>(); q.add(s); inQ[s] = true;" },
    { key: "fifo_pop", text: "while (!q.isEmpty()) {" },
    { key: "fifo_pop", text: "  int u = q.remove(); inQ[u] = false;" },
    { key: "fifo_relax", text: "  for (Edge e : adj[u]) {" },
    { key: "fifo_relax", text: "    int v = e.v; double w = e.w;" },
    { key: "fifo_relax", text: "    if (d[u] + w < d[v]) {" },
    { key: "fifo_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
    { key: "fifo_relax", text: "      if (!inQ[v]) { q.add(v); inQ[v] = true; }" },
    { key: "fifo_relax", text: "    }" },
    { key: "fifo_relax", text: "  }" },
    { key: "fifo_pop", text: "}" },
  ],
  python: [
    { key: "fifo_init", text: "d = {v: float('inf') for v in V}; parent = {v: None for v in V}" },
    { key: "fifo_init", text: "d[s] = 0" },
    { key: "fifo_init", text: "from collections import deque" },
    { key: "fifo_init", text: "Q = deque([s]); inQ = {v: False for v in V}; inQ[s] = True" },
    { key: "fifo_pop", text: "while Q:" },
    { key: "fifo_pop", text: "  u = Q.popleft(); inQ[u] = False" },
    { key: "fifo_relax", text: "  for (v, w) in adj[u]:" },
    { key: "fifo_relax", text: "      if d[u] + w < d[v]:" },
    { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
    { key: "fifo_relax", text: "          if not inQ[v]: Q.append(v); inQ[v] = True" },
  ],
  rust: [
    { key: "fifo_init", text: "let mut d = vec![f64::INFINITY; n]; let mut parent = vec![None; n];" },
    { key: "fifo_init", text: "d[s] = 0.0;" },
    { key: "fifo_init", text: "use std::collections::VecDeque;" },
    { key: "fifo_init", text: "let mut q = VecDeque::new(); let mut in_q = vec![false; n];" },
    { key: "fifo_init", text: "q.push_back(s); in_q[s] = true;" },
    { key: "fifo_pop", text: "while let Some(u) = q.pop_front() {" },
    { key: "fifo_pop", text: "  in_q[u] = false;" },
    { key: "fifo_relax", text: "  for &(v, w) in &adj[u] {" },
    { key: "fifo_relax", text: "      if d[u] + w < d[v] {" },
    { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = Some(u);" },
    { key: "fifo_relax", text: "          if !in_q[v] { q.push_back(v); in_q[v] = true; }" },
    { key: "fifo_relax", text: "      }" },
    { key: "fifo_relax", text: "  }" },
    { key: "fifo_pop", text: "}" },
    { key: "fifo_done", text: "// Algorithm completed" },
    { key: "fifo_check", text: "// Check for negative cycles" },
    { key: "fifo_check_edge", text: "for &(u, v, w) in &edges {" },
    { key: "fifo_neg_cycle", text: "  if d[u] + w < d[v] { println!(\"negative cycle\"); }" },
    { key: "fifo_check_edge", text: "}" },
  ],
  javascript: [
    { key: "fifo_init", text: "const d = Array(n).fill(Infinity); const parent = Array(n).fill(null);" },
    { key: "fifo_init", text: "d[s] = 0;" },
    { key: "fifo_init", text: "const q = [s]; const inQ = Array(n).fill(false); inQ[s] = true;" },
    { key: "fifo_pop", text: "while (q.length > 0) {" },
    { key: "fifo_pop", text: "  const u = q.shift(); inQ[u] = false;" },
    { key: "fifo_relax", text: "  for (const [v, w] of adj[u]) {" },
    { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
    { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
    { key: "fifo_relax", text: "          if (!inQ[v]) { q.push(v); inQ[v] = true; }" },
    { key: "fifo_relax", text: "      }" },
    { key: "fifo_relax", text: "  }" },
    { key: "fifo_pop", text: "}" },
    { key: "fifo_done", text: "// Algorithm completed" },
    { key: "fifo_check", text: "// Check for negative cycles" },
    { key: "fifo_check_edge", text: "for (const [u, v, w] of edges) {" },
    { key: "fifo_neg_cycle", text: "  if (d[u] + w < d[v]) console.log('negative cycle');" },
    { key: "fifo_check_edge", text: "}" },
  ],
  typescript: [
    { key: "fifo_init", text: "const d: number[] = Array(n).fill(Infinity); const parent: (number | null)[] = Array(n).fill(null);" },
    { key: "fifo_init", text: "d[s] = 0;" },
    { key: "fifo_init", text: "const q: number[] = [s]; const inQ: boolean[] = Array(n).fill(false); inQ[s] = true;" },
    { key: "fifo_pop", text: "while (q.length > 0) {" },
    { key: "fifo_pop", text: "  const u = q.shift()!; inQ[u] = false;" },
    { key: "fifo_relax", text: "  for (const [v, w]: [number, number] of adj[u]) {" },
    { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
    { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
    { key: "fifo_relax", text: "          if (!inQ[v]) { q.push(v); inQ[v] = true; }" },
    { key: "fifo_relax", text: "      }" },
    { key: "fifo_relax", text: "  }" },
    { key: "fifo_pop", text: "}" },
    { key: "fifo_done", text: "// Algorithm completed" },
    { key: "fifo_check", text: "// Check for negative cycles" },
    { key: "fifo_check_edge", text: "for (const [u, v, w]: [number, number, number] of edges) {" },
    { key: "fifo_neg_cycle", text: "  if (d[u] + w < d[v]) console.log('negative cycle');" },
    { key: "fifo_check_edge", text: "}" },
  ],
  go: [
    { key: "fifo_init", text: "d := make([]float64, n); parent := make([]int, n); inQ := make([]bool, n)" },
    { key: "fifo_init", text: "for i := range d { d[i] = math.Inf(1); parent[i] = -1 }" },
    { key: "fifo_init", text: "d[s] = 0; q := []int{s}; inQ[s] = true" },
    { key: "fifo_pop", text: "for len(q) > 0 {" },
    { key: "fifo_pop", text: "  u := q[0]; q = q[1:]; inQ[u] = false" },
    { key: "fifo_relax", text: "  for _, e := range adj[u] {" },
    { key: "fifo_relax", text: "      v, w := e.v, e.w" },
    { key: "fifo_relax", text: "      if d[u] + w < d[v] {" },
    { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
    { key: "fifo_relax", text: "          if !inQ[v] { q = append(q, v); inQ[v] = true }" },
    { key: "fifo_relax", text: "      }" },
    { key: "fifo_relax", text: "  }" },
    { key: "fifo_pop", text: "}" },
    { key: "fifo_done", text: "// Algorithm completed" },
    { key: "fifo_check", text: "// Check for negative cycles" },
    { key: "fifo_check_edge", text: "for _, e := range edges {" },
    { key: "fifo_neg_cycle", text: "  if d[e.u] + e.w < d[e.v] { fmt.Println(\"negative cycle\") }" },
    { key: "fifo_check_edge", text: "}" },
  ],
  kotlin: [
    { key: "fifo_init", text: "val d = DoubleArray(n) { Double.POSITIVE_INFINITY }" },
    { key: "fifo_init", text: "val parent = IntArray(n) { -1 }" },
    { key: "fifo_init", text: "d[s] = 0.0" },
    { key: "fifo_init", text: "val q = ArrayDeque<Int>(); val inQ = BooleanArray(n)" },
    { key: "fifo_init", text: "q.add(s); inQ[s] = true" },
    { key: "fifo_pop", text: "while (q.isNotEmpty()) {" },
    { key: "fifo_pop", text: "  val u = q.removeFirst(); inQ[u] = false" },
    { key: "fifo_relax", text: "  adj[u].forEach { (v, w) ->" },
    { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
    { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
    { key: "fifo_relax", text: "          if (!inQ[v]) { q.add(v); inQ[v] = true }" },
    { key: "fifo_relax", text: "      }" },
    { key: "fifo_relax", text: "  }" },
    { key: "fifo_pop", text: "}" },
  ],
  swift: [
    { key: "fifo_init", text: "var d = Array(repeating: Double.infinity, count: n)" },
    { key: "fifo_init", text: "var parent = Array(repeating: -1, count: n)" },
    { key: "fifo_init", text: "d[s] = 0" },
    { key: "fifo_init", text: "var q = [s]; var inQ = Array(repeating: false, count: n); inQ[s] = true" },
    { key: "fifo_pop", text: "while !q.isEmpty {" },
    { key: "fifo_pop", text: "  let u = q.removeFirst(); inQ[u] = false" },
    { key: "fifo_relax", text: "  for (v, w) in adj[u] {" },
    { key: "fifo_relax", text: "      if d[u] + w < d[v] {" },
    { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
    { key: "fifo_relax", text: "          if !inQ[v] { q.append(v); inQ[v] = true }" },
    { key: "fifo_relax", text: "      }" },
    { key: "fifo_relax", text: "  }" },
    { key: "fifo_pop", text: "}" },
    { key: "fifo_done", text: "// Algorithm completed" },
    { key: "fifo_check", text: "// Check for negative cycles" },
    { key: "fifo_check_edge", text: "for (u, v, w) in edges {" },
    { key: "fifo_neg_cycle", text: "  if d[u] + w < d[v] { print(\"negative cycle\") }" },
    { key: "fifo_check_edge", text: "}" },
  ],
  csharp: [
    { key: "fifo_init", text: "double[] d = new double[n]; int[] parent = new int[n]; bool[] inQ = new bool[n];" },
    { key: "fifo_init", text: "Array.Fill(d, double.PositiveInfinity); Array.Fill(parent, -1); d[s] = 0;" },
    { key: "fifo_init", text: "var q = new Queue<int>(); q.Enqueue(s); inQ[s] = true;" },
    { key: "fifo_pop", text: "while (q.Count > 0) {" },
    { key: "fifo_pop", text: "  int u = q.Dequeue(); inQ[u] = false;" },
    { key: "fifo_relax", text: "  foreach (var (v, w) in adj[u]) {" },
    { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
    { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
    { key: "fifo_relax", text: "          if (!inQ[v]) { q.Enqueue(v); inQ[v] = true; }" },
    { key: "fifo_relax", text: "      }" },
    { key: "fifo_relax", text: "  }" },
    { key: "fifo_pop", text: "}" },
    { key: "fifo_done", text: "// Algorithm completed" },
    { key: "fifo_check", text: "// Check for negative cycles" },
    { key: "fifo_check_edge", text: "foreach (var (u, v, w) in edges) {" },
    { key: "fifo_neg_cycle", text: "  if (d[u] + w < d[v]) Console.WriteLine(\"negative cycle\");" },
    { key: "fifo_check_edge", text: "}" },
  ],
  ruby: [
    { key: "fifo_init", text: "d = Array.new(n, Float::INFINITY); parent = Array.new(n, nil)" },
    { key: "fifo_init", text: "d[s] = 0" },
    { key: "fifo_init", text: "q = [s]; in_q = Array.new(n, false); in_q[s] = true" },
    { key: "fifo_pop", text: "until q.empty?" },
    { key: "fifo_pop", text: "  u = q.shift; in_q[u] = false" },
    { key: "fifo_relax", text: "  adj[u].each do |v, w|" },
    { key: "fifo_relax", text: "      if d[u] + w < d[v]" },
    { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
    { key: "fifo_relax", text: "          unless in_q[v]; q << v; in_q[v] = true end" },
    { key: "fifo_relax", text: "      end" },
    { key: "fifo_relax", text: "  end" },
    { key: "fifo_pop", text: "end" },
    { key: "fifo_done", text: "# Algorithm completed" },
    { key: "fifo_check", text: "# Check for negative cycles" },
    { key: "fifo_check_edge", text: "edges.each do |u, v, w|" },
    { key: "fifo_neg_cycle", text: "  puts 'negative cycle' if d[u] + w < d[v]" },
    { key: "fifo_check_edge", text: "end" },
  ],
  php: [
    { key: "fifo_init", text: "$d = array_fill(0, $n, INF); $parent = array_fill(0, $n, null);" },
    { key: "fifo_init", text: "$d[$s] = 0;" },
    { key: "fifo_init", text: "$q = [$s]; $inQ = array_fill(0, $n, false); $inQ[$s] = true;" },
    { key: "fifo_pop", text: "while (!empty($q)) {" },
    { key: "fifo_pop", text: "  $u = array_shift($q); $inQ[$u] = false;" },
    { key: "fifo_relax", text: "  foreach ($adj[$u] as [$v, $w]) {" },
    { key: "fifo_relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
    { key: "fifo_relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
    { key: "fifo_relax", text: "          if (!$inQ[$v]) { $q[] = $v; $inQ[$v] = true; }" },
    { key: "fifo_relax", text: "      }" },
    { key: "fifo_relax", text: "  }" },
    { key: "fifo_pop", text: "}" },
    { key: "fifo_done", text: "// Algorithm completed" },
    { key: "fifo_check", text: "// Check for negative cycles" },
    { key: "fifo_check_edge", text: "foreach ($edges as [$u, $v, $w]) {" },
    { key: "fifo_neg_cycle", text: "  if ($d[$u] + $w < $d[$v]) echo 'negative cycle';" },
    { key: "fifo_check_edge", text: "}" },
  ],
  scala: [
    { key: "fifo_init", text: "val d = Array.fill(n)(Double.PositiveInfinity); val parent = Array.fill(n)(-1)" },
    { key: "fifo_init", text: "d(s) = 0" },
    { key: "fifo_init", text: "import scala.collection.mutable.Queue" },
    { key: "fifo_init", text: "val q = Queue(s); val inQ = Array.fill(n)(false); inQ(s) = true" },
    { key: "fifo_pop", text: "while (q.nonEmpty) {" },
    { key: "fifo_pop", text: "  val u = q.dequeue(); inQ(u) = false" },
    { key: "fifo_relax", text: "  adj(u).foreach { case (v, w) =>" },
    { key: "fifo_relax", text: "      if (d(u) + w < d(v)) {" },
    { key: "fifo_relax", text: "          d(v) = d(u) + w; parent(v) = u" },
    { key: "fifo_relax", text: "          if (!inQ(v)) { q.enqueue(v); inQ(v) = true }" },
    { key: "fifo_relax", text: "      }" },
    { key: "fifo_relax", text: "  }" },
    { key: "fifo_pop", text: "}" },
    { key: "fifo_done", text: "// Algorithm completed" },
    { key: "fifo_check", text: "// Check for negative cycles" },
    { key: "fifo_check_edge", text: "edges.foreach { case (u, v, w) =>" },
    { key: "fifo_neg_cycle", text: "  if (d(u) + w < d(v)) println(\"negative cycle\")" },
    { key: "fifo_check_edge", text: "}" },
  ],
  haskell: [
    { key: "fifo_init", text: "d = replicate n (1/0) :: [Double]" },
    { key: "fifo_init", text: "parent = replicate n Nothing :: [Maybe Int]" },
    { key: "fifo_init", text: "d' = take s d ++ [0] ++ drop (s+1) d" },
    { key: "fifo_init", text: "q = [s]; inQ = replicate n False" },
    { key: "fifo_pop", text: "bfFIFO q inQ d p | null q = (d, p)" },
    { key: "fifo_pop", text: "              | otherwise = let (u:qs) = q in process u qs" },
    { key: "fifo_relax", text: "process u qs = foldl relaxEdge (qs, d, p) (adj u)" },
  ],
  ocaml: [
    { key: "fifo_init", text: "let d = Array.make n infinity in" },
    { key: "fifo_init", text: "let parent = Array.make n None in" },
    { key: "fifo_init", text: "d.(s) <- 0.0;" },
    { key: "fifo_init", text: "let q = Queue.create () in" },
    { key: "fifo_init", text: "let in_q = Array.make n false in" },
    { key: "fifo_init", text: "Queue.push s q; in_q.(s) <- true;" },
    { key: "fifo_pop", text: "while not (Queue.is_empty q) do" },
    { key: "fifo_pop", text: "  let u = Queue.pop q in in_q.(u) <- false;" },
    { key: "fifo_relax", text: "  List.iter (fun (v, w) ->" },
    { key: "fifo_relax", text: "      if d.(u) +. w < d.(v) then (" },
    { key: "fifo_relax", text: "          d.(v) <- d.(u) +. w; parent.(v) <- Some u;" },
    { key: "fifo_relax", text: "          if not in_q.(v) then (Queue.push v q; in_q.(v) <- true)" },
    { key: "fifo_relax", text: "      )" },
    { key: "fifo_relax", text: "  ) adj.(u)" },
    { key: "fifo_pop", text: "done" },
  ],
  fsharp: [
    { key: "fifo_init", text: "let d = Array.create n System.Double.PositiveInfinity" },
    { key: "fifo_init", text: "let parent = Array.create n None" },
    { key: "fifo_init", text: "d.[s] <- 0.0" },
    { key: "fifo_init", text: "let q = System.Collections.Generic.Queue<int>()" },
    { key: "fifo_init", text: "let inQ = Array.create n false" },
    { key: "fifo_init", text: "q.Enqueue(s); inQ.[s] <- true" },
    { key: "fifo_pop", text: "while q.Count > 0 do" },
    { key: "fifo_pop", text: "  let u = q.Dequeue() in inQ.[u] <- false" },
    { key: "fifo_relax", text: "  adj.[u] |> List.iter (fun (v, w) ->" },
    { key: "fifo_relax", text: "      if d.[u] + w < d.[v] then (" },
    { key: "fifo_relax", text: "          d.[v] <- d.[u] + w; parent.[v] <- Some u;" },
    { key: "fifo_relax", text: "          if not inQ.[v] then (q.Enqueue(v); inQ.[v] <- true)" },
    { key: "fifo_relax", text: "      )" },
    { key: "fifo_relax", text: "  )" },
    { key: "fifo_pop", text: "done" },
  ],
  dart: [
    { key: "fifo_init", text: "List<double> d = List.filled(n, double.infinity);" },
    { key: "fifo_init", text: "List<int?> parent = List.filled(n, null);" },
    { key: "fifo_init", text: "d[s] = 0;" },
    { key: "fifo_init", text: "var q = <int>[s]; var inQ = List.filled(n, false); inQ[s] = true;" },
    { key: "fifo_pop", text: "while (q.isNotEmpty) {" },
    { key: "fifo_pop", text: "  int u = q.removeAt(0); inQ[u] = false;" },
    { key: "fifo_relax", text: "  for (var (v, w) in adj[u]) {" },
    { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
    { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
    { key: "fifo_relax", text: "          if (!inQ[v]) { q.add(v); inQ[v] = true; }" },
    { key: "fifo_relax", text: "      }" },
    { key: "fifo_relax", text: "  }" },
    { key: "fifo_pop", text: "}" },
  ],
  lua: [
    { key: "fifo_init", text: "local d = {}; local parent = {}; local inQ = {}" },
    { key: "fifo_init", text: "for i = 1, n do d[i] = math.huge; parent[i] = nil; inQ[i] = false end" },
    { key: "fifo_init", text: "d[s] = 0; local q = {s}; inQ[s] = true" },
    { key: "fifo_pop", text: "while #q > 0 do" },
    { key: "fifo_pop", text: "  local u = table.remove(q, 1); inQ[u] = false" },
    { key: "fifo_relax", text: "  for _, edge in ipairs(adj[u]) do" },
    { key: "fifo_relax", text: "      local v, w = edge[1], edge[2]" },
    { key: "fifo_relax", text: "      if d[u] + w < d[v] then" },
    { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
    { key: "fifo_relax", text: "          if not inQ[v] then table.insert(q, v); inQ[v] = true end" },
    { key: "fifo_relax", text: "      end" },
    { key: "fifo_relax", text: "  end" },
    { key: "fifo_pop", text: "end" },
  ],
  perl: [
    { key: "fifo_init", text: "my @d = (inf) x $n; my @parent = (undef) x $n; my @inQ = (0) x $n;" },
    { key: "fifo_init", text: "$d[$s] = 0; my @q = ($s); $inQ[$s] = 1;" },
    { key: "fifo_pop", text: "while (@q) {" },
    { key: "fifo_pop", text: "  my $u = shift @q; $inQ[$u] = 0;" },
    { key: "fifo_relax", text: "  for my $edge (@{$adj[$u]}) {" },
    { key: "fifo_relax", text: "      my ($v, $w) = @$edge;" },
    { key: "fifo_relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
    { key: "fifo_relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
    { key: "fifo_relax", text: "          if (!$inQ[$v]) { push @q, $v; $inQ[$v] = 1 }" },
    { key: "fifo_relax", text: "      }" },
    { key: "fifo_relax", text: "  }" },
    { key: "fifo_pop", text: "}" },
  ],
  r: [
    { key: "fifo_init", text: "d <- rep(Inf, n); parent <- rep(NA, n); inQ <- rep(FALSE, n)" },
    { key: "fifo_init", text: "d[s] <- 0; q <- c(s); inQ[s] <- TRUE" },
    { key: "fifo_pop", text: "while (length(q) > 0) {" },
    { key: "fifo_pop", text: "  u <- q[1]; q <- q[-1]; inQ[u] <- FALSE" },
    { key: "fifo_relax", text: "  for (edge in adj[[u]]) {" },
    { key: "fifo_relax", text: "      v <- edge[1]; w <- edge[2]" },
    { key: "fifo_relax", text: "      if (d[u] + w < d[v]) {" },
    { key: "fifo_relax", text: "          d[v] <- d[u] + w; parent[v] <- u" },
    { key: "fifo_relax", text: "          if (!inQ[v]) { q <- c(q, v); inQ[v] <- TRUE }" },
    { key: "fifo_relax", text: "      }" },
    { key: "fifo_relax", text: "  }" },
    { key: "fifo_pop", text: "}" },
  ],
  matlab: [
    { key: "fifo_init", text: "d = inf(1, n); parent = zeros(1, n); inQ = false(1, n);" },
    { key: "fifo_init", text: "d(s) = 0; q = [s]; inQ(s) = true;" },
    { key: "fifo_pop", text: "while ~isempty(q)" },
    { key: "fifo_pop", text: "  u = q(1); q = q(2:end); inQ(u) = false;" },
    { key: "fifo_relax", text: "  for e = 1:size(adj{u}, 1)" },
    { key: "fifo_relax", text: "      v = adj{u}(e, 1); w = adj{u}(e, 2);" },
    { key: "fifo_relax", text: "      if d(u) + w < d(v)" },
    { key: "fifo_relax", text: "          d(v) = d(u) + w; parent(v) = u;" },
    { key: "fifo_relax", text: "          if ~inQ(v), q = [q, v]; inQ(v) = true; end" },
    { key: "fifo_relax", text: "      end" },
    { key: "fifo_relax", text: "  end" },
    { key: "fifo_pop", text: "end" },
  ],
  julia: [
    { key: "fifo_init", text: "d = fill(Inf, n); parent = fill(nothing, n); inQ = fill(false, n)" },
    { key: "fifo_init", text: "d[s] = 0; q = [s]; inQ[s] = true" },
    { key: "fifo_pop", text: "while !isempty(q)" },
    { key: "fifo_pop", text: "  u = popfirst!(q); inQ[u] = false" },
    { key: "fifo_relax", text: "  for (v, w) in adj[u]" },
    { key: "fifo_relax", text: "      if d[u] + w < d[v]" },
    { key: "fifo_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
    { key: "fifo_relax", text: "          if !inQ[v] push!(q, v); inQ[v] = true end" },
    { key: "fifo_relax", text: "      end" },
    { key: "fifo_relax", text: "  end" },
    { key: "fifo_pop", text: "end" },
  ],
};
