// BELLMAN_FORD Algorithm Code Templates
// Templates for all supported languages

export const BELLMAN_FORD_TEMPLATES = {
  cpp: [
    { key: "bf_init", text: "vector<double> d(n, INF); vector<int> parent(n, -1);" },
    { key: "bf_init", text: "d[s] = 0;" },
    { key: "bf_outer", text: "for (int i = 0; i < n - 1; ++i) {" },
    { key: "bf_relax", text: "  for (auto &e : edges) { int u = e.u, v = e.v; double w = e.w;" },
    { key: "bf_relax", text: "    if (d[u] + w < d[v]) {" },
    { key: "bf_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
    { key: "bf_relax", text: "    }" },
    { key: "bf_relax", text: "  }" },
    { key: "bf_outer", text: "}" },
    { key: "bf_check", text: "for (auto &e : edges) {" },
    { key: "bf_neg_cycle", text: "  if (d[e.u] + e.w < d[e.v]) {" },
    { key: "bf_neg_cycle", text: "    // negative cycle reachable from s" },
    { key: "bf_neg_cycle", text: "  }" },
    { key: "bf_check", text: "}" },
  ],
  c: [
    { key: "bf_init", text: "for (int i = 0; i < n; ++i) { d[i] = INF; parent[i] = -1; }" },
    { key: "bf_init", text: "d[s] = 0;" },
    { key: "bf_outer", text: "for (int i = 0; i < n - 1; ++i) {" },
    { key: "bf_relax", text: "  for (int e = 0; e < m; ++e) { int u = U[e], v = V[e]; double w = W[e];" },
    { key: "bf_relax", text: "    if (d[u] + w < d[v]) {" },
    { key: "bf_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
    { key: "bf_relax", text: "    }" },
    { key: "bf_relax", text: "  }" },
    { key: "bf_outer", text: "}" },
    { key: "bf_check", text: "for (int e = 0; e < m; ++e) {" },
    { key: "bf_neg_cycle", text: "  if (d[U[e]] + W[e] < d[V[e]]) {" },
    { key: "bf_neg_cycle", text: "    // negative cycle" },
    { key: "bf_neg_cycle", text: "  }" },
    { key: "bf_check", text: "}" },
  ],
  java: [
    { key: "bf_init", text: "double[] d = new double[n]; int[] parent = new int[n];" },
    { key: "bf_init", text: "Arrays.fill(d, INF); Arrays.fill(parent, -1); d[s] = 0;" },
    { key: "bf_outer", text: "for (int i = 0; i < n - 1; i++) {" },
    { key: "bf_relax", text: "  for (Edge e : edges) { int u = e.u, v = e.v; double w = e.w;" },
    { key: "bf_relax", text: "    if (d[u] + w < d[v]) {" },
    { key: "bf_relax", text: "      d[v] = d[u] + w; parent[v] = u;" },
    { key: "bf_relax", text: "    }" },
    { key: "bf_relax", text: "  }" },
    { key: "bf_outer", text: "}" },
    { key: "bf_check", text: "for (Edge e : edges) {" },
    { key: "bf_neg_cycle", text: "  if (d[e.u] + e.w < d[e.v]) {" },
    { key: "bf_neg_cycle", text: "    // negative cycle" },
    { key: "bf_neg_cycle", text: "  }" },
    { key: "bf_check", text: "}" },
  ],
  python: [
    { key: "bf_init", text: "d = {v: float('inf') for v in V}; parent = {v: None for v in V}" },
    { key: "bf_init", text: "d[s] = 0" },
    { key: "bf_outer", text: "for _ in range(len(V) - 1):" },
    { key: "bf_relax", text: "  for (u, v, w) in E:" },
    { key: "bf_relax", text: "      if d[u] + w < d[v]:" },
    { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
    { key: "bf_check", text: "for (u, v, w) in E:" },
    { key: "bf_neg_cycle", text: "  if d[u] + w < d[v]: print('negative cycle')" },
  ],
  rust: [
    { key: "bf_init", text: "let mut d = vec![f64::INFINITY; n]; let mut parent = vec![None; n];" },
    { key: "bf_init", text: "d[s] = 0.0;" },
    { key: "bf_outer", text: "for _ in 0..n - 1 {" },
    { key: "bf_relax", text: "  for &(u, v, w) in &edges {" },
    { key: "bf_relax", text: "      if d[u] + w < d[v] {" },
    { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = Some(u);" },
    { key: "bf_relax", text: "      }" },
    { key: "bf_relax", text: "  }" },
    { key: "bf_outer", text: "}" },
    { key: "bf_check", text: "for &(u, v, w) in &edges {" },
    { key: "bf_neg_cycle", text: "  if d[u] + w < d[v] { println!(\"negative cycle\"); }" },
    { key: "bf_check", text: "}" },
  ],
  javascript: [
    { key: "bf_init", text: "const d = Array(n).fill(Infinity); const parent = Array(n).fill(null);" },
    { key: "bf_init", text: "d[s] = 0;" },
    { key: "bf_outer", text: "for (let i = 0; i < n - 1; i++) {" },
    { key: "bf_relax", text: "  for (const [u, v, w] of edges) {" },
    { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
    { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
    { key: "bf_relax", text: "      }" },
    { key: "bf_relax", text: "  }" },
    { key: "bf_outer", text: "}" },
    { key: "bf_check", text: "for (const [u, v, w] of edges) {" },
    { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) console.log('negative cycle');" },
    { key: "bf_check", text: "}" },
  ],
  typescript: [
    { key: "bf_init", text: "const d: number[] = Array(n).fill(Infinity); const parent: (number | null)[] = Array(n).fill(null);" },
    { key: "bf_init", text: "d[s] = 0;" },
    { key: "bf_outer", text: "for (let i = 0; i < n - 1; i++) {" },
    { key: "bf_relax", text: "  for (const [u, v, w]: [number, number, number] of edges) {" },
    { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
    { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
    { key: "bf_relax", text: "      }" },
    { key: "bf_relax", text: "  }" },
    { key: "bf_outer", text: "}" },
    { key: "bf_check", text: "for (const [u, v, w]: [number, number, number] of edges) {" },
    { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) console.log('negative cycle');" },
    { key: "bf_check", text: "}" },
  ],
  go: [
    { key: "bf_init", text: "d := make([]float64, n); parent := make([]int, n)" },
    { key: "bf_init", text: "for i := range d { d[i] = math.Inf(1); parent[i] = -1 }" },
    { key: "bf_init", text: "d[s] = 0" },
    { key: "bf_outer", text: "for i := 0; i < n-1; i++ {" },
    { key: "bf_relax", text: "  for _, e := range edges {" },
    { key: "bf_relax", text: "      u, v, w := e.u, e.v, e.w" },
    { key: "bf_relax", text: "      if d[u] + w < d[v] {" },
    { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
    { key: "bf_relax", text: "      }" },
    { key: "bf_relax", text: "  }" },
    { key: "bf_outer", text: "}" },
    { key: "bf_check", text: "for _, e := range edges {" },
    { key: "bf_neg_cycle", text: "  if d[e.u] + e.w < d[e.v] { fmt.Println(\"negative cycle\") }" },
    { key: "bf_check", text: "}" },
  ],
  kotlin: [
    { key: "bf_init", text: "val d = DoubleArray(n) { Double.POSITIVE_INFINITY }" },
    { key: "bf_init", text: "val parent = IntArray(n) { -1 }" },
    { key: "bf_init", text: "d[s] = 0.0" },
    { key: "bf_outer", text: "repeat(n - 1) {" },
    { key: "bf_relax", text: "  edges.forEach { (u, v, w) ->" },
    { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
    { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
    { key: "bf_relax", text: "      }" },
    { key: "bf_relax", text: "  }" },
    { key: "bf_outer", text: "}" },
    { key: "bf_check", text: "edges.forEach { (u, v, w) ->" },
    { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) println(\"negative cycle\")" },
    { key: "bf_check", text: "}" },
  ],
  swift: [
    { key: "bf_init", text: "var d = Array(repeating: Double.infinity, count: n)" },
    { key: "bf_init", text: "var parent = Array(repeating: -1, count: n)" },
    { key: "bf_init", text: "d[s] = 0" },
    { key: "bf_outer", text: "for _ in 0..<n - 1 {" },
    { key: "bf_relax", text: "  for (u, v, w) in edges {" },
    { key: "bf_relax", text: "      if d[u] + w < d[v] {" },
    { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
    { key: "bf_relax", text: "      }" },
    { key: "bf_relax", text: "  }" },
    { key: "bf_outer", text: "}" },
    { key: "bf_check", text: "for (u, v, w) in edges {" },
    { key: "bf_neg_cycle", text: "  if d[u] + w < d[v] { print(\"negative cycle\") }" },
    { key: "bf_check", text: "}" },
  ],
  csharp: [
    { key: "bf_init", text: "double[] d = new double[n]; int[] parent = new int[n];" },
    { key: "bf_init", text: "Array.Fill(d, double.PositiveInfinity); Array.Fill(parent, -1); d[s] = 0;" },
    { key: "bf_outer", text: "for (int i = 0; i < n - 1; i++) {" },
    { key: "bf_relax", text: "  foreach (var (u, v, w) in edges) {" },
    { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
    { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
    { key: "bf_relax", text: "      }" },
    { key: "bf_relax", text: "  }" },
    { key: "bf_outer", text: "}" },
    { key: "bf_check", text: "foreach (var (u, v, w) in edges) {" },
    { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) Console.WriteLine(\"negative cycle\");" },
    { key: "bf_check", text: "}" },
  ],
  ruby: [
    { key: "bf_init", text: "d = Array.new(n, Float::INFINITY); parent = Array.new(n, nil)" },
    { key: "bf_init", text: "d[s] = 0" },
    { key: "bf_outer", text: "(n - 1).times do" },
    { key: "bf_relax", text: "  edges.each do |u, v, w|" },
    { key: "bf_relax", text: "      if d[u] + w < d[v]" },
    { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
    { key: "bf_relax", text: "      end" },
    { key: "bf_relax", text: "  end" },
    { key: "bf_outer", text: "end" },
    { key: "bf_check", text: "edges.each do |u, v, w|" },
    { key: "bf_neg_cycle", text: "  puts 'negative cycle' if d[u] + w < d[v]" },
    { key: "bf_check", text: "end" },
  ],
  php: [
    { key: "bf_init", text: "$d = array_fill(0, $n, INF); $parent = array_fill(0, $n, null);" },
    { key: "bf_init", text: "$d[$s] = 0;" },
    { key: "bf_outer", text: "for ($i = 0; $i < $n - 1; $i++) {" },
    { key: "bf_relax", text: "  foreach ($edges as [$u, $v, $w]) {" },
    { key: "bf_relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
    { key: "bf_relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
    { key: "bf_relax", text: "      }" },
    { key: "bf_relax", text: "  }" },
    { key: "bf_outer", text: "}" },
    { key: "bf_check", text: "foreach ($edges as [$u, $v, $w]) {" },
    { key: "bf_neg_cycle", text: "  if ($d[$u] + $w < $d[$v]) echo 'negative cycle';" },
    { key: "bf_check", text: "}" },
  ],
  scala: [
    { key: "bf_init", text: "val d = Array.fill(n)(Double.PositiveInfinity); val parent = Array.fill(n)(-1)" },
    { key: "bf_init", text: "d(s) = 0" },
    { key: "bf_outer", text: "for (_ <- 0 until n - 1) {" },
    { key: "bf_relax", text: "  edges.foreach { case (u, v, w) =>" },
    { key: "bf_relax", text: "      if (d(u) + w < d(v)) {" },
    { key: "bf_relax", text: "          d(v) = d(u) + w; parent(v) = u" },
    { key: "bf_relax", text: "      }" },
    { key: "bf_relax", text: "  }" },
    { key: "bf_outer", text: "}" },
    { key: "bf_check", text: "edges.foreach { case (u, v, w) =>" },
    { key: "bf_neg_cycle", text: "  if (d(u) + w < d(v)) println(\"negative cycle\")" },
    { key: "bf_check", text: "}" },
  ],
  haskell: [
    { key: "bf_init", text: "d = replicate n (1/0) :: [Double]" },
    { key: "bf_init", text: "parent = replicate n Nothing :: [Maybe Int]" },
    { key: "bf_init", text: "d' = take s d ++ [0] ++ drop (s+1) d" },
    { key: "bf_outer", text: "bf dist par = foldl (\\acc _ -> relaxAll edges acc) (dist, par) [1..n-1]" },
    { key: "bf_relax", text: "relaxAll edges (d, p) = foldl relax (d, p) edges" },
    { key: "bf_relax", text: "relax (d, p) (u, v, w) | d!!u + w < d!!v = (update d v (d!!u + w), update p v (Just u))" },
    { key: "bf_relax", text: "                | otherwise = (d, p)" },
    { key: "bf_check", text: "hasNegCycle edges d = any (\\(u, v, w) -> d!!u + w < d!!v) edges" },
  ],
  ocaml: [
    { key: "bf_init", text: "let d = Array.make n infinity in" },
    { key: "bf_init", text: "let parent = Array.make n None in" },
    { key: "bf_init", text: "d.(s) <- 0.0;" },
    { key: "bf_outer", text: "for _ = 0 to n - 2 do" },
    { key: "bf_relax", text: "  List.iter (fun (u, v, w) ->" },
    { key: "bf_relax", text: "      if d.(u) +. w < d.(v) then (" },
    { key: "bf_relax", text: "          d.(v) <- d.(u) +. w; parent.(v) <- Some u" },
    { key: "bf_relax", text: "      )" },
    { key: "bf_relax", text: "  ) edges" },
    { key: "bf_outer", text: "done" },
    { key: "bf_check", text: "List.iter (fun (u, v, w) ->" },
    { key: "bf_neg_cycle", text: "  if d.(u) +. w < d.(v) then print_string \"negative cycle\"" },
    { key: "bf_check", text: ") edges" },
  ],
  fsharp: [
    { key: "bf_init", text: "let d = Array.create n System.Double.PositiveInfinity" },
    { key: "bf_init", text: "let parent = Array.create n None" },
    { key: "bf_init", text: "d.[s] <- 0.0" },
    { key: "bf_outer", text: "for _ in 0 .. n - 2 do" },
    { key: "bf_relax", text: "  edges |> List.iter (fun (u, v, w) ->" },
    { key: "bf_relax", text: "      if d.[u] + w < d.[v] then (" },
    { key: "bf_relax", text: "          d.[v] <- d.[u] + w; parent.[v] <- Some u" },
    { key: "bf_relax", text: "      )" },
    { key: "bf_relax", text: "  )" },
    { key: "bf_outer", text: "done" },
    { key: "bf_check", text: "edges |> List.iter (fun (u, v, w) ->" },
    { key: "bf_neg_cycle", text: "  if d.[u] + w < d.[v] then printfn \"negative cycle\"" },
    { key: "bf_check", text: ")" },
  ],
  dart: [
    { key: "bf_init", text: "List<double> d = List.filled(n, double.infinity);" },
    { key: "bf_init", text: "List<int?> parent = List.filled(n, null);" },
    { key: "bf_init", text: "d[s] = 0;" },
    { key: "bf_outer", text: "for (int i = 0; i < n - 1; i++) {" },
    { key: "bf_relax", text: "  for (var (u, v, w) in edges) {" },
    { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
    { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u;" },
    { key: "bf_relax", text: "      }" },
    { key: "bf_relax", text: "  }" },
    { key: "bf_outer", text: "}" },
    { key: "bf_check", text: "for (var (u, v, w) in edges) {" },
    { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) print('negative cycle');" },
    { key: "bf_check", text: "}" },
  ],
  lua: [
    { key: "bf_init", text: "local d = {}; local parent = {}" },
    { key: "bf_init", text: "for i = 1, n do d[i] = math.huge; parent[i] = nil end" },
    { key: "bf_init", text: "d[s] = 0" },
    { key: "bf_outer", text: "for _ = 1, n - 1 do" },
    { key: "bf_relax", text: "  for _, edge in ipairs(edges) do" },
    { key: "bf_relax", text: "      local u, v, w = edge[1], edge[2], edge[3]" },
    { key: "bf_relax", text: "      if d[u] + w < d[v] then" },
    { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
    { key: "bf_relax", text: "      end" },
    { key: "bf_relax", text: "  end" },
    { key: "bf_outer", text: "end" },
    { key: "bf_check", text: "for _, edge in ipairs(edges) do" },
    { key: "bf_neg_cycle", text: "  local u, v, w = edge[1], edge[2], edge[3]" },
    { key: "bf_neg_cycle", text: "  if d[u] + w < d[v] then print('negative cycle') end" },
    { key: "bf_check", text: "end" },
  ],
  perl: [
    { key: "bf_init", text: "my @d = (inf) x $n; my @parent = (undef) x $n;" },
    { key: "bf_init", text: "$d[$s] = 0;" },
    { key: "bf_outer", text: "for my $i (0 .. $n - 2) {" },
    { key: "bf_relax", text: "  for my $edge (@edges) {" },
    { key: "bf_relax", text: "      my ($u, $v, $w) = @$edge;" },
    { key: "bf_relax", text: "      if ($d[$u] + $w < $d[$v]) {" },
    { key: "bf_relax", text: "          $d[$v] = $d[$u] + $w; $parent[$v] = $u;" },
    { key: "bf_relax", text: "      }" },
    { key: "bf_relax", text: "  }" },
    { key: "bf_outer", text: "}" },
    { key: "bf_check", text: "for my $edge (@edges) {" },
    { key: "bf_neg_cycle", text: "  my ($u, $v, $w) = @$edge;" },
    { key: "bf_neg_cycle", text: "  if ($d[$u] + $w < $d[$v]) { print \"negative cycle\\n\" }" },
    { key: "bf_check", text: "}" },
  ],
  r: [
    { key: "bf_init", text: "d <- rep(Inf, n); parent <- rep(NA, n)" },
    { key: "bf_init", text: "d[s] <- 0" },
    { key: "bf_outer", text: "for (i in 1:(n-1)) {" },
    { key: "bf_relax", text: "  for (edge in edges) {" },
    { key: "bf_relax", text: "      u <- edge[1]; v <- edge[2]; w <- edge[3]" },
    { key: "bf_relax", text: "      if (d[u] + w < d[v]) {" },
    { key: "bf_relax", text: "          d[v] <- d[u] + w; parent[v] <- u" },
    { key: "bf_relax", text: "      }" },
    { key: "bf_relax", text: "  }" },
    { key: "bf_outer", text: "}" },
    { key: "bf_check", text: "for (edge in edges) {" },
    { key: "bf_neg_cycle", text: "  u <- edge[1]; v <- edge[2]; w <- edge[3]" },
    { key: "bf_neg_cycle", text: "  if (d[u] + w < d[v]) cat(\"negative cycle\\n\")" },
    { key: "bf_check", text: "}" },
  ],
  matlab: [
    { key: "bf_init", text: "d = inf(1, n); parent = zeros(1, n);" },
    { key: "bf_init", text: "d(s) = 0;" },
    { key: "bf_outer", text: "for i = 1:n-1" },
    { key: "bf_relax", text: "  for e = 1:size(edges, 1)" },
    { key: "bf_relax", text: "      u = edges(e, 1); v = edges(e, 2); w = edges(e, 3);" },
    { key: "bf_relax", text: "      if d(u) + w < d(v)" },
    { key: "bf_relax", text: "          d(v) = d(u) + w; parent(v) = u;" },
    { key: "bf_relax", text: "      end" },
    { key: "bf_relax", text: "  end" },
    { key: "bf_outer", text: "end" },
    { key: "bf_check", text: "for e = 1:size(edges, 1)" },
    { key: "bf_neg_cycle", text: "  u = edges(e, 1); v = edges(e, 2); w = edges(e, 3);" },
    { key: "bf_neg_cycle", text: "  if d(u) + w < d(v), fprintf('negative cycle\\n'); end" },
    { key: "bf_check", text: "end" },
  ],
  julia: [
    { key: "bf_init", text: "d = fill(Inf, n); parent = fill(nothing, n)" },
    { key: "bf_init", text: "d[s] = 0" },
    { key: "bf_outer", text: "for _ in 1:n-1" },
    { key: "bf_relax", text: "  for (u, v, w) in edges" },
    { key: "bf_relax", text: "      if d[u] + w < d[v]" },
    { key: "bf_relax", text: "          d[v] = d[u] + w; parent[v] = u" },
    { key: "bf_relax", text: "      end" },
    { key: "bf_relax", text: "  end" },
    { key: "bf_outer", text: "end" },
    { key: "bf_check", text: "for (u, v, w) in edges" },
    { key: "bf_neg_cycle", text: "  if d[u] + w < d[v] println(\"negative cycle\") end" },
    { key: "bf_check", text: "end" },
  ],
};
